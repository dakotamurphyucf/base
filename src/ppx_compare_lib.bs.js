// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Printf$negBase = require("./printf.bs.js");
var Import0$negBase = require("./import0.bs.js");

function compare_abstract(type_name, param, param$1) {
  return Curry._1(Printf$negBase.ksprintf(Import0$negBase.failwith, /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Compare called on the type ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ", which is abstract in an implementation.",
                        _1: /* End_of_format */0
                      }
                    }
                  },
                  _1: "Compare called on the type %s, which is abstract in an implementation."
                }), type_name);
}

function equal_abstract(type_name, param, param$1) {
  return Curry._1(Printf$negBase.ksprintf(Import0$negBase.failwith, /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Equal called on the type ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ", which is abstract in an implementation.",
                        _1: /* End_of_format */0
                      }
                    }
                  },
                  _1: "Equal called on the type %s, which is abstract in an implementation."
                }), type_name);
}

var compare_bool = Caml.caml_int_compare;

var compare_char = Caml.caml_int_compare;

var compare_float = Caml.caml_float_compare;

var compare_int = Caml.caml_int_compare;

var compare_int32 = Caml.caml_int_compare;

var compare_int64 = Caml_int64.compare;

var compare_nativeint = Caml.caml_int_compare;

var compare_string = Caml.caml_string_compare;

var compare_unit = Caml.caml_int_compare;

function compare_array(compare_elt, a, b) {
  if (Import0$negBase.phys_equal(a, b)) {
    return 0;
  }
  var len_a = a.length;
  var len_b = b.length;
  var ret = Import0$negBase.compare(len_a, len_b);
  if (Import0$negBase.$less$great(ret, 0)) {
    return ret;
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (Import0$negBase.$eq(i, len_a)) {
      return 0;
    }
    var l = a[i];
    var r = b[i];
    var res = Curry._2(compare_elt, l, r);
    if (Import0$negBase.$less$great(res, 0)) {
      return res;
    }
    _i = Import0$negBase.$plus(i, 1);
    continue ;
  };
}

function compare_list(compare_elt, _a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (!a) {
      if (b) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!b) {
      return 1;
    }
    var res = Curry._2(compare_elt, a.hd, b.hd);
    if (Import0$negBase.$less$great(res, 0)) {
      return res;
    }
    _b = b.tl;
    _a = a.tl;
    continue ;
  };
}

function compare_option(compare_elt, a, b) {
  if (a !== undefined) {
    if (b !== undefined) {
      return Curry._2(compare_elt, Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return 1;
    }
  } else if (b !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function compare_ref(compare_elt, a, b) {
  return Curry._2(compare_elt, a[0], b[0]);
}

function equal_bool(prim, prim$1) {
  return prim === prim$1;
}

function equal_char(prim, prim$1) {
  return prim === prim$1;
}

function equal_int(prim, prim$1) {
  return prim === prim$1;
}

function equal_int32(prim, prim$1) {
  return prim === prim$1;
}

var equal_int64 = Caml.i64_eq;

function equal_nativeint(prim, prim$1) {
  return prim === prim$1;
}

function equal_string(prim, prim$1) {
  return prim === prim$1;
}

function equal_unit(prim, prim$1) {
  return prim === prim$1;
}

function equal_float(x, y) {
  return Caml.caml_float_compare(x, y) === 0;
}

function equal_array(equal_elt, a, b) {
  if (Import0$negBase.phys_equal(a, b)) {
    return true;
  }
  var len_a = a.length;
  var len_b = b.length;
  if (!Import0$negBase.equal(len_a, len_b)) {
    return false;
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (Import0$negBase.$eq(i, len_a)) {
      return true;
    }
    var l = a[i];
    var r = b[i];
    if (!Curry._2(equal_elt, l, r)) {
      return false;
    }
    _i = Import0$negBase.$plus(i, 1);
    continue ;
  };
}

function equal_list(equal_elt, _a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (!a) {
      if (b) {
        return false;
      } else {
        return true;
      }
    }
    if (!b) {
      return false;
    }
    if (!Curry._2(equal_elt, a.hd, b.hd)) {
      return false;
    }
    _b = b.tl;
    _a = a.tl;
    continue ;
  };
}

function equal_option(equal_elt, a, b) {
  if (a !== undefined) {
    if (b !== undefined) {
      return Curry._2(equal_elt, Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return false;
    }
  } else {
    return b === undefined;
  }
}

function equal_ref(equal_elt, a, b) {
  return Curry._2(equal_elt, a[0], b[0]);
}

var phys_equal = Import0$negBase.phys_equal;

var Builtin = {
  compare_bool: compare_bool,
  compare_char: compare_char,
  compare_float: compare_float,
  compare_int: compare_int,
  compare_int32: compare_int32,
  compare_int64: compare_int64,
  compare_nativeint: compare_nativeint,
  compare_string: compare_string,
  compare_unit: compare_unit,
  compare_array: compare_array,
  compare_list: compare_list,
  compare_option: compare_option,
  compare_ref: compare_ref,
  equal_bool: equal_bool,
  equal_char: equal_char,
  equal_float: equal_float,
  equal_int: equal_int,
  equal_int32: equal_int32,
  equal_int64: equal_int64,
  equal_nativeint: equal_nativeint,
  equal_string: equal_string,
  equal_unit: equal_unit,
  equal_array: equal_array,
  equal_list: equal_list,
  equal_option: equal_option,
  equal_ref: equal_ref
};

exports.phys_equal = phys_equal;
exports.compare_abstract = compare_abstract;
exports.equal_abstract = equal_abstract;
exports.Builtin = Builtin;
/* Printf-Base Not a pure module */
