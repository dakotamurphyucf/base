// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Sexp$negBase = require("./sexp.bs.js");
var Error$negBase = require("./error.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");

function max(x, y) {
  if (Import$negBase.$great(x, y)) {
    return x;
  } else {
    return y;
  }
}

function is_empty(param) {
  if (typeof param === "number") {
    return true;
  } else {
    return false;
  }
}

function height(param) {
  if (typeof param === "number") {
    return 0;
  } else if (param.TAG === /* Node */0) {
    return param.height;
  } else {
    return 1;
  }
}

function invariant(compare) {
  var legal_left_key = function (key, param) {
    var left_key;
    if (typeof param === "number") {
      return ;
    }
    left_key = param.TAG === /* Node */0 ? param.key : param.key;
    if (Import$negBase.$less(Curry._2(compare, left_key, key), 0)) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "avltree.ml",
            50,
            6
          ],
          Error: new Error()
        };
  };
  var legal_right_key = function (key, param) {
    var right_key;
    if (typeof param === "number") {
      return ;
    }
    right_key = param.TAG === /* Node */0 ? param.key : param.key;
    if (Import$negBase.$great(Curry._2(compare, right_key, key), 0)) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "avltree.ml",
            56,
            6
          ],
          Error: new Error()
        };
  };
  var inv = function (param) {
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG !== /* Node */0) {
      return ;
    }
    var left = param.left;
    var k = param.key;
    var h = param.height;
    var right = param.right;
    var hl = height(left);
    var hr = height(right);
    inv(left);
    inv(right);
    legal_left_key(k, left);
    legal_right_key(k, right);
    if (h !== Import$negBase.$plus(max(hl, hr), 1)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              66,
              6
            ],
            Error: new Error()
          };
    }
    if (Import$negBase.$less$eq(Import$negBase.abs(Import$negBase.$neg(hl, hr)), 2)) {
      return ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "avltree.ml",
            67,
            6
          ],
          Error: new Error()
        };
  };
  return inv;
}

function invariant$1(t, compare) {
  return invariant(compare)(t);
}

function update_height(x) {
  if (typeof x === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "avltree.ml",
            87,
            22
          ],
          Error: new Error()
        };
  }
  if (x.TAG === /* Node */0) {
    var left = x.left;
    var old_height = x.height;
    var right = x.right;
    var new_height = Import$negBase.$plus(max(height(left), height(right)), 1);
    if (Import$negBase.$less$great(new_height, old_height)) {
      x.height = new_height;
      return ;
    } else {
      return ;
    }
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "avltree.ml",
          87,
          22
        ],
        Error: new Error()
      };
}

function balance(tree) {
  if (typeof tree === "number") {
    return tree;
  }
  if (tree.TAG !== /* Node */0) {
    return tree;
  }
  var left = tree.left;
  var right = tree.right;
  var hl = height(left);
  var hr = height(right);
  if (Import$negBase.$great(hl, Import$negBase.$plus(hr, 2))) {
    if (typeof left === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              110,
              26
            ],
            Error: new Error()
          };
    }
    if (left.TAG === /* Node */0) {
      var left_node_left = left.left;
      var left_node_right = left.right;
      if (Import$negBase.$great$eq(height(left_node_left), height(left_node_right))) {
        tree.left = left_node_right;
        left.right = tree;
        update_height(tree);
        update_height(left);
        return left;
      }
      if (typeof left_node_right === "number") {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "avltree.ml",
                129,
                30
              ],
              Error: new Error()
            };
      }
      if (left_node_right.TAG === /* Node */0) {
        var lr_left = left_node_right.left;
        var lr_right = left_node_right.right;
        left.right = lr_left;
        tree.left = lr_right;
        left_node_right.right = tree;
        left_node_right.left = left;
        update_height(left);
        update_height(tree);
        update_height(left_node_right);
        return left_node_right;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              129,
              30
            ],
            Error: new Error()
          };
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              110,
              26
            ],
            Error: new Error()
          };
    }
  } else if (Import$negBase.$great(hr, Import$negBase.$plus(hl, 2))) {
    if (typeof right === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              145,
              26
            ],
            Error: new Error()
          };
    }
    if (right.TAG === /* Node */0) {
      var right_node_left = right.left;
      var right_node_right = right.right;
      if (Import$negBase.$great$eq(height(right_node_right), height(right_node_left))) {
        tree.right = right_node_left;
        right.left = tree;
        update_height(tree);
        update_height(right);
        return right;
      }
      if (typeof right_node_left === "number") {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "avltree.ml",
                163,
                30
              ],
              Error: new Error()
            };
      }
      if (right_node_left.TAG === /* Node */0) {
        var rl_left = right_node_left.left;
        var rl_right = right_node_left.right;
        right.left = rl_right;
        tree.right = rl_left;
        right_node_left.left = tree;
        right_node_left.right = right;
        update_height(right);
        update_height(tree);
        update_height(right_node_left);
        return right_node_left;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              163,
              30
            ],
            Error: new Error()
          };
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              145,
              26
            ],
            Error: new Error()
          };
    }
  } else {
    update_height(tree);
    return tree;
  }
}

function set_left(node, tree) {
  var tree$1 = balance(tree);
  if (typeof node === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "avltree.ml",
            193,
            9
          ],
          Error: new Error()
        };
  }
  if (node.TAG === /* Node */0) {
    var left = node.left;
    if (Import$negBase.phys_equal(left, tree$1)) {
      
    } else {
      node.left = tree$1;
    }
    return update_height(node);
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "avltree.ml",
          193,
          9
        ],
        Error: new Error()
      };
}

function set_right(node, tree) {
  var tree$1 = balance(tree);
  if (typeof node === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "avltree.ml",
            205,
            9
          ],
          Error: new Error()
        };
  }
  if (node.TAG === /* Node */0) {
    var right = node.right;
    if (Import$negBase.phys_equal(right, tree$1)) {
      
    } else {
      node.right = tree$1;
    }
    return update_height(node);
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "avltree.ml",
          205,
          9
        ],
        Error: new Error()
      };
}

function add(t, replace, added, compare, k, v) {
  if (typeof t === "number") {
    added[0] = true;
    return {
            TAG: /* Leaf */1,
            key: k,
            value: v
          };
  }
  if (t.TAG === /* Node */0) {
    var left = t.left;
    var right = t.right;
    var c = Curry._2(compare, k, t.key);
    if (c === 0) {
      added[0] = false;
      if (replace) {
        t.value = v;
      }
      
    } else if (Import$negBase.$less(c, 0)) {
      set_left(t, add(left, replace, added, compare, k, v));
    } else {
      set_right(t, add(right, replace, added, compare, k, v));
    }
    return t;
  }
  var c$1 = Curry._2(compare, t.key, k);
  if (c$1 === 0) {
    added[0] = false;
    if (replace) {
      t.value = v;
    }
    return t;
  } else {
    added[0] = true;
    if (Import$negBase.$less(c$1, 0)) {
      return {
              TAG: /* Node */0,
              left: t,
              key: k,
              value: v,
              height: 2,
              right: /* Empty */0
            };
    } else {
      return {
              TAG: /* Node */0,
              left: /* Empty */0,
              key: k,
              value: v,
              height: 2,
              right: t
            };
    }
  }
}

function add$1(t, replace, compare, added, key, data) {
  var t$1 = add(t, replace, added, compare, key, data);
  if (added[0]) {
    return balance(t$1);
  } else {
    return t$1;
  }
}

function first(_t) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Node */0) {
      var l = t.left;
      if (typeof l === "number") {
        var v = t.value;
        return [
                t.key,
                v
              ];
      }
      _t = l;
      continue ;
    }
    var v$1 = t.value;
    return [
            t.key,
            v$1
          ];
  };
}

function last(_t) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Node */0) {
      var v = t.value;
      var match = t.right;
      if (typeof match === "number") {
        return [
                t.key,
                v
              ];
      }
      _t = t.right;
      continue ;
    }
    var v$1 = t.value;
    return [
            t.key,
            v$1
          ];
  };
}

function findi_and_call_impl(_t, compare, k, arg1, arg2, call_if_found, call_if_not_found, if_found, if_not_found) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return Curry._4(call_if_not_found, if_not_found, k, arg1, arg2);
    }
    if (t.TAG === /* Node */0) {
      var left = t.left;
      var k$p = t.key;
      var v = t.value;
      var right = t.right;
      var c = Curry._2(compare, k, k$p);
      if (c === 0) {
        return Curry._5(call_if_found, if_found, k$p, v, arg1, arg2);
      }
      _t = Import$negBase.$less(c, 0) ? left : right;
      continue ;
    }
    var k$p$1 = t.key;
    var v$1 = t.value;
    if (Curry._2(compare, k, k$p$1) === 0) {
      return Curry._5(call_if_found, if_found, k$p$1, v$1, arg1, arg2);
    } else {
      return Curry._4(call_if_not_found, if_not_found, k, arg1, arg2);
    }
  };
}

function call_if_found(if_found, param, data, param$1, param$2) {
  return Curry._1(if_found, data);
}

function call_if_not_found(if_not_found, key, param, param$1) {
  return Curry._1(if_not_found, key);
}

function find_and_call(t, compare, k, if_found, if_not_found) {
  return findi_and_call_impl(t, compare, k, undefined, undefined, call_if_found, call_if_not_found, if_found, if_not_found);
}

function call_if_found$1(if_found, key, data, param, param$1) {
  return Curry._2(if_found, key, data);
}

function call_if_not_found$1(if_not_found, key, param, param$1) {
  return Curry._1(if_not_found, key);
}

function findi_and_call(t, compare, k, if_found, if_not_found) {
  return findi_and_call_impl(t, compare, k, undefined, undefined, call_if_found$1, call_if_not_found$1, if_found, if_not_found);
}

function call_if_found$2(if_found, param, data, arg, param$1) {
  return Curry._2(if_found, data, arg);
}

function call_if_not_found$2(if_not_found, key, arg, param) {
  return Curry._2(if_not_found, key, arg);
}

function find_and_call1(t, compare, k, a, if_found, if_not_found) {
  return findi_and_call_impl(t, compare, k, a, undefined, call_if_found$2, call_if_not_found$2, if_found, if_not_found);
}

function call_if_found$3(if_found, key, data, arg, param) {
  return Curry._3(if_found, key, data, arg);
}

function call_if_not_found$3(if_not_found, key, arg, param) {
  return Curry._2(if_not_found, key, arg);
}

function findi_and_call1(t, compare, k, a, if_found, if_not_found) {
  return findi_and_call_impl(t, compare, k, a, undefined, call_if_found$3, call_if_not_found$3, if_found, if_not_found);
}

function call_if_found$4(if_found, param, data, arg1, arg2) {
  return Curry._3(if_found, data, arg1, arg2);
}

function call_if_not_found$4(if_not_found, key, arg1, arg2) {
  return Curry._3(if_not_found, key, arg1, arg2);
}

function find_and_call2(t, compare, k, a, b, if_found, if_not_found) {
  return findi_and_call_impl(t, compare, k, a, b, call_if_found$4, call_if_not_found$4, if_found, if_not_found);
}

function call_if_found$5(if_found, key, data, arg1, arg2) {
  return Curry._4(if_found, key, data, arg1, arg2);
}

function call_if_not_found$5(if_not_found, key, arg1, arg2) {
  return Curry._3(if_not_found, key, arg1, arg2);
}

function findi_and_call2(t, compare, k, a, b, if_found, if_not_found) {
  return findi_and_call_impl(t, compare, k, a, b, call_if_found$5, call_if_not_found$5, if_found, if_not_found);
}

function if_found(v) {
  return Caml_option.some(v);
}

function if_not_found(param) {
  
}

function find(t, compare, k) {
  return find_and_call(t, compare, k, if_found, if_not_found);
}

function if_found$1(param) {
  return true;
}

function if_not_found$1(param) {
  return false;
}

function mem(t, compare, k) {
  return find_and_call(t, compare, k, if_found$1, if_not_found$1);
}

function min_elt(_tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return /* Empty */0;
    }
    if (tree.TAG !== /* Node */0) {
      return tree;
    }
    var left = tree.left;
    if (typeof left === "number") {
      return tree;
    }
    _tree = left;
    continue ;
  };
}

function remove_min_elt(tree) {
  if (typeof tree === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "avltree.ml",
            417,
            15
          ],
          Error: new Error()
        };
  }
  if (tree.TAG !== /* Node */0) {
    return /* Empty */0;
  }
  var left = tree.left;
  if (typeof left === "number") {
    return tree.right;
  }
  if (left.TAG === /* Node */0) {
    set_left(tree, remove_min_elt(left));
    return tree;
  }
  var v = tree.value;
  var match = tree.right;
  if (typeof match === "number") {
    return {
            TAG: /* Leaf */1,
            key: tree.key,
            value: v
          };
  } else {
    set_left(tree, /* Empty */0);
    return tree;
  }
}

function remove(t, removed, compare, k) {
  if (typeof t === "number") {
    removed[0] = false;
    return /* Empty */0;
  }
  if (t.TAG !== /* Node */0) {
    if (Curry._2(compare, k, t.key) === 0) {
      removed[0] = true;
      return /* Empty */0;
    } else {
      removed[0] = false;
      return t;
    }
  }
  var left = t.left;
  var right = t.right;
  var c = Curry._2(compare, k, t.key);
  if (c === 0) {
    removed[0] = true;
    if (typeof left === "number") {
      return right;
    }
    if (typeof right === "number") {
      return left;
    }
    var tree = min_elt(right);
    if (typeof tree === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "avltree.ml",
              436,
              18
            ],
            Error: new Error()
          };
    }
    if (tree.TAG === /* Node */0) {
      set_right(tree, remove_min_elt(right));
      set_left(tree, left);
      return tree;
    }
    var v = tree.value;
    var t2 = balance(remove_min_elt(right));
    return {
            TAG: /* Node */0,
            left: left,
            key: tree.key,
            value: v,
            height: Import$negBase.$plus(max(height(left), height(t2)), 1),
            right: t2
          };
  } else if (Import$negBase.$less(c, 0)) {
    set_left(t, remove(left, removed, compare, k));
    return t;
  } else {
    set_right(t, remove(right, removed, compare, k));
    return t;
  }
}

function remove$1(t, removed, compare, k) {
  return balance(remove(t, removed, compare, k));
}

function fold(_t, _init, f) {
  while(true) {
    var init = _init;
    var t = _t;
    if (typeof t === "number") {
      return init;
    }
    if (t.TAG === /* Node */0) {
      var left = t.left;
      var exit = 0;
      if (typeof left === "number") {
        var data = t.value;
        var match = t.right;
        if (typeof match !== "number" && match.TAG !== /* Node */0) {
          var rdata = match.value;
          return Curry._3(f, match.key, rdata, Curry._3(f, t.key, data, init));
        }
        
      } else if (left.TAG === /* Node */0) {
        var data$1 = t.value;
        var match$1 = t.right;
        if (typeof match$1 === "number" || match$1.TAG === /* Node */0) {
          exit = 2;
        } else {
          var rdata$1 = match$1.value;
          return Curry._3(f, match$1.key, rdata$1, Curry._3(f, t.key, data$1, fold(left, init, f)));
        }
      } else {
        var lkey = left.key;
        var ldata = left.value;
        var key = t.key;
        var data$2 = t.value;
        var match$2 = t.right;
        if (typeof match$2 === "number") {
          return Curry._3(f, key, data$2, Curry._3(f, lkey, ldata, init));
        }
        if (match$2.TAG === /* Node */0) {
          exit = 2;
        } else {
          var rdata$2 = match$2.value;
          return Curry._3(f, match$2.key, rdata$2, Curry._3(f, key, data$2, Curry._3(f, lkey, ldata, init)));
        }
      }
      if (exit === 2 && typeof left !== "number" && left.TAG !== /* Node */0) {
        var ldata$1 = left.value;
        var data$3 = t.value;
        var right = t.right;
        _init = Curry._3(f, t.key, data$3, Curry._3(f, left.key, ldata$1, init));
        _t = right;
        continue ;
      }
      var data$4 = t.value;
      var right$1 = t.right;
      _init = Curry._3(f, t.key, data$4, fold(left, init, f));
      _t = right$1;
      continue ;
    }
    var data$5 = t.value;
    return Curry._3(f, t.key, data$5, init);
  };
}

function iter(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Node */0) {
      var left = t.left;
      var data = t.value;
      var right = t.right;
      iter(left, f);
      Curry._2(f, t.key, data);
      _t = right;
      continue ;
    }
    var data$1 = t.value;
    return Curry._2(f, t.key, data$1);
  };
}

function mapi_inplace(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Node */0) {
      var left = t.left;
      var value = t.value;
      var right = t.right;
      mapi_inplace(left, f);
      t.value = Curry._2(f, t.key, value);
      _t = right;
      continue ;
    }
    var value$1 = t.value;
    t.value = Curry._2(f, t.key, value$1);
    return ;
  };
}

function choose_exn(param) {
  if (typeof param === "number") {
    return Error$negBase.raise_s(Sexp$negBase.message("[Avltree.choose_exn] of empty hashtbl", /* [] */0));
  }
  if (param.TAG === /* Node */0) {
    var value = param.value;
    return [
            param.key,
            value
          ];
  }
  var value$1 = param.value;
  return [
          param.key,
          value$1
        ];
}

var empty = /* Empty */0;

exports.empty = empty;
exports.is_empty = is_empty;
exports.invariant = invariant$1;
exports.add = add$1;
exports.first = first;
exports.last = last;
exports.find = find;
exports.find_and_call = find_and_call;
exports.find_and_call1 = find_and_call1;
exports.find_and_call2 = find_and_call2;
exports.findi_and_call = findi_and_call;
exports.findi_and_call1 = findi_and_call1;
exports.findi_and_call2 = findi_and_call2;
exports.mem = mem;
exports.remove = remove$1;
exports.fold = fold;
exports.iter = iter;
exports.mapi_inplace = mapi_inplace;
exports.choose_exn = choose_exn;
/* Sexp-Base Not a pure module */
