// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int32 = require("bs-platform/lib/js/int32.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Random = require("bs-platform/lib/js/random.js");
var Int0$negBase = require("./int0.bs.js");
var Lazy$negBase = require("./lazy.bs.js");
var Nativeint = require("bs-platform/lib/js/nativeint.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Char0$negBase = require("./char0.bs.js");
var Array0$negBase = require("./array0.bs.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Word_size$negBase = require("./word_size.bs.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_external_polyfill = require("bs-platform/lib/js/caml_external_polyfill.js");

function forbid_nondeterminism_in_tests(allow_in_tests) {
  if (Import$negBase.am_testing && !(allow_in_tests !== undefined && allow_in_tests)) {
    return Import$negBase.failwith("initializing Random with a nondeterministic seed is forbidden in inline tests");
  }
  
}

function bits(t) {
  return Random.State.bits(CamlinternalLazy.force(t));
}

function bool(t) {
  return Random.State.bool(CamlinternalLazy.force(t));
}

function $$int(t, x) {
  return Random.State.$$int(CamlinternalLazy.force(t), x);
}

function int32(t, x) {
  return Random.State.int32(CamlinternalLazy.force(t), x);
}

function int64(t, x) {
  return Random.State.int64(CamlinternalLazy.force(t), x);
}

function nativeint(t, x) {
  return Curry._2(Random.State.nativeint, CamlinternalLazy.force(t), x);
}

function make(seed) {
  return Lazy$negBase.from_val(Random.State.make(seed));
}

function copy(t) {
  return Lazy$negBase.from_val(Random.State.copy(CamlinternalLazy.force(t)));
}

function $$char(t) {
  return Char0$negBase.unsafe_of_int($$int(t, 256));
}

function ascii(t) {
  return Char0$negBase.unsafe_of_int($$int(t, 128));
}

function make_self_init(allow_in_tests, param) {
  forbid_nondeterminism_in_tests(allow_in_tests);
  return Lazy$negBase.from_val(Random.State.make_self_init(undefined));
}

function assign(t1, t2) {
  var t1$1 = CamlinternalLazy.force(t1);
  var t2$1 = CamlinternalLazy.force(t2);
  Array0$negBase.blit(t2$1.st, 0, t1$1.st, 0, t1$1.st.length);
  t1$1.idx = t2$1.idx;
  
}

var $$default;

if (Import$negBase.am_testing) {
  var t = Random.get_state(undefined);
  Random.init(137);
  $$default = Lazy$negBase.from_val(t);
} else {
  $$default = {
    LAZY_DONE: false,
    VAL: (function () {
        return CamlinternalLazy.force(make_self_init(undefined, undefined));
      })
  };
}

function int_on_64bits(t, bound) {
  if (Import$negBase.$less$eq(bound, 1073741823)) {
    return $$int(t, bound);
  } else {
    return Caml_int64.to_int32(int64(t, Caml_int64.of_int32(bound)));
  }
}

function int_on_32bits(t, bound) {
  if (Import$negBase.$less$eq(bound, 1073741823)) {
    return $$int(t, bound);
  } else {
    return int32(t, bound);
  }
}

var $$int$1 = Word_size$negBase.word_size ? int_on_64bits : int_on_32bits;

function full_range_int64(state) {
  return Caml_int64.xor(Caml_int64.of_int32(Random.State.bits(CamlinternalLazy.force(state))), Caml_int64.xor(Caml_int64.lsl_(Caml_int64.of_int32(Random.State.bits(CamlinternalLazy.force(state))), 30), Caml_int64.lsl_(Caml_int64.of_int32(Random.State.bits(CamlinternalLazy.force(state))), 60)));
}

function full_range_int32(state) {
  return Random.State.bits(CamlinternalLazy.force(state)) ^ (Random.State.bits(CamlinternalLazy.force(state)) << 30);
}

function full_range_int_on_64bits(state) {
  return Caml_int64.to_int32(full_range_int64(state));
}

var full_range_int_on_32bits = full_range_int32;

var full_range_int = Word_size$negBase.word_size ? full_range_int_on_64bits : full_range_int_on_32bits;

function full_range_nativeint_on_64bits(state) {
  return Caml_int64.to_int32(full_range_int64(state));
}

var full_range_nativeint_on_32bits = full_range_int32;

var full_range_nativeint = Word_size$negBase.word_size ? full_range_nativeint_on_64bits : full_range_nativeint_on_32bits;

function raise_crossed_bounds(name, lower_bound, upper_bound, string_of_bound) {
  return Curry._4(Printf$negBase.failwithf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Random.",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": crossed bounds [",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " > ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ']' */93,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "Random.%s: crossed bounds [%s > %s]"
                }), name, Curry._1(string_of_bound, lower_bound), Curry._1(string_of_bound, upper_bound), undefined);
}

function int_incl(state, lo, hi) {
  if (Import$negBase.$great(lo, hi)) {
    raise_crossed_bounds("int", lo, hi, Int0$negBase.to_string);
  }
  var diff = Import$negBase.$neg(hi, lo);
  if (diff === Int0$negBase.max_value) {
    return Import$negBase.$plus(lo, Import$negBase.land(Curry._1(full_range_int, state), Int0$negBase.max_value));
  } else if (Import$negBase.$great$eq(diff, 0)) {
    return Import$negBase.$plus(lo, Curry._2($$int$1, state, Int0$negBase.succ(diff)));
  } else {
    while(true) {
      var $$int$2 = Curry._1(full_range_int, state);
      if (Import$negBase.$great$eq($$int$2, lo) && Import$negBase.$less$eq($$int$2, hi)) {
        return $$int$2;
      }
      continue ;
    };
  }
}

function int32_incl(state, lo, hi) {
  if (Curry._2(Import$negBase.Int32_replace_polymorphic_compare.$great, lo, hi)) {
    raise_crossed_bounds("int32", lo, hi, Int32.to_string);
  }
  var diff = hi - lo | 0;
  if (Curry._2(Import$negBase.Int32_replace_polymorphic_compare.$eq, diff, Int32.max_int)) {
    return lo + (full_range_int32(state) & Int32.max_int) | 0;
  } else if (Curry._2(Import$negBase.Int32_replace_polymorphic_compare.$great$eq, diff, 0)) {
    return lo + int32(state, Int32.succ(diff)) | 0;
  } else {
    while(true) {
      var $$int = full_range_int32(state);
      if (Curry._2(Import$negBase.Int32_replace_polymorphic_compare.$great$eq, $$int, lo) && Curry._2(Import$negBase.Int32_replace_polymorphic_compare.$less$eq, $$int, hi)) {
        return $$int;
      }
      continue ;
    };
  }
}

function nativeint_incl(state, lo, hi) {
  if (Curry._2(Import$negBase.Nativeint_replace_polymorphic_compare.$great, lo, hi)) {
    raise_crossed_bounds("nativeint", lo, hi, Nativeint.to_string);
  }
  var diff = hi - lo | 0;
  if (Curry._2(Import$negBase.Nativeint_replace_polymorphic_compare.$eq, diff, Nativeint.max_int)) {
    return lo + (Curry._1(full_range_nativeint, state) & Nativeint.max_int) | 0;
  } else if (Curry._2(Import$negBase.Nativeint_replace_polymorphic_compare.$great$eq, diff, 0)) {
    return lo + nativeint(state, Nativeint.succ(diff)) | 0;
  } else {
    while(true) {
      var $$int = Curry._1(full_range_nativeint, state);
      if (Curry._2(Import$negBase.Nativeint_replace_polymorphic_compare.$great$eq, $$int, lo) && Curry._2(Import$negBase.Nativeint_replace_polymorphic_compare.$less$eq, $$int, hi)) {
        return $$int;
      }
      continue ;
    };
  }
}

function int64_incl(state, lo, hi) {
  if (Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$great, lo, hi)) {
    raise_crossed_bounds("int64", lo, hi, Int64.to_string);
  }
  var diff = Caml_int64.sub(hi, lo);
  if (Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$eq, diff, Int64.max_int)) {
    return Caml_int64.add(lo, Caml_int64.and_(full_range_int64(state), Int64.max_int));
  } else if (Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$great$eq, diff, Caml_int64.zero)) {
    return Caml_int64.add(lo, int64(state, Int64.succ(diff)));
  } else {
    while(true) {
      var $$int = full_range_int64(state);
      if (Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$great$eq, $$int, lo) && Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$less$eq, $$int, hi)) {
        return $$int;
      }
      continue ;
    };
  }
}

function rawfloat(state) {
  while(true) {
    var r1 = Random.State.bits(CamlinternalLazy.force(state));
    var r2 = Random.State.bits(CamlinternalLazy.force(state));
    var result = Import$negBase.$star$dot(Import$negBase.$plus$dot(Import$negBase.$star$dot(r1, 9.31322574615478516e-10), r2), 9.31322574615478516e-10);
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, result, 1.0)) {
      return result;
    }
    continue ;
  };
}

function $$float(state, hi) {
  return Import$negBase.$star$dot(rawfloat(state), hi);
}

function float_range(state, lo, hi) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, lo, hi)) {
    raise_crossed_bounds("float", lo, hi, Import$negBase.Caml.string_of_float);
  }
  var hi$1 = Import$negBase.$neg$dot(hi, lo);
  return Import$negBase.$plus$dot(lo, Import$negBase.$star$dot(rawfloat(state), hi$1));
}

function bits$1(param) {
  return Random.State.bits(CamlinternalLazy.force($$default));
}

function $$int$2(x) {
  return Curry._2($$int$1, $$default, x);
}

function int32$1(x) {
  return int32($$default, x);
}

function nativeint$1(x) {
  return nativeint($$default, x);
}

function int64$1(x) {
  return int64($$default, x);
}

function $$float$1(x) {
  return Import$negBase.$star$dot(rawfloat($$default), x);
}

function int_incl$1(x, y) {
  return int_incl($$default, x, y);
}

function int32_incl$1(x, y) {
  return int32_incl($$default, x, y);
}

function nativeint_incl$1(x, y) {
  return nativeint_incl($$default, x, y);
}

function int64_incl$1(x, y) {
  return int64_incl($$default, x, y);
}

function float_range$1(x, y) {
  return float_range($$default, x, y);
}

function bool$1(param) {
  return Random.State.bool(CamlinternalLazy.force($$default));
}

function $$char$1(param) {
  return Char0$negBase.unsafe_of_int($$int($$default, 256));
}

function ascii$1(param) {
  return Char0$negBase.unsafe_of_int($$int($$default, 128));
}

function full_init(seed) {
  return assign($$default, Lazy$negBase.from_val(Random.State.make(seed)));
}

function init(seed) {
  return full_init([seed]);
}

function self_init(allow_in_tests, param) {
  return full_init((forbid_nondeterminism_in_tests(allow_in_tests), Caml_external_polyfill.resolve("caml_sys_random_seed")(undefined)));
}

function set_state(s) {
  return assign($$default, s);
}

var State = {
  $$default: $$default,
  make: make,
  make_self_init: make_self_init,
  copy: copy,
  bits: bits,
  $$int: $$int$1,
  int32: int32,
  nativeint: nativeint,
  int64: int64,
  $$float: $$float,
  int_incl: int_incl,
  int32_incl: int32_incl,
  nativeint_incl: nativeint_incl,
  int64_incl: int64_incl,
  float_range: float_range,
  bool: bool,
  $$char: $$char,
  ascii: ascii
};

exports.init = init;
exports.full_init = full_init;
exports.self_init = self_init;
exports.bits = bits$1;
exports.$$int = $$int$2;
exports.int32 = int32$1;
exports.nativeint = nativeint$1;
exports.int64 = int64$1;
exports.$$float = $$float$1;
exports.int_incl = int_incl$1;
exports.int32_incl = int32_incl$1;
exports.nativeint_incl = nativeint_incl$1;
exports.int64_incl = int64_incl$1;
exports.float_range = float_range$1;
exports.bool = bool$1;
exports.$$char = $$char$1;
exports.ascii = ascii$1;
exports.State = State;
exports.set_state = set_state;
/* default Not a pure module */
