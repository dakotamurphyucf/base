// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Hash$negBase = require("./hash.bs.js");
var Sign$negBase = require("./sign.bs.js");
var Poly0$negBase = require("./poly0.bs.js");
var Import$negBase = require("./import.bs.js");
var Identifiable$negBase = require("./identifiable.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

var _tp_loc = "sign_or_nan.ml.T.t";

function t_of_sexp(sexp) {
  if (sexp.TAG === /* Atom */0) {
    switch (sexp._0) {
      case "Nan" :
      case "nan" :
          return /* Nan */3;
      case "Neg" :
      case "neg" :
          return /* Neg */0;
      case "Pos" :
      case "pos" :
          return /* Pos */2;
      case "Zero" :
      case "zero" :
          return /* Zero */1;
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  } else {
    var match = sexp._0;
    if (!match) {
      return Sexp_conv_error$negSexplib0.empty_list_invalid_sum(_tp_loc, sexp);
    }
    var match$1 = match.hd;
    if (match$1.TAG !== /* Atom */0) {
      return Sexp_conv_error$negSexplib0.nested_list_invalid_sum(_tp_loc, sexp);
    }
    switch (match$1._0) {
      case "Nan" :
      case "Neg" :
      case "Pos" :
      case "Zero" :
      case "nan" :
      case "neg" :
      case "pos" :
      case "zero" :
          return Sexp_conv_error$negSexplib0.stag_no_args(_tp_loc, sexp);
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  }
}

function sexp_of_t(param) {
  switch (param) {
    case /* Neg */0 :
        return {
                TAG: /* Atom */0,
                _0: "Neg"
              };
    case /* Zero */1 :
        return {
                TAG: /* Atom */0,
                _0: "Zero"
              };
    case /* Pos */2 :
        return {
                TAG: /* Atom */0,
                _0: "Pos"
              };
    case /* Nan */3 :
        return {
                TAG: /* Atom */0,
                _0: "Nan"
              };
    
  }
}

var compare = Caml.caml_int_compare;

function hash_fold_t(hsv, arg) {
  switch (arg) {
    case /* Neg */0 :
        return Hash$negBase.fold_int(hsv, 0);
    case /* Zero */1 :
        return Hash$negBase.fold_int(hsv, 1);
    case /* Pos */2 :
        return Hash$negBase.fold_int(hsv, 2);
    case /* Nan */3 :
        return Hash$negBase.fold_int(hsv, 3);
    
  }
}

function hash(x) {
  var hsv = Hash$negBase.create(undefined, undefined);
  return Hash$negBase.get_hash_value(hash_fold_t(hsv, x));
}

function of_string(s) {
  return t_of_sexp(Import$negBase.sexp_of_string(s));
}

function to_string(t) {
  return Import$negBase.string_of_sexp(sexp_of_t(t));
}

function $less(x, y) {
  return x < y;
}

function $less$eq(x, y) {
  return x <= y;
}

function $less$great(x, y) {
  return x !== y;
}

function $eq(x, y) {
  return x === y;
}

function $great(x, y) {
  return x > y;
}

function $great$eq(x, y) {
  return x >= y;
}

var ascending = Poly0$negBase.ascending;

var descending = Poly0$negBase.descending;

var compare$1 = Caml.caml_int_compare;

function equal(x, y) {
  return x === y;
}

function max(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var include = Identifiable$negBase.Make({
      compare: compare,
      hash_fold_t: hash_fold_t,
      hash: hash,
      t_of_sexp: t_of_sexp,
      sexp_of_t: sexp_of_t,
      of_string: of_string,
      to_string: to_string,
      module_name: "Base.Sign_or_nan"
    });

function of_sign(param) {
  return param;
}

function to_sign_exn(param) {
  switch (param) {
    case /* Neg */0 :
        return /* Neg */0;
    case /* Zero */1 :
        return /* Zero */1;
    case /* Pos */2 :
        return /* Pos */2;
    case /* Nan */3 :
        return Import$negBase.invalid_arg("Base.Sign_or_nan.to_sign_exn: Nan");
    
  }
}

var of_int = Sign$negBase.of_int;

function to_int_exn(t) {
  return Sign$negBase.to_int(to_sign_exn(t));
}

function flip(param) {
  switch (param) {
    case /* Neg */0 :
        return /* Pos */2;
    case /* Zero */1 :
        return /* Zero */1;
    case /* Pos */2 :
        return /* Neg */0;
    case /* Nan */3 :
        return /* Nan */3;
    
  }
}

function $star(t, t$p) {
  if (t >= 3 || t$p >= 3) {
    return /* Nan */3;
  } else {
    return Sign$negBase.$star(to_sign_exn(t), to_sign_exn(t$p));
  }
}

var all = {
  hd: /* Neg */0,
  tl: {
    hd: /* Zero */1,
    tl: {
      hd: /* Pos */2,
      tl: {
        hd: /* Nan */3,
        tl: /* [] */0
      }
    }
  }
};

var t_sexp_grammar = {
  TAG: /* Enum */1,
  _0: {
    name_kind: /* Capitalized */1,
    names: {
      hd: "Neg",
      tl: {
        hd: "Zero",
        tl: {
          hd: "Pos",
          tl: {
            hd: "Nan",
            tl: /* [] */0
          }
        }
      }
    }
  }
};

var hash_fold_t$1 = include.hash_fold_t;

var hash$1 = include.hash;

var t_of_sexp$1 = include.t_of_sexp;

var sexp_of_t$1 = include.sexp_of_t;

var of_string$1 = include.of_string;

var to_string$1 = include.to_string;

var between = include.between;

var clamp_exn = include.clamp_exn;

var clamp = include.clamp;

var comparator = include.comparator;

var pp = include.pp;

var hashable = include.hashable;

exports.all = all;
exports.t_sexp_grammar = t_sexp_grammar;
exports.hash_fold_t = hash_fold_t$1;
exports.hash = hash$1;
exports.t_of_sexp = t_of_sexp$1;
exports.sexp_of_t = sexp_of_t$1;
exports.of_string = of_string$1;
exports.to_string = to_string$1;
exports.$great$eq = $great$eq;
exports.$less$eq = $less$eq;
exports.$eq = $eq;
exports.$great = $great;
exports.$less = $less;
exports.$less$great = $less$great;
exports.equal = equal;
exports.compare = compare$1;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.pp = pp;
exports.hashable = hashable;
exports.of_int = of_int;
exports.to_int_exn = to_int_exn;
exports.of_sign = of_sign;
exports.to_sign_exn = to_sign_exn;
exports.flip = flip;
exports.$star = $star;
/* include Not a pure module */
