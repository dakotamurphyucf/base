// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var List$negBase = require("./list.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Linked_queue0$negBase = require("./linked_queue0.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");
var Indexed_container$negBase = require("./indexed_container.bs.js");

function enqueue(t, x) {
  return Linked_queue0$negBase.push(x, t);
}

function dequeue(t) {
  if (Linked_queue0$negBase.is_empty(t)) {
    return ;
  } else {
    return Caml_option.some(Linked_queue0$negBase.pop(t));
  }
}

function peek(t) {
  if (Linked_queue0$negBase.is_empty(t)) {
    return ;
  } else {
    return Caml_option.some(Linked_queue0$negBase.peek(t));
  }
}

var iter = {
  NAME: "Custom",
  VAL: Linked_queue0$negBase.iter
};

var length = {
  NAME: "Custom",
  VAL: Linked_queue0$negBase.length
};

var C = Indexed_container$negBase.Make({
      fold: Linked_queue0$negBase.fold,
      iter: iter,
      length: length,
      iteri: "Define_using_fold",
      foldi: "Define_using_fold"
    });

var to_list = C.to_list;

var iteri = C.iteri;

var transfer = Linked_queue0$negBase.transfer;

function concat_map(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Linked_queue0$negBase.iter(t, (function (a) {
          return List$negBase.iter(Curry._1(f, a), (function (b) {
                        return Linked_queue0$negBase.push(b, res);
                      }));
        }));
  return res;
}

function concat_mapi(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Curry._2(iteri, t, (function (i, a) {
          return List$negBase.iter(Curry._2(f, i, a), (function (b) {
                        return Linked_queue0$negBase.push(b, res);
                      }));
        }));
  return res;
}

function filter_map(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Linked_queue0$negBase.iter(t, (function (a) {
          var b = Curry._1(f, a);
          if (b !== undefined) {
            return Linked_queue0$negBase.push(Caml_option.valFromOption(b), res);
          }
          
        }));
  return res;
}

function filter_mapi(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Curry._2(iteri, t, (function (i, a) {
          var b = Curry._2(f, i, a);
          if (b !== undefined) {
            return Linked_queue0$negBase.push(Caml_option.valFromOption(b), res);
          }
          
        }));
  return res;
}

function filter(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Linked_queue0$negBase.iter(t, (function (a) {
          if (Curry._1(f, a)) {
            return Linked_queue0$negBase.push(a, res);
          }
          
        }));
  return res;
}

function filteri(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Curry._2(iteri, t, (function (i, a) {
          if (Curry._2(f, i, a)) {
            return Linked_queue0$negBase.push(a, res);
          }
          
        }));
  return res;
}

function map(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Linked_queue0$negBase.iter(t, (function (a) {
          return Linked_queue0$negBase.push(Curry._1(f, a), res);
        }));
  return res;
}

function mapi(t, f) {
  var res = Linked_queue0$negBase.create(undefined);
  Curry._2(iteri, t, (function (i, a) {
          return Linked_queue0$negBase.push(Curry._2(f, i, a), res);
        }));
  return res;
}

function filter_inplace(q, f) {
  var q$p = filter(q, f);
  Linked_queue0$negBase.clear(q);
  return Linked_queue0$negBase.transfer(q$p, q);
}

function filteri_inplace(q, f) {
  var q$p = filteri(q, f);
  Linked_queue0$negBase.clear(q);
  return Linked_queue0$negBase.transfer(q$p, q);
}

function enqueue_all(t, list) {
  return List$negBase.iter(list, (function (x) {
                return Linked_queue0$negBase.push(x, t);
              }));
}

function of_list(list) {
  var t = Linked_queue0$negBase.create(undefined);
  List$negBase.iter(list, (function (x) {
          return Linked_queue0$negBase.push(x, t);
        }));
  return t;
}

function of_array(array) {
  var t = Linked_queue0$negBase.create(undefined);
  Array0$negBase.iter(array, (function (x) {
          return Linked_queue0$negBase.push(x, t);
        }));
  return t;
}

function init(len, f) {
  var t = Linked_queue0$negBase.create(undefined);
  for(var i = 0 ,i_finish = Import$negBase.$neg(len, 1); i <= i_finish; ++i){
    Linked_queue0$negBase.push(Curry._1(f, i), t);
  }
  return t;
}

function to_array(t) {
  var len = Linked_queue0$negBase.length(t);
  if (len === 0) {
    return [];
  }
  var arr = Array0$negBase.create(len, Linked_queue0$negBase.peek(t));
  var i = {
    contents: 0
  };
  Linked_queue0$negBase.iter(t, (function (v) {
          Caml_array.set(arr, i[0], v);
          return Import$negBase.incr(i);
        }));
  return arr;
}

function t_of_sexp(a_of_sexp, sexp) {
  return of_list(Import$negBase.list_of_sexp(a_of_sexp, sexp));
}

function sexp_of_t(sexp_of_a, t) {
  return Import$negBase.sexp_of_list(sexp_of_a, Curry._1(to_list, t));
}

function t_sexp_grammar(grammar) {
  return Sexp_grammar$negSexplib0.coerce(List$negBase.t_sexp_grammar(grammar));
}

function singleton(a) {
  var t = Linked_queue0$negBase.create(undefined);
  Linked_queue0$negBase.push(a, t);
  return t;
}

var mem = C.mem;

var length$1 = Linked_queue0$negBase.length;

var is_empty = Linked_queue0$negBase.is_empty;

var iter$1 = Linked_queue0$negBase.iter;

var fold = Linked_queue0$negBase.fold;

var fold_result = C.fold_result;

var fold_until = C.fold_until;

var exists = C.exists;

var for_all = C.for_all;

var count = C.count;

var sum = C.sum;

var find = C.find;

var find_map = C.find_map;

var min_elt = C.min_elt;

var max_elt = C.max_elt;

var foldi = C.foldi;

var existsi = C.existsi;

var for_alli = C.for_alli;

var counti = C.counti;

var findi = C.findi;

var find_mapi = C.find_mapi;

var dequeue_exn = Linked_queue0$negBase.pop;

var peek_exn = Linked_queue0$negBase.peek;

var clear = Linked_queue0$negBase.clear;

var copy = Linked_queue0$negBase.copy;

var create = Linked_queue0$negBase.create;

exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.mem = mem;
exports.length = length$1;
exports.is_empty = is_empty;
exports.iter = iter$1;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.count = count;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.foldi = foldi;
exports.iteri = iteri;
exports.existsi = existsi;
exports.for_alli = for_alli;
exports.counti = counti;
exports.findi = findi;
exports.find_mapi = find_mapi;
exports.singleton = singleton;
exports.of_list = of_list;
exports.of_array = of_array;
exports.init = init;
exports.enqueue = enqueue;
exports.enqueue_all = enqueue_all;
exports.dequeue = dequeue;
exports.dequeue_exn = dequeue_exn;
exports.peek = peek;
exports.peek_exn = peek_exn;
exports.clear = clear;
exports.copy = copy;
exports.map = map;
exports.mapi = mapi;
exports.concat_map = concat_map;
exports.concat_mapi = concat_mapi;
exports.filter_map = filter_map;
exports.filter_mapi = filter_mapi;
exports.filter = filter;
exports.filteri = filteri;
exports.filter_inplace = filter_inplace;
exports.filteri_inplace = filteri_inplace;
exports.create = create;
exports.transfer = transfer;
/* C Not a pure module */
