// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var List0$negBase = require("./list0.bs.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var With_return$negBase = require("./with_return.bs.js");

function iter(fold, t, f) {
  return Curry._3(fold, t, undefined, (function (param, a) {
                return Curry._1(f, a);
              }));
}

function count(fold, t, f) {
  return Curry._3(fold, t, 0, (function (n, a) {
                if (Curry._1(f, a)) {
                  return Import$negBase.$plus(n, 1);
                } else {
                  return n;
                }
              }));
}

function sum(fold, M, t, f) {
  return Curry._3(fold, t, M.zero, (function (n, a) {
                return Curry._2(M.$plus, n, Curry._1(f, a));
              }));
}

function fold_result(fold, init, f, t) {
  return With_return$negBase.with_return(function (param) {
              return {
                      TAG: /* Ok */0,
                      _0: Curry._3(fold, t, init, (function (acc, item) {
                              var x = Curry._2(f, acc, item);
                              if (x.TAG === /* Ok */0) {
                                return x._0;
                              } else {
                                return Curry._1(param, x);
                              }
                            }))
                    };
            });
}

function fold_until(fold, init, f, finish, t) {
  return With_return$negBase.with_return(function (param) {
              return Curry._1(finish, Curry._3(fold, t, init, (function (acc, item) {
                                var x = Curry._2(f, acc, item);
                                if (x.TAG === /* Continue */0) {
                                  return x._0;
                                } else {
                                  return Curry._1(param, x._0);
                                }
                              })));
            });
}

function min_elt(fold, t, compare) {
  return Curry._3(fold, t, undefined, (function (acc, elt) {
                if (acc !== undefined && !Import$negBase.$great(Curry._2(compare, Caml_option.valFromOption(acc), elt), 0)) {
                  return acc;
                } else {
                  return Caml_option.some(elt);
                }
              }));
}

function max_elt(fold, t, compare) {
  return Curry._3(fold, t, undefined, (function (acc, elt) {
                if (acc !== undefined && !Import$negBase.$less(Curry._2(compare, Caml_option.valFromOption(acc), elt), 0)) {
                  return acc;
                } else {
                  return Caml_option.some(elt);
                }
              }));
}

function length(fold, c) {
  return Curry._3(fold, c, 0, (function (acc, param) {
                return Import$negBase.$plus(acc, 1);
              }));
}

function is_empty(iter, c) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iter, c, (function (param) {
                      return Curry._1(r, false);
                    }));
              return true;
            });
}

function exists(iter, c, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iter, c, (function (x) {
                      if (Curry._1(f, x)) {
                        return Curry._1(r, true);
                      }
                      
                    }));
              return false;
            });
}

function for_all(iter, c, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iter, c, (function (x) {
                      if (!Curry._1(f, x)) {
                        return Curry._1(r, false);
                      }
                      
                    }));
              return true;
            });
}

function find_map(iter, t, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iter, t, (function (x) {
                      var res = Curry._1(f, x);
                      if (res !== undefined) {
                        return Curry._1(r, res);
                      }
                      
                    }));
              
            });
}

function find(iter, c, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iter, c, (function (x) {
                      if (Curry._1(f, x)) {
                        return Curry._1(r, Caml_option.some(x));
                      }
                      
                    }));
              
            });
}

function to_list(fold, c) {
  return List0$negBase.rev(Curry._3(fold, c, /* [] */0, (function (acc, x) {
                    return {
                            hd: x,
                            tl: acc
                          };
                  })));
}

function to_array(length, iter, c) {
  var array = {
    contents: []
  };
  var i = {
    contents: 0
  };
  Curry._2(iter, c, (function (x) {
          if (i[0] === 0) {
            array[0] = Array0$negBase.create(Curry._1(length, c), x);
          }
          Caml_array.set(array[0], i[0], x);
          i[0] = Import$negBase.$plus(i[0], 1);
          
        }));
  return array[0];
}

function Make_gen(T) {
  var fold = T.fold;
  var match = T.iter;
  var iter$1 = typeof match === "string" ? (function (t, f) {
        return iter(fold, t, f);
      }) : match.VAL;
  var match$1 = T.length;
  var length$1 = typeof match$1 === "string" ? (function (t) {
        return length(fold, t);
      }) : match$1.VAL;
  var is_empty$1 = function (t) {
    return is_empty(iter$1, t);
  };
  var sum$1 = function (m, t) {
    return function (param) {
      return sum(fold, m, t, param);
    };
  };
  var count$1 = function (t, f) {
    return count(fold, t, f);
  };
  var exists$1 = function (t, f) {
    return exists(iter$1, t, f);
  };
  var for_all$1 = function (t, f) {
    return for_all(iter$1, t, f);
  };
  var find_map$1 = function (t, f) {
    return find_map(iter$1, t, f);
  };
  var find$1 = function (t, f) {
    return find(iter$1, t, f);
  };
  var to_list$1 = function (t) {
    return to_list(fold, t);
  };
  var to_array$1 = function (t) {
    return to_array(length$1, iter$1, t);
  };
  var min_elt$1 = function (t, compare) {
    return min_elt(fold, t, compare);
  };
  var max_elt$1 = function (t, compare) {
    return max_elt(fold, t, compare);
  };
  var fold_result$1 = function (t, init, f) {
    return fold_result(fold, init, f, t);
  };
  var fold_until$1 = function (t, init, f, finish) {
    return fold_until(fold, init, f, finish, t);
  };
  return {
          length: length$1,
          is_empty: is_empty$1,
          iter: iter$1,
          fold: fold,
          fold_result: fold_result$1,
          fold_until: fold_until$1,
          exists: exists$1,
          for_all: for_all$1,
          count: count$1,
          sum: sum$1,
          find: find$1,
          find_map: find_map$1,
          to_list: to_list$1,
          to_array: to_array$1,
          min_elt: min_elt$1,
          max_elt: max_elt$1
        };
}

function Make(funarg) {
  var fold = funarg.fold;
  var iter$1 = funarg.iter;
  var length$1 = funarg.length;
  var iter$2 = typeof iter$1 === "string" ? (function (t, f) {
        return iter(fold, t, f);
      }) : iter$1.VAL;
  var length$2 = typeof length$1 === "string" ? (function (t) {
        return length(fold, t);
      }) : length$1.VAL;
  var is_empty$1 = function (t) {
    return is_empty(iter$2, t);
  };
  var sum$1 = function (m, t) {
    return function (param) {
      return sum(fold, m, t, param);
    };
  };
  var count$1 = function (t, f) {
    return count(fold, t, f);
  };
  var exists$1 = function (t, f) {
    return exists(iter$2, t, f);
  };
  var for_all$1 = function (t, f) {
    return for_all(iter$2, t, f);
  };
  var find_map$1 = function (t, f) {
    return find_map(iter$2, t, f);
  };
  var find$1 = function (t, f) {
    return find(iter$2, t, f);
  };
  var to_list$1 = function (t) {
    return to_list(fold, t);
  };
  var to_array$1 = function (t) {
    return to_array(length$2, iter$2, t);
  };
  var min_elt$1 = function (t, compare) {
    return min_elt(fold, t, compare);
  };
  var max_elt$1 = function (t, compare) {
    return max_elt(fold, t, compare);
  };
  var fold_result$1 = function (t, init, f) {
    return fold_result(fold, init, f, t);
  };
  var fold_until$1 = function (t, init, f, finish) {
    return fold_until(fold, init, f, finish, t);
  };
  var mem = function (t, a, equal) {
    return exists(iter$2, t, Curry._1(equal, a));
  };
  return {
          mem: mem,
          length: length$2,
          is_empty: is_empty$1,
          iter: iter$2,
          fold: fold,
          fold_result: fold_result$1,
          fold_until: fold_until$1,
          exists: exists$1,
          for_all: for_all$1,
          count: count$1,
          sum: sum$1,
          find: find$1,
          find_map: find_map$1,
          to_list: to_list$1,
          to_array: to_array$1,
          min_elt: min_elt$1,
          max_elt: max_elt$1
        };
}

function Make0(funarg) {
  var fold = funarg.fold;
  var iter$1 = funarg.iter;
  var length$1 = funarg.length;
  var iter$2 = typeof iter$1 === "string" ? (function (t, f) {
        return iter(fold, t, f);
      }) : iter$1.VAL;
  var length$2 = typeof length$1 === "string" ? (function (t) {
        return length(fold, t);
      }) : length$1.VAL;
  var is_empty$1 = function (t) {
    return is_empty(iter$2, t);
  };
  var sum$1 = function (m, t) {
    return function (param) {
      return sum(fold, m, t, param);
    };
  };
  var count$1 = function (t, f) {
    return count(fold, t, f);
  };
  var exists$1 = function (t, f) {
    return exists(iter$2, t, f);
  };
  var for_all$1 = function (t, f) {
    return for_all(iter$2, t, f);
  };
  var find_map$1 = function (t, f) {
    return find_map(iter$2, t, f);
  };
  var find$1 = function (t, f) {
    return find(iter$2, t, f);
  };
  var to_list$1 = function (t) {
    return to_list(fold, t);
  };
  var to_array$1 = function (t) {
    return to_array(length$2, iter$2, t);
  };
  var min_elt$1 = function (t, compare) {
    return min_elt(fold, t, compare);
  };
  var max_elt$1 = function (t, compare) {
    return max_elt(fold, t, compare);
  };
  var fold_result$1 = function (t, init, f) {
    return fold_result(fold, init, f, t);
  };
  var fold_until$1 = function (t, init, f, finish) {
    return fold_until(fold, init, f, finish, t);
  };
  var mem = function (t, elt) {
    return exists(iter$2, t, Curry._1(funarg.Elt.equal, elt));
  };
  return {
          mem: mem,
          length: length$2,
          is_empty: is_empty$1,
          iter: iter$2,
          fold: fold,
          fold_result: fold_result$1,
          fold_until: fold_until$1,
          exists: exists$1,
          for_all: for_all$1,
          count: count$1,
          sum: sum$1,
          find: find$1,
          find_map: find_map$1,
          to_list: to_list$1,
          to_array: to_array$1,
          min_elt: min_elt$1,
          max_elt: max_elt$1
        };
}

exports.iter = iter;
exports.count = count;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.length = length;
exports.to_list = to_list;
exports.sum = sum;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.is_empty = is_empty;
exports.exists = exists;
exports.for_all = for_all;
exports.find = find;
exports.find_map = find_map;
exports.to_array = to_array;
exports.Make = Make;
exports.Make0 = Make0;
exports.Make_gen = Make_gen;
/* Array0-Base Not a pure module */
