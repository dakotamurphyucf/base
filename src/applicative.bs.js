// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var List$negBase = require("./list.bs.js");
var Import$negBase = require("./import.bs.js");

function S_to_S2(X) {
  return X;
}

function S2_to_S(X) {
  return X;
}

function S2_to_S3(X) {
  return X;
}

function S3_to_S2(X) {
  return X;
}

function Make3(X) {
  var $$return = X.$$return;
  var apply = X.apply;
  var derived_map = function (t, f) {
    return Curry._2(apply, Curry._1($$return, f), t);
  };
  var match = X.map;
  var map = typeof match === "string" ? derived_map : match.VAL;
  var $great$great$pipe = Curry.__2(map);
  var map2 = function (ta, tb, f) {
    return Curry._2(apply, Curry._2(map, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return Curry._2(apply, Curry._2(apply, Curry._2(map, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return Curry._2(apply, Curry._2(apply, Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return Curry._2(apply, Curry._2(apply, Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Make2(X) {
  var $$return = X.$$return;
  var apply = X.apply;
  var map = X.map;
  var derived_map = function (t, f) {
    return Curry._2(apply, Curry._1($$return, f), t);
  };
  var map$1 = typeof map === "string" ? derived_map : map.VAL;
  var $great$great$pipe = Curry.__2(map$1);
  var map2 = function (ta, tb, f) {
    return Curry._2(apply, Curry._2(map$1, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return Curry._2(apply, Curry._2(apply, Curry._2(map$1, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return Curry._2(apply, Curry._2(apply, Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return Curry._2(apply, Curry._2(apply, Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map$1,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Make(X) {
  var $$return = X.$$return;
  var apply = X.apply;
  var map = X.map;
  var derived_map = function (t, f) {
    return Curry._2(apply, Curry._1($$return, f), t);
  };
  var map$1 = typeof map === "string" ? derived_map : map.VAL;
  var $great$great$pipe = Curry.__2(map$1);
  var map2 = function (ta, tb, f) {
    return Curry._2(apply, Curry._2(map$1, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return Curry._2(apply, Curry._2(apply, Curry._2(map$1, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return Curry._2(apply, Curry._2(apply, Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return Curry._2(apply, Curry._2(apply, Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map$1,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Make3_using_map2(X) {
  var $$return = X.$$return;
  var map2 = X.map2;
  var map = X.map;
  var apply = function (tf, tx) {
    return Curry._3(map2, tf, tx, (function (f, x) {
                  return Curry._1(f, x);
                }));
  };
  var map$1 = typeof map === "string" ? "Define_using_apply" : ({
        NAME: "Custom",
        VAL: map.VAL
      });
  var derived_map = function (t, f) {
    return apply(Curry._1($$return, f), t);
  };
  var map$2 = typeof map$1 === "string" ? derived_map : map$1.VAL;
  var $great$great$pipe = Curry.__2(map$2);
  var map2$1 = function (ta, tb, f) {
    return apply(Curry._2(map$2, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return apply(apply(Curry._2(map$2, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2$1(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2$1(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return apply(apply(Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return apply(apply(Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map$2,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2$1,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Make2_using_map2(X) {
  var $$return = X.$$return;
  var map2 = X.map2;
  var map = X.map;
  var apply = function (tf, tx) {
    return Curry._3(map2, tf, tx, (function (f, x) {
                  return Curry._1(f, x);
                }));
  };
  var map$1 = typeof map === "string" ? "Define_using_apply" : ({
        NAME: "Custom",
        VAL: map.VAL
      });
  var derived_map = function (t, f) {
    return apply(Curry._1($$return, f), t);
  };
  var map$2 = typeof map$1 === "string" ? derived_map : map$1.VAL;
  var $great$great$pipe = Curry.__2(map$2);
  var map2$1 = function (ta, tb, f) {
    return apply(Curry._2(map$2, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return apply(apply(Curry._2(map$2, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2$1(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2$1(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return apply(apply(Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return apply(apply(Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map$2,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2$1,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Make_using_map2(X) {
  var $$return = X.$$return;
  var map2 = X.map2;
  var map = X.map;
  var apply = function (tf, tx) {
    return Curry._3(map2, tf, tx, (function (f, x) {
                  return Curry._1(f, x);
                }));
  };
  var map$1 = typeof map === "string" ? "Define_using_apply" : ({
        NAME: "Custom",
        VAL: map.VAL
      });
  var derived_map = function (t, f) {
    return apply(Curry._1($$return, f), t);
  };
  var map$2 = typeof map$1 === "string" ? derived_map : map$1.VAL;
  var $great$great$pipe = Curry.__2(map$2);
  var map2$1 = function (ta, tb, f) {
    return apply(Curry._2(map$2, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return apply(apply(Curry._2(map$2, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2$1(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2$1(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return apply(apply(Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return apply(apply(Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map$2,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2$1,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Of_monad2(M) {
  var $$return = M.$$return;
  var apply = function (mf, mx) {
    return Curry._2(M.bind, mf, (function (f) {
                  return Curry._2(M.map, mx, f);
                }));
  };
  var map_1 = M.map;
  var map = {
    NAME: "Custom",
    VAL: map_1
  };
  var derived_map = function (t, f) {
    return apply(Curry._1($$return, f), t);
  };
  var map$1 = typeof map === "string" ? derived_map : M.map;
  var $great$great$pipe = Curry.__2(map$1);
  var map2 = function (ta, tb, f) {
    return apply(Curry._2(map$1, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return apply(apply(Curry._2(map$1, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return apply(apply(Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return apply(apply(Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map$1,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Of_monad(M) {
  var bind = M.bind;
  var $$return = M.$$return;
  var map = M.map;
  var apply = function (mf, mx) {
    return Curry._2(bind, mf, (function (f) {
                  return Curry._2(map, mx, f);
                }));
  };
  var map$1 = {
    NAME: "Custom",
    VAL: map
  };
  var derived_map = function (t, f) {
    return apply(Curry._1($$return, f), t);
  };
  var map$2 = typeof map$1 === "string" ? derived_map : map;
  var $great$great$pipe = Curry.__2(map$2);
  var map2 = function (ta, tb, f) {
    return apply(Curry._2(map$2, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return apply(apply(Curry._2(map$2, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2(param, param$1, arg);
                  };
                }), Curry._1($$return, /* [] */0));
  };
  var both = function (ta, tb) {
    return map2(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return apply(apply(Curry._1($$return, (function (param, y) {
                          return y;
                        })), u), v);
  };
  var $less$star = function (u, v) {
    return apply(apply(Curry._1($$return, (function (x, param) {
                          return x;
                        })), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1($$return, undefined), $star$great);
  };
  return {
          $$return: $$return,
          map: map$2,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: {
            $less$star$great: apply,
            $less$star: $less$star,
            $star$great: $star$great,
            $great$great$pipe: $great$great$pipe
          }
        };
}

function Compose(F, G) {
  var $$return = function (a) {
    return Curry._1(G.$$return, Curry._1(F.$$return, a));
  };
  var apply = function (tf, tx) {
    return Curry._2(G.apply, Curry._2(G.map, tf, F.apply), tx);
  };
  var custom_map = function (t, f) {
    var func = F.map;
    return Curry._2(G.map, t, (function (param) {
                  return Curry._2(func, param, f);
                }));
  };
  var map = {
    NAME: "Custom",
    VAL: custom_map
  };
  var derived_map = function (t, f) {
    return apply(Curry._1(G.$$return, Curry._1(F.$$return, f)), t);
  };
  var map$1 = typeof map === "string" ? derived_map : custom_map;
  var $great$great$pipe = Curry.__2(map$1);
  var map2 = function (ta, tb, f) {
    return apply(Curry._2(map$1, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return apply(apply(Curry._2(map$1, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2(param, param$1, arg);
                  };
                }), Curry._1(G.$$return, Curry._1(F.$$return, /* [] */0)));
  };
  var both = function (ta, tb) {
    return map2(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return apply(apply(Curry._1(G.$$return, Curry._1(F.$$return, (function (param, y) {
                              return y;
                            }))), u), v);
  };
  var $less$star = function (u, v) {
    return apply(apply(Curry._1(G.$$return, Curry._1(F.$$return, (function (x, param) {
                              return x;
                            }))), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, Curry._1(G.$$return, Curry._1(F.$$return, undefined)), $star$great);
  };
  var Applicative_infix = {
    $less$star$great: apply,
    $less$star: $less$star,
    $star$great: $star$great,
    $great$great$pipe: $great$great$pipe
  };
  return {
          $$return: $$return,
          map: map$1,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: Applicative_infix
        };
}

function Pair(F, G) {
  var $$return = function (a) {
    return [
            Curry._1(F.$$return, a),
            Curry._1(G.$$return, a)
          ];
  };
  var apply = function (tf, tx) {
    return [
            Curry._2(F.apply, Import$negBase.fst(tf), Import$negBase.fst(tx)),
            Curry._2(G.apply, Import$negBase.snd(tf), Import$negBase.snd(tx))
          ];
  };
  var custom_map = function (t, f) {
    return [
            Curry._2(F.map, Import$negBase.fst(t), f),
            Curry._2(G.map, Import$negBase.snd(t), f)
          ];
  };
  var map = {
    NAME: "Custom",
    VAL: custom_map
  };
  var derived_map = function (t, f) {
    return apply($$return(f), t);
  };
  var map$1 = typeof map === "string" ? derived_map : custom_map;
  var $great$great$pipe = Curry.__2(map$1);
  var map2 = function (ta, tb, f) {
    return apply(Curry._2(map$1, ta, f), tb);
  };
  var map3 = function (ta, tb, tc, f) {
    return apply(apply(Curry._2(map$1, ta, f), tb), tc);
  };
  var all = function (ts) {
    var arg = function (x, xs) {
      return {
              hd: x,
              tl: xs
            };
    };
    return List$negBase.fold_right(ts, (function (param) {
                  return function (param$1) {
                    return map2(param, param$1, arg);
                  };
                }), $$return(/* [] */0));
  };
  var both = function (ta, tb) {
    return map2(ta, tb, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  };
  var $star$great = function (u, v) {
    return apply(apply($$return(function (param, y) {
                        return y;
                      }), u), v);
  };
  var $less$star = function (u, v) {
    return apply(apply($$return(function (x, param) {
                        return x;
                      }), u), v);
  };
  var all_unit = function (ts) {
    return List$negBase.fold(ts, $$return(undefined), $star$great);
  };
  var Applicative_infix = {
    $less$star$great: apply,
    $less$star: $less$star,
    $star$great: $star$great,
    $great$great$pipe: $great$great$pipe
  };
  return {
          $$return: $$return,
          map: map$1,
          both: both,
          $less$star$great: apply,
          $less$star: $less$star,
          $star$great: $star$great,
          $great$great$pipe: $great$great$pipe,
          apply: apply,
          map2: map2,
          map3: map3,
          all: all,
          all_unit: all_unit,
          Applicative_infix: Applicative_infix
        };
}

function Make_let_syntax(funarg, funarg$1, funarg$2) {
  var partial_arg = funarg;
  var partial_arg$1 = function (param, param$1) {
    var partial_arg$2 = partial_arg;
    var Let_syntax_return = partial_arg$2.$$return;
    var Let_syntax_map = partial_arg$2.map;
    var Let_syntax_both = partial_arg$2.both;
    var Let_syntax_$less$star$great = partial_arg$2.$less$star$great;
    var Let_syntax_$less$star = partial_arg$2.$less$star;
    var Let_syntax_$star$great = partial_arg$2.$star$great;
    var Let_syntax_$great$great$pipe = partial_arg$2.$great$great$pipe;
    var Let_syntax = {
      $$return: Let_syntax_return,
      map: Let_syntax_map,
      both: Let_syntax_both,
      $less$star$great: Let_syntax_$less$star$great,
      $less$star: Let_syntax_$less$star,
      $star$great: Let_syntax_$star$great,
      $great$great$pipe: Let_syntax_$great$great$pipe,
      Open_on_rhs: param$1
    };
    var Let_syntax_return$1 = partial_arg$2.$$return;
    var Let_syntax_map$1 = partial_arg$2.map;
    var Let_syntax_both$1 = partial_arg$2.both;
    var Let_syntax_$less$star$great$1 = partial_arg$2.$less$star$great;
    var Let_syntax_$less$star$1 = partial_arg$2.$less$star;
    var Let_syntax_$star$great$1 = partial_arg$2.$star$great;
    var Let_syntax_$great$great$pipe$1 = partial_arg$2.$great$great$pipe;
    var Let_syntax$1 = {
      $$return: Let_syntax_return$1,
      map: Let_syntax_map$1,
      both: Let_syntax_both$1,
      $less$star$great: Let_syntax_$less$star$great$1,
      $less$star: Let_syntax_$less$star$1,
      $star$great: Let_syntax_$star$great$1,
      $great$great$pipe: Let_syntax_$great$great$pipe$1,
      Let_syntax: Let_syntax
    };
    return {
            Let_syntax: Let_syntax$1
          };
  };
  var $$let = partial_arg$1(funarg$1, funarg$2);
  var $$let$1 = $$let.Let_syntax;
  var $$let$2 = $$let$1.Let_syntax;
  return {
          Let_syntax: {
            $$return: $$let$1.$$return,
            $less$star$great: $$let$1.$less$star$great,
            $less$star: $$let$1.$less$star,
            $star$great: $$let$1.$star$great,
            $great$great$pipe: $$let$1.$great$great$pipe,
            Let_syntax: {
              $$return: $$let$2.$$return,
              map: $$let$2.map,
              both: $$let$2.both,
              Open_on_rhs: $$let$2.Open_on_rhs
            }
          }
        };
}

function Make_let_syntax2(funarg, funarg$1, funarg$2) {
  var partial_arg = funarg;
  var partial_arg$1 = function (param, param$1) {
    var Let_syntax_return = partial_arg.$$return;
    var Let_syntax_map = partial_arg.map;
    var Let_syntax_both = partial_arg.both;
    var Let_syntax_$less$star$great = partial_arg.$less$star$great;
    var Let_syntax_$less$star = partial_arg.$less$star;
    var Let_syntax_$star$great = partial_arg.$star$great;
    var Let_syntax_$great$great$pipe = partial_arg.$great$great$pipe;
    var Let_syntax = {
      $$return: Let_syntax_return,
      map: Let_syntax_map,
      both: Let_syntax_both,
      $less$star$great: Let_syntax_$less$star$great,
      $less$star: Let_syntax_$less$star,
      $star$great: Let_syntax_$star$great,
      $great$great$pipe: Let_syntax_$great$great$pipe,
      Open_on_rhs: param$1
    };
    var Let_syntax_return$1 = partial_arg.$$return;
    var Let_syntax_map$1 = partial_arg.map;
    var Let_syntax_both$1 = partial_arg.both;
    var Let_syntax_$less$star$great$1 = partial_arg.$less$star$great;
    var Let_syntax_$less$star$1 = partial_arg.$less$star;
    var Let_syntax_$star$great$1 = partial_arg.$star$great;
    var Let_syntax_$great$great$pipe$1 = partial_arg.$great$great$pipe;
    var Let_syntax$1 = {
      $$return: Let_syntax_return$1,
      map: Let_syntax_map$1,
      both: Let_syntax_both$1,
      $less$star$great: Let_syntax_$less$star$great$1,
      $less$star: Let_syntax_$less$star$1,
      $star$great: Let_syntax_$star$great$1,
      $great$great$pipe: Let_syntax_$great$great$pipe$1,
      Let_syntax: Let_syntax
    };
    return {
            Let_syntax: Let_syntax$1
          };
  };
  var $$let = partial_arg$1(funarg$1, funarg$2);
  var $$let$1 = $$let.Let_syntax;
  var $$let$2 = $$let$1.Let_syntax;
  return {
          Let_syntax: {
            $$return: $$let$1.$$return,
            $less$star$great: $$let$1.$less$star$great,
            $less$star: $$let$1.$less$star,
            $star$great: $$let$1.$star$great,
            $great$great$pipe: $$let$1.$great$great$pipe,
            Let_syntax: {
              $$return: $$let$2.$$return,
              map: $$let$2.map,
              both: $$let$2.both,
              Open_on_rhs: $$let$2.Open_on_rhs
            }
          }
        };
}

function Make_let_syntax3(funarg, funarg$1, funarg$2) {
  var Let_syntax_return = funarg.$$return;
  var Let_syntax_map = funarg.map;
  var Let_syntax_both = funarg.both;
  var Let_syntax_$less$star$great = funarg.$less$star$great;
  var Let_syntax_$less$star = funarg.$less$star;
  var Let_syntax_$star$great = funarg.$star$great;
  var Let_syntax_$great$great$pipe = funarg.$great$great$pipe;
  return {
          Let_syntax: {
            $$return: funarg.$$return,
            $less$star$great: funarg.$less$star$great,
            $less$star: funarg.$less$star,
            $star$great: funarg.$star$great,
            $great$great$pipe: funarg.$great$great$pipe,
            Let_syntax: {
              $$return: Let_syntax_return,
              map: Let_syntax_map,
              both: Let_syntax_both,
              Open_on_rhs: funarg$2
            }
          }
        };
}

exports.S2_to_S = S2_to_S;
exports.S_to_S2 = S_to_S2;
exports.S3_to_S2 = S3_to_S2;
exports.S2_to_S3 = S2_to_S3;
exports.Make = Make;
exports.Make2 = Make2;
exports.Make3 = Make3;
exports.Make_let_syntax = Make_let_syntax;
exports.Make_let_syntax2 = Make_let_syntax2;
exports.Make_let_syntax3 = Make_let_syntax3;
exports.Make_using_map2 = Make_using_map2;
exports.Make2_using_map2 = Make2_using_map2;
exports.Make3_using_map2 = Make3_using_map2;
exports.Of_monad = Of_monad;
exports.Of_monad2 = Of_monad2;
exports.Compose = Compose;
exports.Pair = Pair;
/* List-Base Not a pure module */
