// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var List0$negBase = require("./list0.bs.js");

function Make_indexed(M) {
  var bind = M.bind;
  var map = M.map;
  var $$return = M.$$return;
  var map_via_bind = function (ma, f) {
    return Curry._2(bind, ma, (function (a) {
                  return Curry._1($$return, Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map.VAL;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return Curry._2(bind, a, (function (a) {
                  return Curry._2(map$1, b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return Curry._2(bind, t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return Curry._1($$return, List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return Curry._1($$return, undefined);
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Let_syntax: Let_syntax$1,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit
        };
}

function Make3(M) {
  var bind = M.bind;
  var map = M.map;
  var $$return = M.$$return;
  var map_via_bind = function (ma, f) {
    return Curry._2(bind, ma, (function (a) {
                  return Curry._1($$return, Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map.VAL;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return Curry._2(bind, a, (function (a) {
                  return Curry._2(map$1, b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return Curry._2(bind, t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return Curry._1($$return, List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return Curry._1($$return, undefined);
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Let_syntax: Let_syntax$1,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit
        };
}

function Make2(M) {
  var bind = M.bind;
  var map = M.map;
  var $$return = M.$$return;
  var map_via_bind = function (ma, f) {
    return Curry._2(bind, ma, (function (a) {
                  return Curry._1($$return, Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map.VAL;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return Curry._2(bind, a, (function (a) {
                  return Curry._2(map$1, b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return Curry._2(bind, t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return Curry._1($$return, List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return Curry._1($$return, undefined);
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Let_syntax: Let_syntax$1,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit
        };
}

function Make(M) {
  var bind = M.bind;
  var $$return = M.$$return;
  var map = M.map;
  var map_via_bind = function (ma, f) {
    return Curry._2(bind, ma, (function (a) {
                  return Curry._1($$return, Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map.VAL;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return Curry._2(bind, a, (function (a) {
                  return Curry._2(map$1, b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return Curry._2(bind, t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return Curry._1($$return, List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return Curry._1($$return, undefined);
    }
    var ts = param.tl;
    return Curry._2(bind, param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit,
          Let_syntax: Let_syntax$1
        };
}

function bind(a, f) {
  return Curry._1(f, a);
}

function $$return(a) {
  return a;
}

function map_1(a, f) {
  return Curry._1(f, a);
}

var map = {
  NAME: "Custom",
  VAL: map_1
};

function map_via_bind(ma, f) {
  return Curry._1(f, ma);
}

var map$1 = typeof map === "string" ? map_via_bind : map_1;

function $great$great$eq(t, f) {
  return Curry._1(f, t);
}

var $great$great$pipe = Curry.__2(map$1);

var Monad_infix = {
  $great$great$eq: $great$great$eq,
  $great$great$pipe: $great$great$pipe
};

function both(a, b) {
  return Curry._2(map$1, b, (function (b) {
                return [
                        a,
                        b
                      ];
              }));
}

var Open_on_rhs = {};

var Let_syntax = {
  $$return: $$return,
  bind: bind,
  map: map$1,
  both: both,
  Open_on_rhs: Open_on_rhs
};

var Let_syntax$1 = {
  $$return: $$return,
  $great$great$eq: $great$great$eq,
  $great$great$pipe: $great$great$pipe,
  Let_syntax: Let_syntax
};

function join(t) {
  return t;
}

function ignore_m(t) {
  return Curry._2(map$1, t, (function (param) {
                
              }));
}

function all(ts) {
  var _vs = /* [] */0;
  var _param = ts;
  while(true) {
    var param = _param;
    var vs = _vs;
    if (!param) {
      return List0$negBase.rev(vs);
    }
    _param = param.tl;
    _vs = {
      hd: param.hd,
      tl: vs
    };
    continue ;
  };
}

function all_unit(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    _param = param.tl;
    continue ;
  };
}

var Ident = {
  $great$great$eq: $great$great$eq,
  $great$great$pipe: $great$great$pipe,
  Monad_infix: Monad_infix,
  bind: bind,
  $$return: $$return,
  map: map$1,
  join: join,
  ignore_m: ignore_m,
  all: all,
  all_unit: all_unit,
  Let_syntax: Let_syntax$1
};

function Of_monad(funarg, funarg$1) {
  var partial_arg_bind = funarg.bind;
  var partial_arg_map = funarg.map;
  var partial_arg_return = funarg.$$return;
  var M = funarg$1;
  var $$return = function (a) {
    return Curry._1(M.of_monad, Curry._1(partial_arg_return, a));
  };
  var bind = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_bind, Curry._1(M.to_monad, t), (function (a) {
                      return Curry._1(M.to_monad, Curry._1(f, a));
                    })));
  };
  var map_1 = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_map, Curry._1(M.to_monad, t), f));
  };
  var map = {
    NAME: "Custom",
    VAL: map_1
  };
  var map_via_bind = function (ma, f) {
    return bind(ma, (function (a) {
                  return $$return(Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map_1;
  var $great$great$eq = bind;
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return $great$great$eq(a, (function (a) {
                  return $great$great$pipe(b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return $great$great$eq(t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return $$return(List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return $$return(undefined);
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit,
          Let_syntax: Let_syntax$1
        };
}

function Of_monad2(funarg, funarg$1) {
  var partial_arg_bind = funarg.bind;
  var partial_arg_map = funarg.map;
  var partial_arg_return = funarg.$$return;
  var M = funarg$1;
  var $$return = function (a) {
    return Curry._1(M.of_monad, Curry._1(partial_arg_return, a));
  };
  var bind = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_bind, Curry._1(M.to_monad, t), (function (a) {
                      return Curry._1(M.to_monad, Curry._1(f, a));
                    })));
  };
  var map_1 = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_map, Curry._1(M.to_monad, t), f));
  };
  var map = {
    NAME: "Custom",
    VAL: map_1
  };
  var map_via_bind = function (ma, f) {
    return bind(ma, (function (a) {
                  return $$return(Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map_1;
  var $great$great$eq = bind;
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return $great$great$eq(a, (function (a) {
                  return $great$great$pipe(b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return $great$great$eq(t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return $$return(List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return $$return(undefined);
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Let_syntax: Let_syntax$1,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit
        };
}

function Of_monad3(funarg, funarg$1) {
  var partial_arg_bind = funarg.bind;
  var partial_arg_map = funarg.map;
  var partial_arg_return = funarg.$$return;
  var M = funarg$1;
  var $$return = function (a) {
    return Curry._1(M.of_monad, Curry._1(partial_arg_return, a));
  };
  var bind = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_bind, Curry._1(M.to_monad, t), (function (a) {
                      return Curry._1(M.to_monad, Curry._1(f, a));
                    })));
  };
  var map_1 = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_map, Curry._1(M.to_monad, t), f));
  };
  var map = {
    NAME: "Custom",
    VAL: map_1
  };
  var map_via_bind = function (ma, f) {
    return bind(ma, (function (a) {
                  return $$return(Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map_1;
  var $great$great$eq = bind;
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return $great$great$eq(a, (function (a) {
                  return $great$great$pipe(b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return $great$great$eq(t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return $$return(List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return $$return(undefined);
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Let_syntax: Let_syntax$1,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit
        };
}

function Of_monad_indexed(funarg, funarg$1) {
  var partial_arg_bind = funarg.bind;
  var partial_arg_map = funarg.map;
  var partial_arg_return = funarg.$$return;
  var M = funarg$1;
  var $$return = function (a) {
    return Curry._1(M.of_monad, Curry._1(partial_arg_return, a));
  };
  var bind = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_bind, Curry._1(M.to_monad, t), (function (a) {
                      return Curry._1(M.to_monad, Curry._1(f, a));
                    })));
  };
  var map_1 = function (t, f) {
    return Curry._1(M.of_monad, Curry._2(partial_arg_map, Curry._1(M.to_monad, t), f));
  };
  var map = {
    NAME: "Custom",
    VAL: map_1
  };
  var map_via_bind = function (ma, f) {
    return bind(ma, (function (a) {
                  return $$return(Curry._1(f, a));
                }));
  };
  var map$1 = typeof map === "string" ? map_via_bind : map_1;
  var $great$great$eq = bind;
  var $great$great$pipe = Curry.__2(map$1);
  var Monad_infix = {
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe
  };
  var both = function (a, b) {
    return $great$great$eq(a, (function (a) {
                  return $great$great$pipe(b, (function (b) {
                                return [
                                        a,
                                        b
                                      ];
                              }));
                }));
  };
  var Open_on_rhs = {};
  var Let_syntax = {
    $$return: $$return,
    bind: bind,
    map: map$1,
    both: both,
    Open_on_rhs: Open_on_rhs
  };
  var Let_syntax$1 = {
    $$return: $$return,
    $great$great$eq: $great$great$eq,
    $great$great$pipe: $great$great$pipe,
    Let_syntax: Let_syntax
  };
  var join = function (t) {
    return $great$great$eq(t, (function (t$p) {
                  return t$p;
                }));
  };
  var ignore_m = function (t) {
    return Curry._2(map$1, t, (function (param) {
                  
                }));
  };
  var loop = function (vs, param) {
    if (!param) {
      return $$return(List0$negBase.rev(vs));
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (v) {
                  return loop({
                              hd: v,
                              tl: vs
                            }, ts);
                }));
  };
  var all = function (ts) {
    return loop(/* [] */0, ts);
  };
  var all_unit = function (param) {
    if (!param) {
      return $$return(undefined);
    }
    var ts = param.tl;
    return $great$great$eq(param.hd, (function (param) {
                  return all_unit(ts);
                }));
  };
  return {
          $great$great$eq: $great$great$eq,
          $great$great$pipe: $great$great$pipe,
          Let_syntax: Let_syntax$1,
          Monad_infix: Monad_infix,
          bind: bind,
          $$return: $$return,
          map: map$1,
          join: join,
          ignore_m: ignore_m,
          all: all,
          all_unit: all_unit
        };
}

exports.Make = Make;
exports.Make2 = Make2;
exports.Make3 = Make3;
exports.Make_indexed = Make_indexed;
exports.Of_monad = Of_monad;
exports.Of_monad2 = Of_monad2;
exports.Of_monad3 = Of_monad3;
exports.Of_monad_indexed = Of_monad_indexed;
exports.Ident = Ident;
/* No side effect */
