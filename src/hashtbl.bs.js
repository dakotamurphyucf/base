// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int$negBase = require("./int.bs.js");
var List$negBase = require("./list.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Error$negBase = require("./error.bs.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Avltree$negBase = require("./avltree.bs.js");
var Hashable$negBase = require("./hashable.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var With_return$negBase = require("./with_return.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");

function sexp_of_key(t) {
  return t.hashable.sexp_of_t;
}

function ensure_mutation_allowed(t) {
  if (!t.mutation_allowed) {
    return Import$negBase.failwith("Hashtbl: mutation not allowed during iteration");
  }
  
}

function without_mutating(t, f) {
  if (!t.mutation_allowed) {
    return Curry._1(f, undefined);
  }
  t.mutation_allowed = false;
  var x;
  try {
    x = Curry._1(f, undefined);
  }
  catch (exn){
    t.mutation_allowed = true;
    throw exn;
  }
  t.mutation_allowed = true;
  return x;
}

var max_table_length = Int$negBase.floor_pow2(Array0$negBase.max_length);

function create(growth_allowedOpt, sizeOpt, hashable, param) {
  var growth_allowed = growth_allowedOpt !== undefined ? growth_allowedOpt : true;
  var size = sizeOpt !== undefined ? sizeOpt : 0;
  var size$1 = Curry._2(Int$negBase.min, Curry._2(Int$negBase.max, 1, size), max_table_length);
  var size$2 = Int$negBase.ceil_pow2(size$1);
  return {
          table: Array0$negBase.create(size$2, Avltree$negBase.empty),
          length: 0,
          recently_added: {
            contents: false
          },
          growth_allowed: growth_allowed,
          hashable: hashable,
          mutation_allowed: true
        };
}

function slot(t, key) {
  var hash = Curry._1(t.hashable.hash, key);
  return Import$negBase.land(hash, Import$negBase.$neg(t.table.length, 1));
}

function add_worker(t, replace, key, data) {
  var i = slot(t, key);
  var root = Caml_array.get(t.table, i);
  var added = t.recently_added;
  added[0] = false;
  var new_root = Avltree$negBase.add(root, replace, t.hashable.compare, added, key, data);
  if (added[0]) {
    t.length = Import$negBase.$plus(t.length, 1);
  }
  if (!Import$negBase.phys_equal(new_root, root)) {
    return Caml_array.set(t.table, i, new_root);
  }
  
}

function maybe_resize_table(t) {
  var len = t.table.length;
  var should_grow = Import$negBase.$great(t.length, len);
  if (!(should_grow && t.growth_allowed)) {
    return ;
  }
  var new_array_length = Curry._2(Int$negBase.min, Import$negBase.$star(len, 2), max_table_length);
  if (!Import$negBase.$great(new_array_length, len)) {
    return ;
  }
  var new_table = Array0$negBase.create(new_array_length, Avltree$negBase.empty);
  var old_table = t.table;
  t.table = new_table;
  t.length = 0;
  var f = function (key, data) {
    return add_worker(t, true, key, data);
  };
  for(var i = 0 ,i_finish = Import$negBase.$neg(old_table.length, 1); i <= i_finish; ++i){
    Avltree$negBase.iter(Caml_array.get(old_table, i), f);
  }
  
}

function set(t, key, data) {
  ensure_mutation_allowed(t);
  add_worker(t, true, key, data);
  return maybe_resize_table(t);
}

function add(t, key, data) {
  ensure_mutation_allowed(t);
  add_worker(t, false, key, data);
  if (t.recently_added[0]) {
    maybe_resize_table(t);
    return "Ok";
  } else {
    return "Duplicate";
  }
}

function add_exn(t, key, data) {
  var match = add(t, key, data);
  if (match === "Ok") {
    return ;
  }
  var sexp_of_key = t.hashable.sexp_of_t;
  return Error$negBase.raise(Error$negBase.create(undefined, undefined, "Hashtbl.add_exn got key already present", key, sexp_of_key));
}

function clear(t) {
  ensure_mutation_allowed(t);
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.table.length, 1); i <= i_finish; ++i){
    Caml_array.set(t.table, i, Avltree$negBase.empty);
  }
  t.length = 0;
  
}

function find_and_call(t, key, if_found, if_not_found) {
  var tree = Caml_array.get(t.table, slot(t, key));
  if (typeof tree === "number") {
    return Curry._1(if_not_found, key);
  }
  if (tree.TAG === /* Node */0) {
    return Avltree$negBase.find_and_call(tree, t.hashable.compare, key, if_found, if_not_found);
  }
  var v = tree.value;
  if (Curry._2(t.hashable.compare, tree.key, key) === 0) {
    return Curry._1(if_found, v);
  } else {
    return Curry._1(if_not_found, key);
  }
}

function find_and_call1(t, key, a, if_found, if_not_found) {
  var tree = Caml_array.get(t.table, slot(t, key));
  if (typeof tree === "number") {
    return Curry._2(if_not_found, key, a);
  }
  if (tree.TAG === /* Node */0) {
    return Avltree$negBase.find_and_call1(tree, t.hashable.compare, key, a, if_found, if_not_found);
  }
  var v = tree.value;
  if (Curry._2(t.hashable.compare, tree.key, key) === 0) {
    return Curry._2(if_found, v, a);
  } else {
    return Curry._2(if_not_found, key, a);
  }
}

function find_and_call2(t, key, a, b, if_found, if_not_found) {
  var tree = Caml_array.get(t.table, slot(t, key));
  if (typeof tree === "number") {
    return Curry._3(if_not_found, key, a, b);
  }
  if (tree.TAG === /* Node */0) {
    return Avltree$negBase.find_and_call2(tree, t.hashable.compare, key, a, b, if_found, if_not_found);
  }
  var v = tree.value;
  if (Curry._2(t.hashable.compare, tree.key, key) === 0) {
    return Curry._3(if_found, v, a, b);
  } else {
    return Curry._3(if_not_found, key, a, b);
  }
}

function findi_and_call(t, key, if_found, if_not_found) {
  var tree = Caml_array.get(t.table, slot(t, key));
  if (typeof tree === "number") {
    return Curry._1(if_not_found, key);
  }
  if (tree.TAG === /* Node */0) {
    return Avltree$negBase.findi_and_call(tree, t.hashable.compare, key, if_found, if_not_found);
  }
  var k = tree.key;
  var v = tree.value;
  if (Curry._2(t.hashable.compare, k, key) === 0) {
    return Curry._2(if_found, k, v);
  } else {
    return Curry._1(if_not_found, key);
  }
}

function findi_and_call1(t, key, a, if_found, if_not_found) {
  var tree = Caml_array.get(t.table, slot(t, key));
  if (typeof tree === "number") {
    return Curry._2(if_not_found, key, a);
  }
  if (tree.TAG === /* Node */0) {
    return Avltree$negBase.findi_and_call1(tree, t.hashable.compare, key, a, if_found, if_not_found);
  }
  var k = tree.key;
  var v = tree.value;
  if (Curry._2(t.hashable.compare, k, key) === 0) {
    return Curry._3(if_found, k, v, a);
  } else {
    return Curry._2(if_not_found, key, a);
  }
}

function findi_and_call2(t, key, a, b, if_found, if_not_found) {
  var tree = Caml_array.get(t.table, slot(t, key));
  if (typeof tree === "number") {
    return Curry._3(if_not_found, key, a, b);
  }
  if (tree.TAG === /* Node */0) {
    return Avltree$negBase.findi_and_call2(tree, t.hashable.compare, key, a, b, if_found, if_not_found);
  }
  var k = tree.key;
  var v = tree.value;
  if (Curry._2(t.hashable.compare, k, key) === 0) {
    return Curry._4(if_found, k, v, a, b);
  } else {
    return Curry._3(if_not_found, key, a, b);
  }
}

function if_found(v) {
  return Caml_option.some(v);
}

function if_not_found(param) {
  
}

function find(t, key) {
  return find_and_call(t, key, if_found, if_not_found);
}

function mem(t, key) {
  var tree = Caml_array.get(t.table, slot(t, key));
  if (typeof tree === "number") {
    return false;
  } else if (tree.TAG === /* Node */0) {
    return Avltree$negBase.mem(tree, t.hashable.compare, key);
  } else {
    return Curry._2(t.hashable.compare, tree.key, key) === 0;
  }
}

function remove(t, key) {
  ensure_mutation_allowed(t);
  var i = slot(t, key);
  var root = Caml_array.get(t.table, i);
  var added_or_removed = t.recently_added;
  added_or_removed[0] = false;
  var new_root = Avltree$negBase.remove(root, added_or_removed, t.hashable.compare, key);
  if (!Import$negBase.phys_equal(root, new_root)) {
    Caml_array.set(t.table, i, new_root);
  }
  if (added_or_removed[0]) {
    t.length = Import$negBase.$neg(t.length, 1);
    return ;
  }
  
}

function length(t) {
  return t.length;
}

function is_empty(t) {
  return t.length === 0;
}

function fold(t, init, f) {
  if (t.length === 0) {
    return init;
  }
  var n = t.table.length;
  var acc = init;
  var m = t.mutation_allowed;
  var val;
  try {
    t.mutation_allowed = false;
    for(var i = 0 ,i_finish = Import$negBase.$neg(n, 1); i <= i_finish; ++i){
      var bucket = t.table[i];
      if (typeof bucket !== "number") {
        if (bucket.TAG === /* Node */0) {
          acc = Avltree$negBase.fold(bucket, acc, f);
        } else {
          var data = bucket.value;
          acc = Curry._3(f, bucket.key, data, acc);
        }
      }
      
    }
    val = undefined;
  }
  catch (exn){
    t.mutation_allowed = m;
    throw exn;
  }
  t.mutation_allowed = m;
  return acc;
}

function iteri(t, f) {
  if (t.length === 0) {
    return ;
  }
  var n = t.table.length;
  var m = t.mutation_allowed;
  var val;
  try {
    t.mutation_allowed = false;
    for(var i = 0 ,i_finish = Import$negBase.$neg(n, 1); i <= i_finish; ++i){
      var bucket = t.table[i];
      if (typeof bucket !== "number") {
        if (bucket.TAG === /* Node */0) {
          Avltree$negBase.iter(bucket, f);
        } else {
          var data = bucket.value;
          Curry._2(f, bucket.key, data);
        }
      }
      
    }
    val = undefined;
  }
  catch (exn){
    t.mutation_allowed = m;
    throw exn;
  }
  t.mutation_allowed = m;
  
}

function iter(t, f) {
  return iteri(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function iter_keys(t, f) {
  return iteri(t, (function (key, param) {
                return Curry._1(f, key);
              }));
}

function choose_nonempty(table, _i) {
  while(true) {
    var i = _i;
    var avltree = Caml_array.get(table, i);
    if (!Avltree$negBase.is_empty(avltree)) {
      return Avltree$negBase.choose_exn(avltree);
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function choose_exn(t) {
  if (t.length === 0) {
    Error$negBase.raise_s(Sexp$negBase.message("[Hashtbl.choose_exn] of empty hashtbl", /* [] */0));
  }
  return choose_nonempty(t.table, 0);
}

function choose(t) {
  if (t.length === 0) {
    return ;
  } else {
    return choose_nonempty(t.table, 0);
  }
}

function invariant(invariant_key, invariant_data, t) {
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.table.length, 1); i <= i_finish; ++i){
    Avltree$negBase.invariant(Caml_array.get(t.table, i), t.hashable.compare);
  }
  var real_len = fold(t, 0, (function (key, data, i) {
          Curry._1(invariant_key, key);
          Curry._1(invariant_data, data);
          return Import$negBase.$plus(i, 1);
        }));
  if (real_len === t.length) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "hashtbl.ml",
          323,
          2
        ],
        Error: new Error()
      };
}

function if_found$1(v, param) {
  return v;
}

function if_not_found$1(k, t) {
  throw {
        RE_EXN_ID: Import$negBase.Not_found_s,
        _1: {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* Atom */0,
              _0: "Hashtbl.find_exn: not found"
            },
            tl: {
              hd: Curry._1(t.hashable.sexp_of_t, k),
              tl: /* [] */0
            }
          }
        },
        Error: new Error()
      };
}

function find_exn(t, key) {
  return find_and_call1(t, key, t, if_found$1, if_not_found$1);
}

function existsi(t, f) {
  return With_return$negBase.with_return(function (r) {
              iteri(t, (function (key, data) {
                      if (Curry._2(f, key, data)) {
                        return Curry._1(r, true);
                      }
                      
                    }));
              return false;
            });
}

function exists(t, f) {
  return existsi(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function for_alli(t, f) {
  return !existsi(t, (function (key, data) {
                return !Curry._2(f, key, data);
              }));
}

function for_all(t, f) {
  return !existsi(t, (function (param, data) {
                return !Curry._1(f, data);
              }));
}

function counti(t, f) {
  return fold(t, 0, (function (key, data, acc) {
                if (Curry._2(f, key, data)) {
                  return Import$negBase.$plus(acc, 1);
                } else {
                  return acc;
                }
              }));
}

function count(t, f) {
  return fold(t, 0, (function (param, data, acc) {
                if (Curry._1(f, data)) {
                  return Import$negBase.$plus(acc, 1);
                } else {
                  return acc;
                }
              }));
}

function mapi(t, f) {
  var new_t = create(t.growth_allowed, t.length, t.hashable, undefined);
  iteri(t, (function (key, data) {
          return set(new_t, key, Curry._2(f, key, data));
        }));
  return new_t;
}

function map(t, f) {
  return mapi(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function copy(t) {
  return mapi(t, (function (param, data) {
                return data;
              }));
}

function filter_mapi(t, f) {
  var new_t = create(t.growth_allowed, t.length, t.hashable, undefined);
  iteri(t, (function (key, data) {
          var new_data = Curry._2(f, key, data);
          if (new_data !== undefined) {
            return set(new_t, key, Caml_option.valFromOption(new_data));
          }
          
        }));
  return new_t;
}

function filter_map(t, f) {
  return filter_mapi(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function filteri(t, f) {
  return filter_mapi(t, (function (key, data) {
                if (Curry._2(f, key, data)) {
                  return Caml_option.some(data);
                }
                
              }));
}

function filter(t, f) {
  return filteri(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function filter_keys(t, f) {
  return filteri(t, (function (key, param) {
                return Curry._1(f, key);
              }));
}

function partition_mapi(t, f) {
  var t0 = create(t.growth_allowed, t.length, t.hashable, undefined);
  var t1 = create(t.growth_allowed, t.length, t.hashable, undefined);
  iteri(t, (function (key, data) {
          var new_data = Curry._2(f, key, data);
          if (new_data.TAG === /* First */0) {
            return set(t0, key, new_data._0);
          } else {
            return set(t1, key, new_data._0);
          }
        }));
  return [
          t0,
          t1
        ];
}

function partition_map(t, f) {
  return partition_mapi(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function partitioni_tf(t, f) {
  return partition_mapi(t, (function (key, data) {
                if (Curry._2(f, key, data)) {
                  return {
                          TAG: /* First */0,
                          _0: data
                        };
                } else {
                  return {
                          TAG: /* Second */1,
                          _0: data
                        };
                }
              }));
}

function partition_tf(t, f) {
  return partitioni_tf(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function find_or_add(t, id, $$default) {
  var x = find(t, id);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  var $$default$1 = Curry._1($$default, undefined);
  set(t, id, $$default$1);
  return $$default$1;
}

function findi_or_add(t, id, $$default) {
  var x = find(t, id);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  var $$default$1 = Curry._1($$default, id);
  set(t, id, $$default$1);
  return $$default$1;
}

function find_and_remove(t, id) {
  var result = find(t, id);
  if (Option$negBase.is_some(result)) {
    remove(t, id);
  }
  return result;
}

function change(t, id, f) {
  var data = Curry._1(f, find(t, id));
  if (data !== undefined) {
    return set(t, id, Caml_option.valFromOption(data));
  } else {
    return remove(t, id);
  }
}

function update(t, id, f) {
  return set(t, id, Curry._1(f, find(t, id)));
}

function incr_by(remove_if_zero, t, key, by) {
  if (remove_if_zero) {
    return change(t, key, (function (opt) {
                  var n = Import$negBase.$plus(by, Option$negBase.value(opt, 0));
                  if (n !== 0) {
                    return n;
                  }
                  
                }));
  } else {
    return update(t, key, (function (i) {
                  if (i !== undefined) {
                    return Import$negBase.$plus(by, i);
                  } else {
                    return by;
                  }
                }));
  }
}

function incr(byOpt, remove_if_zeroOpt, t, key) {
  var by = byOpt !== undefined ? byOpt : 1;
  var remove_if_zero = remove_if_zeroOpt !== undefined ? remove_if_zeroOpt : false;
  return incr_by(remove_if_zero, t, key, by);
}

function decr(byOpt, remove_if_zeroOpt, t, key) {
  var by = byOpt !== undefined ? byOpt : 1;
  var remove_if_zero = remove_if_zeroOpt !== undefined ? remove_if_zeroOpt : false;
  return incr_by(remove_if_zero, t, key, Import$negBase.$tilde$neg(by));
}

function add_multi(t, key, data) {
  return update(t, key, (function (l) {
                if (l !== undefined) {
                  return {
                          hd: data,
                          tl: l
                        };
                } else {
                  return {
                          hd: data,
                          tl: /* [] */0
                        };
                }
              }));
}

function remove_multi(t, key) {
  var match = find(t, key);
  if (match !== undefined) {
    if (match && match.tl) {
      return set(t, key, match.tl);
    } else {
      return remove(t, key);
    }
  }
  
}

function find_multi(t, key) {
  var l = find(t, key);
  if (l !== undefined) {
    return l;
  } else {
    return /* [] */0;
  }
}

function create_mapped(growth_allowed, size, hashable, get_key, get_data, rows) {
  var size$1 = size !== undefined ? size : List$negBase.length(rows);
  var res = create(growth_allowed, size$1, hashable, undefined);
  var dupes = {
    contents: /* [] */0
  };
  List$negBase.iter(rows, (function (r) {
          var key = Curry._1(get_key, r);
          var data = Curry._1(get_data, r);
          if (mem(res, key)) {
            dupes[0] = {
              hd: key,
              tl: dupes[0]
            };
            return ;
          } else {
            return set(res, key, data);
          }
        }));
  var keys = dupes[0];
  if (keys) {
    return {
            NAME: "Duplicate_keys",
            VAL: List$negBase.dedup_and_sort(hashable.compare, keys)
          };
  } else {
    return {
            NAME: "Ok",
            VAL: res
          };
  }
}

function of_alist(growth_allowed, size, hashable, lst) {
  var match = create_mapped(growth_allowed, size, hashable, Import$negBase.fst, Import$negBase.snd, lst);
  if (match.NAME === "Duplicate_keys") {
    return {
            NAME: "Duplicate_key",
            VAL: List$negBase.hd_exn(match.VAL)
          };
  } else {
    return {
            NAME: "Ok",
            VAL: match.VAL
          };
  }
}

function of_alist_report_all_dups(growth_allowed, size, hashable, lst) {
  return create_mapped(growth_allowed, size, hashable, Import$negBase.fst, Import$negBase.snd, lst);
}

function of_alist_or_error(growth_allowed, size, hashable, lst) {
  var match = of_alist(growth_allowed, size, hashable, lst);
  if (match.NAME === "Ok") {
    return {
            TAG: /* Ok */0,
            _0: match.VAL
          };
  }
  var sexp_of_key = hashable.sexp_of_t;
  return Or_error$negBase.error(undefined, undefined, "Hashtbl.of_alist_exn: duplicate key", match.VAL, sexp_of_key);
}

function of_alist_exn(growth_allowed, size, hashable, lst) {
  var v = of_alist_or_error(growth_allowed, size, hashable, lst);
  if (v.TAG === /* Ok */0) {
    return v._0;
  } else {
    return Error$negBase.raise(v._0);
  }
}

function of_alist_multi(growth_allowed, size, hashable, lst) {
  var get_key = Import$negBase.fst;
  var get_data = Import$negBase.snd;
  var size$1 = size !== undefined ? size : List$negBase.length(lst);
  var res = create(growth_allowed, size$1, hashable, undefined);
  List$negBase.iter(lst, (function (r) {
          var key = Curry._1(get_key, r);
          var data = Curry._1(get_data, r);
          return add_multi(res, key, data);
        }));
  return res;
}

function to_alist(t) {
  return fold(t, /* [] */0, (function (key, data, list) {
                return {
                        hd: [
                          key,
                          data
                        ],
                        tl: list
                      };
              }));
}

function sexp_of_t(sexp_of_key, sexp_of_data, t) {
  var arg = function (param, param$1) {
    return Curry._2(t.hashable.compare, param[0], param$1[0]);
  };
  return Import$negBase.sexp_of_list((function (param) {
                return Import$negBase.sexp_of_pair(sexp_of_key, sexp_of_data, param);
              }), (function (param) {
                  return List$negBase.sort(param, arg);
                })(to_alist(t)));
}

function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp) {
  var alist = Import$negBase.list_of_sexp((function (param) {
          return Import$negBase.pair_of_sexp(k_of_sexp, d_of_sexp, param);
        }), sexp);
  var match = of_alist(undefined, List$negBase.length(alist), hashable, alist);
  if (match.NAME === "Ok") {
    return match.VAL;
  }
  var k = match.VAL;
  var alist_sexps = Import$negBase.list_of_sexp((function (param) {
          return Import$negBase.pair_of_sexp((function (prim) {
                        return prim;
                      }), (function (prim) {
                        return prim;
                      }), param);
        }), sexp);
  var found_first_k = {
    contents: false
  };
  List$negBase.iter2_exn(alist, alist_sexps, (function (param, param$1) {
          if (Curry._2(hashable.compare, k, param[0]) === 0) {
            if (found_first_k[0]) {
              return Import$negBase.of_sexp_error("Hashtbl.t_of_sexp: duplicate key", param$1[0]);
            } else {
              found_first_k[0] = true;
              return ;
            }
          }
          
        }));
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "hashtbl.ml",
          561,
          4
        ],
        Error: new Error()
      };
}

function t_sexp_grammar(k_grammar, v_grammar) {
  return Sexp_grammar$negSexplib0.coerce(List$negBase.Assoc.t_sexp_grammar(k_grammar, v_grammar));
}

function keys(t) {
  return fold(t, /* [] */0, (function (key, param, acc) {
                return {
                        hd: key,
                        tl: acc
                      };
              }));
}

function data(t) {
  return fold(t, /* [] */0, (function (param, data, list) {
                return {
                        hd: data,
                        tl: list
                      };
              }));
}

function add_to_groups(groups, get_key, get_data, combine, rows) {
  return List$negBase.iter(rows, (function (row) {
                var key = Curry._1(get_key, row);
                var data = Curry._1(get_data, row);
                var old = find(groups, key);
                var data$1 = old !== undefined ? Curry._2(combine, Caml_option.valFromOption(old), data) : data;
                return set(groups, key, data$1);
              }));
}

function group(growth_allowed, size, hashable, get_key, get_data, combine, rows) {
  var res = create(growth_allowed, size, hashable, undefined);
  add_to_groups(res, get_key, get_data, combine, rows);
  return res;
}

function create_with_key(growth_allowed, size, hashable, get_key, rows) {
  return create_mapped(growth_allowed, size, hashable, get_key, (function (prim) {
                return prim;
              }), rows);
}

function create_with_key_or_error(growth_allowed, size, hashable, get_key, rows) {
  var match = create_with_key(growth_allowed, size, hashable, get_key, rows);
  if (match.NAME !== "Duplicate_keys") {
    return {
            TAG: /* Ok */0,
            _0: match.VAL
          };
  }
  var sexp_of_key = hashable.sexp_of_t;
  return Or_error$negBase.error_s(Sexp$negBase.message("Hashtbl.create_with_key: duplicate keys", {
                  hd: [
                    "keys",
                    Import$negBase.sexp_of_list(sexp_of_key, match.VAL)
                  ],
                  tl: /* [] */0
                }));
}

function create_with_key_exn(growth_allowed, size, hashable, get_key, rows) {
  return Or_error$negBase.ok_exn(create_with_key_or_error(growth_allowed, size, hashable, get_key, rows));
}

function maybe_set(t, key, f, d) {
  var v = Curry._2(f, key, d);
  if (v !== undefined) {
    return set(t, key, Caml_option.valFromOption(v));
  }
  
}

function merge(t_left, t_right, f) {
  if (!Hashable$negBase.equal(t_left.hashable, t_right.hashable)) {
    Import$negBase.invalid_arg("Hashtbl.merge: different 'hashable' values");
  }
  var new_t = create(t_left.growth_allowed, t_left.length, t_left.hashable, undefined);
  without_mutating(t_left, (function (param) {
          return without_mutating(t_right, (function (param) {
                        iteri(t_left, (function (key, left) {
                                var right = find(t_right, key);
                                if (right !== undefined) {
                                  return maybe_set(new_t, key, f, {
                                              NAME: "Both",
                                              VAL: [
                                                left,
                                                Caml_option.valFromOption(right)
                                              ]
                                            });
                                } else {
                                  return maybe_set(new_t, key, f, {
                                              NAME: "Left",
                                              VAL: left
                                            });
                                }
                              }));
                        return iteri(t_right, (function (key, right) {
                                      var match = find(t_left, key);
                                      if (match !== undefined) {
                                        return ;
                                      } else {
                                        return maybe_set(new_t, key, f, {
                                                    NAME: "Right",
                                                    VAL: right
                                                  });
                                      }
                                    }));
                      }));
        }));
  return new_t;
}

function merge_into(src, dst, f) {
  return iteri(src, (function (key, data) {
                var dst_data = find(dst, key);
                var action = without_mutating(dst, (function (param) {
                        return Curry._3(f, key, data, dst_data);
                      }));
                if (!action) {
                  return remove(dst, key);
                }
                var data$1 = action._0;
                if (dst_data !== undefined && Import$negBase.phys_equal(Caml_option.valFromOption(dst_data), data$1)) {
                  return ;
                } else {
                  return set(dst, key, data$1);
                }
              }));
}

function filteri_inplace(t, f) {
  var to_remove = fold(t, /* [] */0, (function (key, data, ac) {
          if (Curry._2(f, key, data)) {
            return ac;
          } else {
            return {
                    hd: key,
                    tl: ac
                  };
          }
        }));
  return List$negBase.iter(to_remove, (function (key) {
                return remove(t, key);
              }));
}

function filter_inplace(t, f) {
  return filteri_inplace(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function filter_keys_inplace(t, f) {
  return filteri_inplace(t, (function (key, param) {
                return Curry._1(f, key);
              }));
}

function filter_mapi_inplace(t, f) {
  var map_results = fold(t, /* [] */0, (function (key, data, ac) {
          return {
                  hd: [
                    key,
                    Curry._2(f, key, data)
                  ],
                  tl: ac
                };
        }));
  return List$negBase.iter(map_results, (function (param) {
                var result = param[1];
                var key = param[0];
                if (result !== undefined) {
                  return set(t, key, Caml_option.valFromOption(result));
                } else {
                  return remove(t, key);
                }
              }));
}

function filter_map_inplace(t, f) {
  return filter_mapi_inplace(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function mapi_inplace(t, f) {
  ensure_mutation_allowed(t);
  return without_mutating(t, (function (param) {
                return Array0$negBase.iter(t.table, (function (param) {
                              return Avltree$negBase.mapi_inplace(param, f);
                            }));
              }));
}

function map_inplace(t, f) {
  return mapi_inplace(t, (function (param, data) {
                return Curry._1(f, data);
              }));
}

function equal(equal$1, t, t$p) {
  if (t.length === t$p.length) {
    return With_return$negBase.with_return(function (r) {
                without_mutating(t$p, (function (param) {
                        return iteri(t, (function (key, data) {
                                      var data$p = find(t$p, key);
                                      if (data$p !== undefined && Curry._2(equal$1, data, Caml_option.valFromOption(data$p))) {
                                        return ;
                                      } else {
                                        return Curry._1(r, false);
                                      }
                                    }));
                      }));
                return true;
              });
  } else {
    return false;
  }
}

function Creators(Key) {
  var hashable = Key.hashable;
  var create$1 = function (growth_allowed, size, param) {
    return create(growth_allowed, size, hashable, undefined);
  };
  var of_alist$1 = function (growth_allowed, size, l) {
    return of_alist(growth_allowed, size, hashable, l);
  };
  var of_alist_report_all_dups$1 = function (growth_allowed, size, l) {
    return of_alist_report_all_dups(growth_allowed, size, hashable, l);
  };
  var of_alist_or_error$1 = function (growth_allowed, size, l) {
    return of_alist_or_error(growth_allowed, size, hashable, l);
  };
  var of_alist_exn$1 = function (growth_allowed, size, l) {
    return of_alist_exn(growth_allowed, size, hashable, l);
  };
  var t_of_sexp$1 = function (k_of_sexp, d_of_sexp, sexp) {
    return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
  };
  var of_alist_multi$1 = function (growth_allowed, size, l) {
    return of_alist_multi(growth_allowed, size, hashable, l);
  };
  var create_mapped$1 = function (growth_allowed, size, get_key, get_data, l) {
    return create_mapped(growth_allowed, size, hashable, get_key, get_data, l);
  };
  var create_with_key$1 = function (growth_allowed, size, get_key, l) {
    return create_with_key(growth_allowed, size, hashable, get_key, l);
  };
  var create_with_key_or_error$1 = function (growth_allowed, size, get_key, l) {
    return create_with_key_or_error(growth_allowed, size, hashable, get_key, l);
  };
  var create_with_key_exn$1 = function (growth_allowed, size, get_key, l) {
    return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
  };
  var group$1 = function (growth_allowed, size, get_key, get_data, combine, l) {
    return group(growth_allowed, size, hashable, get_key, get_data, combine, l);
  };
  return {
          t_of_sexp: t_of_sexp$1,
          create: create$1,
          of_alist: of_alist$1,
          of_alist_report_all_dups: of_alist_report_all_dups$1,
          of_alist_or_error: of_alist_or_error$1,
          of_alist_exn: of_alist_exn$1,
          of_alist_multi: of_alist_multi$1,
          create_mapped: create_mapped$1,
          create_with_key: create_with_key$1,
          create_with_key_or_error: create_with_key_or_error$1,
          create_with_key_exn: create_with_key_exn$1,
          group: group$1
        };
}

function create$1(growth_allowed, size, param) {
  return create(growth_allowed, size, Hashable$negBase.poly, undefined);
}

function of_alist$1(growth_allowed, size, l) {
  return of_alist(growth_allowed, size, Hashable$negBase.poly, l);
}

function of_alist_report_all_dups$1(growth_allowed, size, l) {
  return of_alist_report_all_dups(growth_allowed, size, Hashable$negBase.poly, l);
}

function of_alist_or_error$1(growth_allowed, size, l) {
  return of_alist_or_error(growth_allowed, size, Hashable$negBase.poly, l);
}

function of_alist_exn$1(growth_allowed, size, l) {
  return of_alist_exn(growth_allowed, size, Hashable$negBase.poly, l);
}

function t_of_sexp$1(k_of_sexp, d_of_sexp, sexp) {
  return t_of_sexp(Hashable$negBase.poly, k_of_sexp, d_of_sexp, sexp);
}

function of_alist_multi$1(growth_allowed, size, l) {
  return of_alist_multi(growth_allowed, size, Hashable$negBase.poly, l);
}

function create_mapped$1(growth_allowed, size, get_key, get_data, l) {
  return create_mapped(growth_allowed, size, Hashable$negBase.poly, get_key, get_data, l);
}

function create_with_key$1(growth_allowed, size, get_key, l) {
  return create_with_key(growth_allowed, size, Hashable$negBase.poly, get_key, l);
}

function create_with_key_or_error$1(growth_allowed, size, get_key, l) {
  return create_with_key_or_error(growth_allowed, size, Hashable$negBase.poly, get_key, l);
}

function create_with_key_exn$1(growth_allowed, size, get_key, l) {
  return create_with_key_exn(growth_allowed, size, Hashable$negBase.poly, get_key, l);
}

function group$1(growth_allowed, size, get_key, get_data, combine, l) {
  return group(growth_allowed, size, Hashable$negBase.poly, get_key, get_data, combine, l);
}

function hashable(t) {
  return t.hashable;
}

var Private = {
  hashable: hashable
};

function create$2(growth_allowed, size, m) {
  return create(growth_allowed, size, Hashable$negBase.of_key(m), undefined);
}

function of_alist$2(growth_allowed, size, m, l) {
  return of_alist(growth_allowed, size, Hashable$negBase.of_key(m), l);
}

function of_alist_report_all_dups$2(growth_allowed, size, m, l) {
  return of_alist_report_all_dups(growth_allowed, size, Hashable$negBase.of_key(m), l);
}

function of_alist_or_error$2(growth_allowed, size, m, l) {
  return of_alist_or_error(growth_allowed, size, Hashable$negBase.of_key(m), l);
}

function of_alist_exn$2(growth_allowed, size, m, l) {
  return of_alist_exn(growth_allowed, size, Hashable$negBase.of_key(m), l);
}

function of_alist_multi$2(growth_allowed, size, m, l) {
  return of_alist_multi(growth_allowed, size, Hashable$negBase.of_key(m), l);
}

function create_mapped$2(growth_allowed, size, m, get_key, get_data, l) {
  return create_mapped(growth_allowed, size, Hashable$negBase.of_key(m), get_key, get_data, l);
}

function create_with_key$2(growth_allowed, size, m, get_key, l) {
  return create_with_key(growth_allowed, size, Hashable$negBase.of_key(m), get_key, l);
}

function create_with_key_or_error$2(growth_allowed, size, m, get_key, l) {
  return create_with_key_or_error(growth_allowed, size, Hashable$negBase.of_key(m), get_key, l);
}

function create_with_key_exn$2(growth_allowed, size, m, get_key, l) {
  return create_with_key_exn(growth_allowed, size, Hashable$negBase.of_key(m), get_key, l);
}

function group$2(growth_allowed, size, m, get_key, get_data, combine, l) {
  return group(growth_allowed, size, Hashable$negBase.of_key(m), get_key, get_data, combine, l);
}

function hashable_s(t) {
  return Hashable$negBase.to_key(t.hashable);
}

function M(K) {
  return {};
}

function sexp_of_m__t(K, sexp_of_v, t) {
  return sexp_of_t(K.sexp_of_t, sexp_of_v, t);
}

function m__t_of_sexp(K, v_of_sexp, sexp) {
  return t_of_sexp(Hashable$negBase.of_key({
                  compare: K.compare,
                  sexp_of_t: K.sexp_of_t,
                  hash: K.hash
                }), K.t_of_sexp, v_of_sexp, sexp);
}

function m__t_sexp_grammar(K, v_grammar) {
  return t_sexp_grammar(K.t_sexp_grammar, v_grammar);
}

var hash = Hashable$negBase.hash;

var hash_param = Hashable$negBase.hash_param;

var similar = equal;

var Poly = {
  t_of_sexp: t_of_sexp$1,
  sexp_of_t: sexp_of_t,
  t_sexp_grammar: t_sexp_grammar,
  hashable: Hashable$negBase.poly,
  invariant: invariant,
  create: create$1,
  of_alist: of_alist$1,
  of_alist_report_all_dups: of_alist_report_all_dups$1,
  of_alist_or_error: of_alist_or_error$1,
  of_alist_exn: of_alist_exn$1,
  of_alist_multi: of_alist_multi$1,
  create_mapped: create_mapped$1,
  create_with_key: create_with_key$1,
  create_with_key_or_error: create_with_key_or_error$1,
  create_with_key_exn: create_with_key_exn$1,
  group: group$1,
  sexp_of_key: sexp_of_key,
  clear: clear,
  copy: copy,
  fold: fold,
  iter_keys: iter_keys,
  iter: iter,
  iteri: iteri,
  existsi: existsi,
  exists: exists,
  for_alli: for_alli,
  for_all: for_all,
  counti: counti,
  count: count,
  length: length,
  is_empty: is_empty,
  mem: mem,
  remove: remove,
  choose: choose,
  choose_exn: choose_exn,
  set: set,
  add: add,
  add_exn: add_exn,
  change: change,
  update: update,
  map: map,
  mapi: mapi,
  filter_map: filter_map,
  filter_mapi: filter_mapi,
  filter_keys: filter_keys,
  filter: filter,
  filteri: filteri,
  partition_map: partition_map,
  partition_mapi: partition_mapi,
  partition_tf: partition_tf,
  partitioni_tf: partitioni_tf,
  find_or_add: find_or_add,
  findi_or_add: findi_or_add,
  find: find,
  find_exn: find_exn,
  find_and_call: find_and_call,
  find_and_call1: find_and_call1,
  find_and_call2: find_and_call2,
  findi_and_call: findi_and_call,
  findi_and_call1: findi_and_call1,
  findi_and_call2: findi_and_call2,
  find_and_remove: find_and_remove,
  merge: merge,
  merge_into: merge_into,
  keys: keys,
  data: data,
  filter_keys_inplace: filter_keys_inplace,
  filter_inplace: filter_inplace,
  filteri_inplace: filteri_inplace,
  map_inplace: map_inplace,
  mapi_inplace: mapi_inplace,
  filter_map_inplace: filter_map_inplace,
  filter_mapi_inplace: filter_mapi_inplace,
  equal: equal,
  similar: equal,
  to_alist: to_alist,
  incr: incr,
  decr: decr,
  add_multi: add_multi,
  remove_multi: remove_multi,
  find_multi: find_multi
};

exports.hash = hash;
exports.hash_param = hash_param;
exports.sexp_of_t = sexp_of_t;
exports.create = create$2;
exports.of_alist = of_alist$2;
exports.of_alist_report_all_dups = of_alist_report_all_dups$2;
exports.of_alist_or_error = of_alist_or_error$2;
exports.of_alist_exn = of_alist_exn$2;
exports.of_alist_multi = of_alist_multi$2;
exports.create_mapped = create_mapped$2;
exports.create_with_key = create_with_key$2;
exports.create_with_key_or_error = create_with_key_or_error$2;
exports.create_with_key_exn = create_with_key_exn$2;
exports.group = group$2;
exports.sexp_of_key = sexp_of_key;
exports.clear = clear;
exports.copy = copy;
exports.fold = fold;
exports.iter_keys = iter_keys;
exports.iter = iter;
exports.iteri = iteri;
exports.existsi = existsi;
exports.exists = exists;
exports.for_alli = for_alli;
exports.for_all = for_all;
exports.counti = counti;
exports.count = count;
exports.length = length;
exports.is_empty = is_empty;
exports.mem = mem;
exports.remove = remove;
exports.choose = choose;
exports.choose_exn = choose_exn;
exports.set = set;
exports.add = add;
exports.add_exn = add_exn;
exports.change = change;
exports.update = update;
exports.map = map;
exports.mapi = mapi;
exports.filter_map = filter_map;
exports.filter_mapi = filter_mapi;
exports.filter_keys = filter_keys;
exports.filter = filter;
exports.filteri = filteri;
exports.partition_map = partition_map;
exports.partition_mapi = partition_mapi;
exports.partition_tf = partition_tf;
exports.partitioni_tf = partitioni_tf;
exports.find_or_add = find_or_add;
exports.findi_or_add = findi_or_add;
exports.find = find;
exports.find_exn = find_exn;
exports.find_and_call = find_and_call;
exports.find_and_call1 = find_and_call1;
exports.find_and_call2 = find_and_call2;
exports.findi_and_call = findi_and_call;
exports.findi_and_call1 = findi_and_call1;
exports.findi_and_call2 = findi_and_call2;
exports.find_and_remove = find_and_remove;
exports.merge = merge;
exports.merge_into = merge_into;
exports.keys = keys;
exports.data = data;
exports.filter_keys_inplace = filter_keys_inplace;
exports.filter_inplace = filter_inplace;
exports.filteri_inplace = filteri_inplace;
exports.map_inplace = map_inplace;
exports.mapi_inplace = mapi_inplace;
exports.filter_map_inplace = filter_map_inplace;
exports.filter_mapi_inplace = filter_mapi_inplace;
exports.equal = equal;
exports.similar = similar;
exports.to_alist = to_alist;
exports.incr = incr;
exports.decr = decr;
exports.add_multi = add_multi;
exports.remove_multi = remove_multi;
exports.find_multi = find_multi;
exports.hashable_s = hashable_s;
exports.invariant = invariant;
exports.Creators = Creators;
exports.Poly = Poly;
exports.M = M;
exports.sexp_of_m__t = sexp_of_m__t;
exports.m__t_of_sexp = m__t_of_sexp;
exports.m__t_sexp_grammar = m__t_sexp_grammar;
exports.Private = Private;
/* max_table_length Not a pure module */
