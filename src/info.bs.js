// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Exn$negBase = require("./exn.bs.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Hash$negBase = require("./hash.bs.js");
var Lazy$negBase = require("./lazy.bs.js");
var List$negBase = require("./list.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var String0$negBase = require("./string0.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Sexp_conv$negSexplib0 = require("sexplib0/./sexp_conv.bs.js");
var Pretty_printer$negBase = require("./pretty_printer.bs.js");
var Source_code_position0$negBase = require("./source_code_position0.bs.js");

function sexp_of_t(v0) {
  switch (v0.TAG | 0) {
    case /* Could_not_construct */0 :
        var v0$1 = Sexp$negBase.sexp_of_t(v0._0);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Could_not_construct"
                  },
                  tl: {
                    hd: v0$1,
                    tl: /* [] */0
                  }
                }
              };
    case /* String */1 :
        var v0$2 = Import$negBase.sexp_of_string(v0._0);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "String"
                  },
                  tl: {
                    hd: v0$2,
                    tl: /* [] */0
                  }
                }
              };
    case /* Exn */2 :
        var v0$3 = Import$negBase.sexp_of_exn(v0._0);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Exn"
                  },
                  tl: {
                    hd: v0$3,
                    tl: /* [] */0
                  }
                }
              };
    case /* Sexp */3 :
        var v0$4 = Sexp$negBase.sexp_of_t(v0._0);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Sexp"
                  },
                  tl: {
                    hd: v0$4,
                    tl: /* [] */0
                  }
                }
              };
    case /* Tag_sexp */4 :
        var v0$5 = Import$negBase.sexp_of_string(v0._0);
        var v1 = Sexp$negBase.sexp_of_t(v0._1);
        var v2 = Import$negBase.sexp_of_option(Source_code_position0$negBase.sexp_of_t, v0._2);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Tag_sexp"
                  },
                  tl: {
                    hd: v0$5,
                    tl: {
                      hd: v1,
                      tl: {
                        hd: v2,
                        tl: /* [] */0
                      }
                    }
                  }
                }
              };
    case /* Tag_t */5 :
        var v0$6 = Import$negBase.sexp_of_string(v0._0);
        var v1$1 = sexp_of_t(v0._1);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Tag_t"
                  },
                  tl: {
                    hd: v0$6,
                    tl: {
                      hd: v1$1,
                      tl: /* [] */0
                    }
                  }
                }
              };
    case /* Tag_arg */6 :
        var v0$7 = Import$negBase.sexp_of_string(v0._0);
        var v1$2 = Sexp$negBase.sexp_of_t(v0._1);
        var v2$1 = sexp_of_t(v0._2);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Tag_arg"
                  },
                  tl: {
                    hd: v0$7,
                    tl: {
                      hd: v1$2,
                      tl: {
                        hd: v2$1,
                        tl: /* [] */0
                      }
                    }
                  }
                }
              };
    case /* Of_list */7 :
        var v0$8 = Import$negBase.sexp_of_option(Import$negBase.sexp_of_int, v0._0);
        var v1$3 = Import$negBase.sexp_of_list(sexp_of_t, v0._1);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Of_list"
                  },
                  tl: {
                    hd: v0$8,
                    tl: {
                      hd: v1$3,
                      tl: /* [] */0
                    }
                  }
                }
              };
    case /* With_backtrace */8 :
        var v0$9 = sexp_of_t(v0._0);
        var v1$4 = Import$negBase.sexp_of_string(v0._1);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "With_backtrace"
                  },
                  tl: {
                    hd: v0$9,
                    tl: {
                      hd: v1$4,
                      tl: /* [] */0
                    }
                  }
                }
              };
    
  }
}

function to_strings_hum(_t, _ac) {
  while(true) {
    var ac = _ac;
    var t = _t;
    switch (t.TAG | 0) {
      case /* Could_not_construct */0 :
          return {
                  hd: "could not construct info: ",
                  tl: {
                    hd: Sexp$negBase.to_string_mach(t._0),
                    tl: ac
                  }
                };
      case /* String */1 :
          return {
                  hd: t._0,
                  tl: ac
                };
      case /* Exn */2 :
          return {
                  hd: Sexp$negBase.to_string_mach(Exn$negBase.sexp_of_t(t._0)),
                  tl: ac
                };
      case /* Sexp */3 :
          return {
                  hd: Sexp$negBase.to_string_mach(t._0),
                  tl: ac
                };
      case /* Tag_sexp */4 :
          return {
                  hd: t._0,
                  tl: {
                    hd: ": ",
                    tl: {
                      hd: Sexp$negBase.to_string_mach(t._1),
                      tl: ac
                    }
                  }
                };
      case /* Tag_t */5 :
          return {
                  hd: t._0,
                  tl: {
                    hd: ": ",
                    tl: to_strings_hum(t._1, ac)
                  }
                };
      case /* Tag_arg */6 :
          var tag = t._0;
          var body_0 = Sexp$negBase.to_string_mach(t._1);
          var body_1 = {
            hd: ": ",
            tl: to_strings_hum(t._2, ac)
          };
          var body = {
            hd: body_0,
            tl: body_1
          };
          if (tag.length === 0) {
            return body;
          } else {
            return {
                    hd: tag,
                    tl: {
                      hd: ": ",
                      tl: body
                    }
                  };
          }
      case /* Of_list */7 :
          var ts = t._1;
          var trunc_after = t._0;
          var ts$1;
          if (trunc_after !== undefined) {
            var n = List$negBase.length(ts);
            ts$1 = Import$negBase.$less$eq(n, trunc_after) ? ts : Import$negBase.$at(List$negBase.take(ts, trunc_after), {
                    hd: {
                      TAG: /* String */1,
                      _0: Curry._1(Printf$negBase.sprintf(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "and ",
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_d */0,
                                    _1: /* No_padding */0,
                                    _2: /* No_precision */0,
                                    _3: {
                                      TAG: /* String_literal */11,
                                      _0: " more info",
                                      _1: /* End_of_format */0
                                    }
                                  }
                                },
                                _1: "and %d more info"
                              }), Import$negBase.$neg(n, trunc_after))
                    },
                    tl: /* [] */0
                  });
          } else {
            ts$1 = ts;
          }
          return List$negBase.fold(List$negBase.rev(ts$1), ac, (function (ac, t) {
                        return to_strings_hum(t, List$negBase.is_empty(ac) ? ac : ({
                                        hd: "; ",
                                        tl: ac
                                      }));
                      }));
      case /* With_backtrace */8 :
          _ac = {
            hd: "\nBacktrace:\n",
            tl: {
              hd: t._1,
              tl: ac
            }
          };
          _t = t._0;
          continue ;
      
    }
  };
}

function to_sexps_hum(t, ac) {
  switch (t.TAG | 0) {
    case /* Could_not_construct */0 :
        return {
                hd: sexp_of_t(t),
                tl: ac
              };
    case /* String */1 :
        return {
                hd: {
                  TAG: /* Atom */0,
                  _0: t._0
                },
                tl: ac
              };
    case /* Exn */2 :
        return {
                hd: Exn$negBase.sexp_of_t(t._0),
                tl: ac
              };
    case /* Sexp */3 :
        return {
                hd: t._0,
                tl: ac
              };
    case /* Tag_sexp */4 :
        var here = t._2;
        return {
                hd: {
                  TAG: /* List */1,
                  _0: {
                    hd: {
                      TAG: /* Atom */0,
                      _0: t._0
                    },
                    tl: {
                      hd: t._1,
                      tl: here !== undefined ? ({
                            hd: Source_code_position0$negBase.sexp_of_t(here),
                            tl: /* [] */0
                          }) : /* [] */0
                    }
                  }
                },
                tl: ac
              };
    case /* Tag_t */5 :
        return {
                hd: {
                  TAG: /* List */1,
                  _0: {
                    hd: {
                      TAG: /* Atom */0,
                      _0: t._0
                    },
                    tl: to_sexps_hum(t._1, /* [] */0)
                  }
                },
                tl: ac
              };
    case /* Tag_arg */6 :
        var tag = t._0;
        var body_0 = t._1;
        var body_1 = to_sexps_hum(t._2, /* [] */0);
        var body = {
          hd: body_0,
          tl: body_1
        };
        if (tag.length === 0) {
          return {
                  hd: {
                    TAG: /* List */1,
                    _0: body
                  },
                  tl: ac
                };
        } else {
          return {
                  hd: {
                    TAG: /* List */1,
                    _0: {
                      hd: {
                        TAG: /* Atom */0,
                        _0: tag
                      },
                      tl: body
                    }
                  },
                  tl: ac
                };
        }
    case /* Of_list */7 :
        return List$negBase.fold(List$negBase.rev(t._1), ac, (function (ac, t) {
                      return to_sexps_hum(t, ac);
                    }));
    case /* With_backtrace */8 :
        return {
                hd: {
                  TAG: /* List */1,
                  _0: {
                    hd: to_sexp_hum(t._0),
                    tl: {
                      hd: {
                        TAG: /* Atom */0,
                        _0: t._1
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: ac
              };
    
  }
}

function to_sexp_hum(t) {
  var sexps = to_sexps_hum(t, /* [] */0);
  if (sexps && !sexps.tl) {
    return sexps.hd;
  } else {
    return {
            TAG: /* List */1,
            _0: sexps
          };
  }
}

function protect(f) {
  try {
    return Curry._1(f, undefined);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: /* Could_not_construct */0,
            _0: Exn$negBase.sexp_of_t(exn)
          };
  }
}

function of_info(info) {
  return protect(function (param) {
              return CamlinternalLazy.force(info);
            });
}

function to_info(t) {
  return {
          LAZY_DONE: true,
          VAL: t
        };
}

function invariant(param) {
  
}

function sexp_of_t$1(t) {
  return to_sexp_hum(protect(function (param) {
                  return CamlinternalLazy.force(t);
                }));
}

function t_of_sexp(sexp) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return {
                      TAG: /* Sexp */3,
                      _0: sexp
                    };
            })
        };
}

function compare(t1, t2) {
  return Sexp$negBase.compare(sexp_of_t$1(t1), sexp_of_t$1(t2));
}

function equal(t1, t2) {
  return Sexp$negBase.equal(sexp_of_t$1(t1), sexp_of_t$1(t2));
}

function hash_fold_t(state, t) {
  return Sexp$negBase.hash_fold_t(state, sexp_of_t$1(t));
}

function hash(t) {
  return Hash$negBase.run(undefined, hash_fold_t, t);
}

function to_string_hum(t) {
  var s = protect(function (param) {
        return CamlinternalLazy.force(t);
      });
  if (s.TAG === /* String */1) {
    return s._0;
  } else {
    return Sexp$negBase.to_string_hum(undefined, to_sexp_hum(s));
  }
}

function to_string_hum_deprecated(t) {
  var t$1 = protect(function (param) {
        return CamlinternalLazy.force(t);
      });
  return String0$negBase.concat(undefined, to_strings_hum(t$1, /* [] */0));
}

function to_string_mach(t) {
  return Sexp$negBase.to_string_mach(sexp_of_t$1(t));
}

function of_lazy(l) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return protect(function (param) {
                          return {
                                  TAG: /* String */1,
                                  _0: CamlinternalLazy.force(l)
                                };
                        });
            })
        };
}

function of_lazy_t(lazy_t) {
  return Curry._1(Lazy$negBase.join, lazy_t);
}

function of_string(message) {
  return Lazy$negBase.from_val({
              TAG: /* String */1,
              _0: message
            });
}

function createf(format) {
  return Printf$negBase.ksprintf(of_string, format);
}

function of_thunk(f) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return protect(function (param) {
                          return {
                                  TAG: /* String */1,
                                  _0: Curry._1(f, undefined)
                                };
                        });
            })
        };
}

function create(here, strict, tag, x, sexp_of_x) {
  if (strict !== undefined) {
    return {
            LAZY_DONE: true,
            VAL: {
              TAG: /* Tag_sexp */4,
              _0: tag,
              _1: Curry._1(sexp_of_x, x),
              _2: here
            }
          };
  } else {
    return {
            LAZY_DONE: false,
            VAL: (function () {
                return protect(function (param) {
                            return {
                                    TAG: /* Tag_sexp */4,
                                    _0: tag,
                                    _1: Curry._1(sexp_of_x, x),
                                    _2: here
                                  };
                          });
              })
          };
  }
}

function create_s(sexp) {
  return Lazy$negBase.from_val({
              TAG: /* Sexp */3,
              _0: sexp
            });
}

function tag(t, tag$1) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return {
                      TAG: /* Tag_t */5,
                      _0: tag$1,
                      _1: protect(function (param) {
                            return CamlinternalLazy.force(t);
                          })
                    };
            })
        };
}

function tag_s(t, tag) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return protect(function (param) {
                          return {
                                  TAG: /* Tag_arg */6,
                                  _0: "",
                                  _1: tag,
                                  _2: protect(function (param) {
                                        return CamlinternalLazy.force(t);
                                      })
                                };
                        });
            })
        };
}

function tag_arg(t, tag, x, sexp_of_x) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return protect(function (param) {
                          return {
                                  TAG: /* Tag_arg */6,
                                  _0: tag,
                                  _1: Curry._1(sexp_of_x, x),
                                  _2: protect(function (param) {
                                        return CamlinternalLazy.force(t);
                                      })
                                };
                        });
            })
        };
}

function of_list(trunc_after, ts) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return {
                      TAG: /* Of_list */7,
                      _0: trunc_after,
                      _1: List$negBase.map(ts, of_info)
                    };
            })
        };
}

var Exn = /* @__PURE__ */Caml_exceptions.create("Info-Base.Exn");

Sexp_conv$negSexplib0.Exn_converter.add(undefined, undefined, Exn, (function (t) {
        if (t.RE_EXN_ID === Exn) {
          return sexp_of_t$1(t._1);
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "info.ml",
                199,
                6
              ],
              Error: new Error()
            };
      }));

function to_exn(t) {
  if (!Lazy$negBase.is_val(t)) {
    return {
            RE_EXN_ID: Exn,
            _1: t
          };
  }
  var exn = CamlinternalLazy.force(t);
  if (exn.TAG === /* Exn */2) {
    return exn._0;
  } else {
    return {
            RE_EXN_ID: Exn,
            _1: t
          };
  }
}

function of_exn(backtrace, exn) {
  var backtrace$1 = backtrace !== undefined ? (
      typeof backtrace === "string" ? Printexc.get_backtrace(undefined) : backtrace.VAL
    ) : undefined;
  if (exn.RE_EXN_ID !== Exn) {
    if (backtrace$1 !== undefined) {
      return {
              LAZY_DONE: false,
              VAL: (function () {
                  return {
                          TAG: /* With_backtrace */8,
                          _0: {
                            TAG: /* Sexp */3,
                            _0: Exn$negBase.sexp_of_t(exn)
                          },
                          _1: backtrace$1
                        };
                })
            };
    } else {
      return Lazy$negBase.from_val({
                  TAG: /* Exn */2,
                  _0: exn
                });
    }
  }
  var t = exn._1;
  if (backtrace$1 !== undefined) {
    return {
            LAZY_DONE: false,
            VAL: (function () {
                return {
                        TAG: /* With_backtrace */8,
                        _0: protect(function (param) {
                              return CamlinternalLazy.force(t);
                            }),
                        _1: backtrace$1
                      };
              })
          };
  } else {
    return t;
  }
}

function pp(ppf, t) {
  return Format.pp_print_string(ppf, to_string_hum(t));
}

var include = Pretty_printer$negBase.Register_pp({
      pp: pp,
      module_name: "Base.Info"
    });

var t_sexp_grammar = {
  TAG: /* Any */0,
  _0: "Info.t"
};

var pp$1 = include.pp;

var Internal_repr = {
  sexp_of_t: sexp_of_t,
  of_info: of_info,
  to_info: to_info
};

exports.compare = compare;
exports.equal = equal;
exports.hash_fold_t = hash_fold_t;
exports.hash = hash;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t$1;
exports.t_sexp_grammar = t_sexp_grammar;
exports.invariant = invariant;
exports.to_string_hum = to_string_hum;
exports.to_string_mach = to_string_mach;
exports.to_string_hum_deprecated = to_string_hum_deprecated;
exports.of_string = of_string;
exports.of_lazy = of_lazy;
exports.of_thunk = of_thunk;
exports.of_lazy_t = of_lazy_t;
exports.create = create;
exports.create_s = create_s;
exports.createf = createf;
exports.tag = tag;
exports.tag_s = tag_s;
exports.tag_arg = tag_arg;
exports.of_list = of_list;
exports.of_exn = of_exn;
exports.to_exn = to_exn;
exports.pp = pp$1;
exports.Internal_repr = Internal_repr;
/*  Not a pure module */
