// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Int$negBase = require("./int.bs.js");
var List$negBase = require("./list.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Array$negBase = require("./array.bs.js");
var Error$negBase = require("./error.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Option_array$negBase = require("./option_array.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");
var Indexed_container$negBase = require("./indexed_container.bs.js");

function sexp_of_t(_of_a, param) {
  var v_num_mutations = param.num_mutations;
  var v_front = param.front;
  var v_mask = param.mask;
  var v_length = param.length;
  var v_elts = param.elts;
  var arg = Option_array$negBase.sexp_of_t(_of_a, v_elts);
  var bnds_0 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "elts"
      },
      tl: {
        hd: arg,
        tl: /* [] */0
      }
    }
  };
  var bnds = {
    hd: bnds_0,
    tl: /* [] */0
  };
  var arg$1 = Import$negBase.sexp_of_int(v_length);
  var bnds_0$1 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "length"
      },
      tl: {
        hd: arg$1,
        tl: /* [] */0
      }
    }
  };
  var bnds$1 = {
    hd: bnds_0$1,
    tl: bnds
  };
  var arg$2 = Import$negBase.sexp_of_int(v_mask);
  var bnds_0$2 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "mask"
      },
      tl: {
        hd: arg$2,
        tl: /* [] */0
      }
    }
  };
  var bnds$2 = {
    hd: bnds_0$2,
    tl: bnds$1
  };
  var arg$3 = Import$negBase.sexp_of_int(v_front);
  var bnds_0$3 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "front"
      },
      tl: {
        hd: arg$3,
        tl: /* [] */0
      }
    }
  };
  var bnds$3 = {
    hd: bnds_0$3,
    tl: bnds$2
  };
  var arg$4 = Import$negBase.sexp_of_int(v_num_mutations);
  var bnds_0$4 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "num_mutations"
      },
      tl: {
        hd: arg$4,
        tl: /* [] */0
      }
    }
  };
  var bnds$4 = {
    hd: bnds_0$4,
    tl: bnds$3
  };
  return {
          TAG: /* List */1,
          _0: bnds$4
        };
}

function inc_num_mutations(t) {
  t.num_mutations = Import$negBase.$plus(t.num_mutations, 1);
  
}

function capacity(t) {
  return Import$negBase.$plus(t.mask, 1);
}

function elts_index(t, i) {
  return Import$negBase.land(Import$negBase.$plus(t.front, i), t.mask);
}

function unsafe_get(t, i) {
  return Option_array$negBase.unsafe_get_some_exn(t.elts, elts_index(t, i));
}

function unsafe_is_set(t, i) {
  return Option_array$negBase.unsafe_is_some(t.elts, elts_index(t, i));
}

function unsafe_set(t, i, a) {
  return Option_array$negBase.unsafe_set_some(t.elts, elts_index(t, i), a);
}

function unsafe_unset(t, i) {
  return Option_array$negBase.unsafe_set_none(t.elts, elts_index(t, i));
}

function check_index_exn(t, i) {
  if (Import$negBase.$less(i, 0) || Import$negBase.$great$eq(i, t.length)) {
    return Error$negBase.raise_s(Sexp$negBase.message("Queue index out of bounds", {
                    hd: [
                      "index",
                      Curry._1(Int$negBase.sexp_of_t, i)
                    ],
                    tl: {
                      hd: [
                        "length",
                        Curry._1(Int$negBase.sexp_of_t, t.length)
                      ],
                      tl: /* [] */0
                    }
                  }));
  }
  
}

function get(t, i) {
  check_index_exn(t, i);
  return unsafe_get(t, i);
}

function set(t, i, a) {
  check_index_exn(t, i);
  inc_num_mutations(t);
  return unsafe_set(t, i, a);
}

function is_empty(t) {
  return t.length === 0;
}

function length(param) {
  return param.length;
}

function ensure_no_mutation(t, num_mutations) {
  if (Import$negBase.$less$great(t.num_mutations, num_mutations)) {
    return Error$negBase.raise_s(Sexp$negBase.message("mutation of queue during iteration", {
                    hd: [
                      "",
                      sexp_of_t((function (param) {
                              return {
                                      TAG: /* Atom */0,
                                      _0: "_"
                                    };
                            }), t)
                    ],
                    tl: /* [] */0
                  }));
  }
  
}

function compare(compare_elt, t1, t2) {
  if (Import$negBase.phys_equal(t1, t2)) {
    return 0;
  } else {
    var _pos = 0;
    var len1 = t1.length;
    var len2 = t2.length;
    var mut1 = t1.num_mutations;
    var mut2 = t2.num_mutations;
    while(true) {
      var pos = _pos;
      var match = pos === len1;
      var match$1 = pos === len2;
      if (match) {
        if (match$1) {
          return 0;
        } else {
          return -1;
        }
      }
      if (match$1) {
        return 1;
      }
      var x = Curry._2(compare_elt, unsafe_get(t1, pos), unsafe_get(t2, pos));
      ensure_no_mutation(t1, mut1);
      ensure_no_mutation(t2, mut2);
      if (x !== 0) {
        return x;
      }
      _pos = Import$negBase.$plus(pos, 1);
      continue ;
    };
  }
}

function equal(equal_elt, t1, t2) {
  if (Import$negBase.phys_equal(t1, t2)) {
    return true;
  }
  var len1 = t1.length;
  var len2 = t2.length;
  if (len1 === len2) {
    var _pos = 0;
    var mut1 = t1.num_mutations;
    var mut2 = t2.num_mutations;
    while(true) {
      var pos = _pos;
      if (pos === len1) {
        return true;
      }
      var b = Curry._2(equal_elt, unsafe_get(t1, pos), unsafe_get(t2, pos));
      ensure_no_mutation(t1, mut1);
      ensure_no_mutation(t2, mut2);
      if (!b) {
        return false;
      }
      _pos = Import$negBase.$plus(pos, 1);
      continue ;
    };
  } else {
    return false;
  }
}

function invariant(invariant_a, t) {
  var num_mutations = t.num_mutations;
  var front = t.front;
  var length = t.length;
  var elts = t.elts;
  if (!Import$negBase.$great$eq(front, 0)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            153,
            2
          ],
          Error: new Error()
        };
  }
  if (!Import$negBase.$less(front, Import$negBase.$plus(t.mask, 1))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            154,
            2
          ],
          Error: new Error()
        };
  }
  var capacity = Import$negBase.$plus(t.mask, 1);
  if (capacity !== Option_array$negBase.length(elts)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            156,
            2
          ],
          Error: new Error()
        };
  }
  if (!Import$negBase.$great$eq(capacity, 1)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            157,
            2
          ],
          Error: new Error()
        };
  }
  if (!Int$negBase.is_pow2(capacity)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            158,
            2
          ],
          Error: new Error()
        };
  }
  if (!Import$negBase.$great$eq(length, 0)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            159,
            2
          ],
          Error: new Error()
        };
  }
  if (!Import$negBase.$less$eq(length, capacity)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            160,
            2
          ],
          Error: new Error()
        };
  }
  for(var i = 0 ,i_finish = Import$negBase.$neg(capacity, 1); i <= i_finish; ++i){
    if (Import$negBase.$less(i, t.length)) {
      Curry._1(invariant_a, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
    } else if (unsafe_is_set(t, i)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "queue.ml",
              166,
              9
            ],
            Error: new Error()
          };
    }
    
  }
  
}

function create(capacity, param) {
  var capacity$1 = capacity !== undefined ? (
      Import$negBase.$less(capacity, 0) ? Error$negBase.raise_s(Sexp$negBase.message("cannot have queue with negative capacity", {
                  hd: [
                    "capacity",
                    Curry._1(Int$negBase.sexp_of_t, capacity)
                  ],
                  tl: /* [] */0
                })) : (
          capacity === 0 ? 1 : Int$negBase.ceil_pow2(capacity)
        )
    ) : 1;
  return {
          num_mutations: 0,
          front: 0,
          mask: Import$negBase.$neg(capacity$1, 1),
          length: 0,
          elts: Option_array$negBase.create(capacity$1)
        };
}

function blit_to_array(src, dst) {
  if (!Import$negBase.$less$eq(src.length, Option_array$negBase.length(dst))) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            194,
            2
          ],
          Error: new Error()
        };
  }
  var front_len = Curry._2(Int$negBase.min, src.length, Import$negBase.$neg(Import$negBase.$plus(src.mask, 1), src.front));
  var rest_len = Import$negBase.$neg(src.length, front_len);
  Curry._5(Option_array$negBase.blit, src.elts, src.front, dst, 0, front_len);
  return Curry._5(Option_array$negBase.blit, src.elts, 0, dst, front_len, rest_len);
}

function set_capacity(t, desired_capacity) {
  inc_num_mutations(t);
  var new_capacity = Int$negBase.ceil_pow2(Import$negBase.max(1, Import$negBase.max(desired_capacity, t.length)));
  if (!Import$negBase.$less$great(new_capacity, Import$negBase.$plus(t.mask, 1))) {
    return ;
  }
  var dst = Option_array$negBase.create(new_capacity);
  blit_to_array(t, dst);
  t.front = 0;
  t.mask = Import$negBase.$neg(new_capacity, 1);
  t.elts = dst;
  
}

function enqueue(t, a) {
  inc_num_mutations(t);
  if (t.length === Import$negBase.$plus(t.mask, 1)) {
    set_capacity(t, Import$negBase.$star(2, t.length));
  }
  unsafe_set(t, t.length, a);
  t.length = Import$negBase.$plus(t.length, 1);
  
}

function dequeue_nonempty(t) {
  inc_num_mutations(t);
  var elts = t.elts;
  var front = t.front;
  var res = Option_array$negBase.get_some_exn(elts, front);
  Option_array$negBase.set_none(elts, front);
  t.front = elts_index(t, 1);
  t.length = Import$negBase.$neg(t.length, 1);
  return res;
}

function dequeue_exn(t) {
  if (t.length === 0) {
    throw {
          RE_EXN_ID: Queue.Empty,
          Error: new Error()
        };
  }
  return dequeue_nonempty(t);
}

function dequeue(t) {
  if (t.length === 0) {
    return ;
  } else {
    return Caml_option.some(dequeue_nonempty(t));
  }
}

function front_nonempty(t) {
  return Option_array$negBase.unsafe_get_some_exn(t.elts, t.front);
}

function last_nonempty(t) {
  return unsafe_get(t, Import$negBase.$neg(t.length, 1));
}

function peek(t) {
  if (t.length === 0) {
    return ;
  } else {
    return Caml_option.some(front_nonempty(t));
  }
}

function peek_exn(t) {
  if (t.length === 0) {
    throw {
          RE_EXN_ID: Queue.Empty,
          Error: new Error()
        };
  }
  return front_nonempty(t);
}

function last(t) {
  if (t.length === 0) {
    return ;
  } else {
    return Caml_option.some(last_nonempty(t));
  }
}

function last_exn(t) {
  if (t.length === 0) {
    throw {
          RE_EXN_ID: Queue.Empty,
          Error: new Error()
        };
  }
  return last_nonempty(t);
}

function clear(t) {
  inc_num_mutations(t);
  if (!Import$negBase.$great(t.length, 0)) {
    return ;
  }
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    unsafe_unset(t, i);
  }
  t.length = 0;
  t.front = 0;
  
}

function blit_transfer(src, dst, len, param) {
  inc_num_mutations(src);
  inc_num_mutations(dst);
  var len$1 = len !== undefined ? (Import$negBase.$less(len, 0) ? Error$negBase.raise_s(Sexp$negBase.message("Queue.blit_transfer: negative length", {
                  hd: [
                    "length",
                    Curry._1(Int$negBase.sexp_of_t, len)
                  ],
                  tl: /* [] */0
                })) : undefined, Import$negBase.min(len, src.length)) : src.length;
  if (!Import$negBase.$great(len$1, 0)) {
    return ;
  }
  set_capacity(dst, Import$negBase.max(Import$negBase.$plus(dst.mask, 1), Import$negBase.$plus(dst.length, len$1)));
  var dst_start = Import$negBase.$plus(dst.front, dst.length);
  for(var i = 0 ,i_finish = Import$negBase.$neg(len$1, 1); i <= i_finish; ++i){
    var src_i = Import$negBase.land(Import$negBase.$plus(src.front, i), src.mask);
    var dst_i = Import$negBase.land(Import$negBase.$plus(dst_start, i), dst.mask);
    Option_array$negBase.unsafe_set_some(dst.elts, dst_i, Option_array$negBase.unsafe_get_some_exn(src.elts, src_i));
    Option_array$negBase.unsafe_set_none(src.elts, src_i);
  }
  dst.length = Import$negBase.$plus(dst.length, len$1);
  src.front = Import$negBase.land(Import$negBase.$plus(src.front, len$1), src.mask);
  src.length = Import$negBase.$neg(src.length, len$1);
  
}

function enqueue_all(t, l) {
  set_capacity(t, Curry._2(Int$negBase.max, Import$negBase.$plus(t.mask, 1), Import$negBase.$plus(t.length, List$negBase.length(l))));
  return List$negBase.iter(l, (function (x) {
                return enqueue(t, x);
              }));
}

function fold(t, init, f) {
  if (t.length === 0) {
    return init;
  }
  var num_mutations = t.num_mutations;
  var r = init;
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    r = Curry._2(f, r, unsafe_get(t, i));
    ensure_no_mutation(t, num_mutations);
  }
  return r;
}

function foldi(t, init, f) {
  var i = {
    contents: 0
  };
  return fold(t, init, (function (acc, a) {
                var acc$1 = Curry._3(f, i[0], acc, a);
                i[0] = Import$negBase.$plus(i[0], 1);
                return acc$1;
              }));
}

function iter(t, f) {
  var num_mutations = t.num_mutations;
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    Curry._1(f, unsafe_get(t, i));
    ensure_no_mutation(t, num_mutations);
  }
  
}

function iteri(t, f) {
  var num_mutations = t.num_mutations;
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    Curry._2(f, i, unsafe_get(t, i));
    ensure_no_mutation(t, num_mutations);
  }
  
}

var iter$1 = {
  NAME: "Custom",
  VAL: iter
};

var length$1 = {
  NAME: "Custom",
  VAL: length
};

var foldi$1 = {
  NAME: "Custom",
  VAL: foldi
};

var iteri$1 = {
  NAME: "Custom",
  VAL: iteri
};

var C = Indexed_container$negBase.Make({
      fold: fold,
      iter: iter$1,
      length: length$1,
      iteri: iteri$1,
      foldi: foldi$1
    });

var to_list = C.to_list;

function concat_map(t, f) {
  var t_result = create(undefined, undefined);
  iter(t, (function (a) {
          return List$negBase.iter(Curry._1(f, a), (function (b) {
                        return enqueue(t_result, b);
                      }));
        }));
  return t_result;
}

function concat_mapi(t, f) {
  var t_result = create(undefined, undefined);
  iteri(t, (function (i, a) {
          return List$negBase.iter(Curry._2(f, i, a), (function (b) {
                        return enqueue(t_result, b);
                      }));
        }));
  return t_result;
}

function filter_map(t, f) {
  var t_result = create(undefined, undefined);
  iter(t, (function (a) {
          var b = Curry._1(f, a);
          if (b !== undefined) {
            return enqueue(t_result, Caml_option.valFromOption(b));
          }
          
        }));
  return t_result;
}

function filter_mapi(t, f) {
  var t_result = create(undefined, undefined);
  iteri(t, (function (i, a) {
          var b = Curry._2(f, i, a);
          if (b !== undefined) {
            return enqueue(t_result, Caml_option.valFromOption(b));
          }
          
        }));
  return t_result;
}

function filter(t, f) {
  var t_result = create(undefined, undefined);
  iter(t, (function (a) {
          if (Curry._1(f, a)) {
            return enqueue(t_result, a);
          }
          
        }));
  return t_result;
}

function filteri(t, f) {
  var t_result = create(undefined, undefined);
  iteri(t, (function (i, a) {
          if (Curry._2(f, i, a)) {
            return enqueue(t_result, a);
          }
          
        }));
  return t_result;
}

function filter_inplace(t, f) {
  var t2 = filter(t, f);
  clear(t);
  return blit_transfer(t2, t, undefined, undefined);
}

function filteri_inplace(t, f) {
  var t2 = filteri(t, f);
  clear(t);
  return blit_transfer(t2, t, undefined, undefined);
}

function copy(src) {
  var dst = create(src.length, undefined);
  blit_to_array(src, dst.elts);
  dst.length = src.length;
  return dst;
}

function of_list(l) {
  var t = create(List$negBase.length(l), undefined);
  List$negBase.iter(l, (function (x) {
          return enqueue(t, x);
        }));
  return t;
}

function init(len, f) {
  if (Import$negBase.$less(len, 0)) {
    Error$negBase.raise_s(Sexp$negBase.message("Queue.init: negative length", {
              hd: [
                "length",
                Curry._1(Int$negBase.sexp_of_t, len)
              ],
              tl: /* [] */0
            }));
  }
  var t = create(len, undefined);
  if (!Import$negBase.$great$eq(Option_array$negBase.length(t.elts), len)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "queue.ml",
            445,
            2
          ],
          Error: new Error()
        };
  }
  for(var i = 0 ,i_finish = Import$negBase.$neg(len, 1); i <= i_finish; ++i){
    Option_array$negBase.unsafe_set_some(t.elts, i, Curry._1(f, i));
  }
  t.length = len;
  return t;
}

function of_array(a) {
  return init(Array$negBase.length(a), (function (param) {
                return a[param];
              }));
}

function to_array(t) {
  return Array$negBase.init(t.length, (function (i) {
                return unsafe_get(t, i);
              }));
}

function map(ta, f) {
  var num_mutations = ta.num_mutations;
  var tb = create(ta.length, undefined);
  tb.length = ta.length;
  for(var i = 0 ,i_finish = Import$negBase.$neg(ta.length, 1); i <= i_finish; ++i){
    var b = Curry._1(f, unsafe_get(ta, i));
    ensure_no_mutation(ta, num_mutations);
    Option_array$negBase.unsafe_set_some(tb.elts, i, b);
  }
  return tb;
}

function mapi(t, f) {
  var i = {
    contents: 0
  };
  return map(t, (function (a) {
                var result = Curry._2(f, i[0], a);
                i[0] = Import$negBase.$plus(i[0], 1);
                return result;
              }));
}

function singleton(x) {
  var t = create(undefined, undefined);
  enqueue(t, x);
  return t;
}

function sexp_of_t$1(sexp_of_a, t) {
  return List$negBase.sexp_of_t(sexp_of_a, Curry._1(to_list, t));
}

function t_of_sexp(a_of_sexp, sexp) {
  return of_list(List$negBase.t_of_sexp(a_of_sexp, sexp));
}

function t_sexp_grammar(grammar) {
  return Sexp_grammar$negSexplib0.coerce(List$negBase.t_sexp_grammar(grammar));
}

var mem = C.mem;

var fold_result = C.fold_result;

var fold_until = C.fold_until;

var exists = C.exists;

var for_all = C.for_all;

var count = C.count;

var sum = C.sum;

var find = C.find;

var find_map = C.find_map;

var min_elt = C.min_elt;

var max_elt = C.max_elt;

var existsi = C.existsi;

var for_alli = C.for_alli;

var counti = C.counti;

var findi = C.findi;

var find_mapi = C.find_mapi;

exports.compare = compare;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t$1;
exports.t_sexp_grammar = t_sexp_grammar;
exports.mem = mem;
exports.length = length;
exports.is_empty = is_empty;
exports.iter = iter;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.count = count;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.foldi = foldi;
exports.iteri = iteri;
exports.existsi = existsi;
exports.for_alli = for_alli;
exports.counti = counti;
exports.findi = findi;
exports.find_mapi = find_mapi;
exports.singleton = singleton;
exports.of_list = of_list;
exports.of_array = of_array;
exports.init = init;
exports.enqueue = enqueue;
exports.enqueue_all = enqueue_all;
exports.dequeue = dequeue;
exports.dequeue_exn = dequeue_exn;
exports.peek = peek;
exports.peek_exn = peek_exn;
exports.clear = clear;
exports.copy = copy;
exports.map = map;
exports.mapi = mapi;
exports.concat_map = concat_map;
exports.concat_mapi = concat_mapi;
exports.filter_map = filter_map;
exports.filter_mapi = filter_mapi;
exports.filter = filter;
exports.filteri = filteri;
exports.filter_inplace = filter_inplace;
exports.filteri_inplace = filteri_inplace;
exports.equal = equal;
exports.invariant = invariant;
exports.create = create;
exports.last = last;
exports.last_exn = last_exn;
exports.blit_transfer = blit_transfer;
exports.get = get;
exports.set = set;
exports.capacity = capacity;
exports.set_capacity = set_capacity;
/* C Not a pure module */
