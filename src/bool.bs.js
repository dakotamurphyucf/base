// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Sexp$negBase = require("./sexp.bs.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Comparator$negBase = require("./comparator.bs.js");
var Pretty_printer$negBase = require("./pretty_printer.bs.js");

var hash = Import$negBase.hash_bool;

var hashable = {
  hash: hash,
  compare: Import$negBase.compare_bool,
  sexp_of_t: Import$negBase.sexp_of_bool
};

function of_string(s) {
  switch (s) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Bool.of_string: expected true or false but got ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        }
                      },
                      _1: "Bool.of_string: expected true or false but got %s"
                    }), s, undefined);
  }
}

var to_string = Import$negBase.Caml.string_of_bool;

var include = Comparator$negBase.Make({
      compare: Import$negBase.compare_bool,
      sexp_of_t: Import$negBase.sexp_of_bool
    });

var include$1 = Pretty_printer$negBase.Register({
      module_name: "Base.Bool",
      to_string: to_string
    });

function invariant(param) {
  
}

function between(t, low, high) {
  if (Curry._2(Import$negBase.Bool_replace_polymorphic_compare.$less$eq, low, t)) {
    return Curry._2(Import$negBase.Bool_replace_polymorphic_compare.$less$eq, t, high);
  } else {
    return false;
  }
}

function clamp_unchecked(t, min, max) {
  if (Curry._2(Import$negBase.Bool_replace_polymorphic_compare.$less, t, min)) {
    return min;
  } else if (Curry._2(Import$negBase.Bool_replace_polymorphic_compare.$less$eq, t, max)) {
    return t;
  } else {
    return max;
  }
}

function clamp_exn(t, min, max) {
  if (!Curry._2(Import$negBase.Bool_replace_polymorphic_compare.$less$eq, min, max)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "bool.ml",
            56,
            2
          ],
          Error: new Error()
        };
  }
  return clamp_unchecked(t, min, max);
}

function clamp(t, min, max) {
  if (Curry._2(Import$negBase.Bool_replace_polymorphic_compare.$great, min, max)) {
    return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                    hd: [
                      "min",
                      Import$negBase.sexp_of_bool(min)
                    ],
                    tl: {
                      hd: [
                        "max",
                        Import$negBase.sexp_of_bool(max)
                      ],
                      tl: /* [] */0
                    }
                  }));
  } else {
    return {
            TAG: /* Ok */0,
            _0: clamp_unchecked(t, min, max)
          };
  }
}

var to_int = Import$negBase.bool_to_int;

function $pipe$pipe(a, b) {
  return Import$negBase.lor(Import$negBase.bool_to_int(a), Import$negBase.bool_to_int(b));
}

function $amp$amp(a, b) {
  return Import$negBase.land(Import$negBase.bool_to_int(a), Import$negBase.bool_to_int(b));
}

if (!(Import$negBase.bool_to_int(true) === 1 && Import$negBase.bool_to_int(false) === 0)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "bool.ml",
          83,
          9
        ],
        Error: new Error()
      };
}

var all = {
  hd: false,
  tl: {
    hd: true,
    tl: /* [] */0
  }
};

var t_sexp_grammar = Import$negBase.bool_sexp_grammar;

var hash_fold_t = Import$negBase.hash_fold_bool;

var t_of_sexp = Import$negBase.bool_of_sexp;

var sexp_of_t = Import$negBase.sexp_of_bool;

var $great$eq = Import$negBase.Bool_replace_polymorphic_compare.$great$eq;

var $less$eq = Import$negBase.Bool_replace_polymorphic_compare.$less$eq;

var $eq = Import$negBase.Bool_replace_polymorphic_compare.$eq;

var $great = Import$negBase.Bool_replace_polymorphic_compare.$great;

var $less = Import$negBase.Bool_replace_polymorphic_compare.$less;

var $less$great = Import$negBase.Bool_replace_polymorphic_compare.$less$great;

var equal = Import$negBase.Bool_replace_polymorphic_compare.equal;

var compare = Import$negBase.Bool_replace_polymorphic_compare.compare;

var min = Import$negBase.Bool_replace_polymorphic_compare.min;

var max = Import$negBase.Bool_replace_polymorphic_compare.max;

var ascending = Import$negBase.Bool_replace_polymorphic_compare.ascending;

var descending = Import$negBase.Bool_replace_polymorphic_compare.descending;

var comparator = include.comparator;

var pp = include$1.pp;

var Non_short_circuiting = {
  $amp$amp: $amp$amp,
  $pipe$pipe: $pipe$pipe
};

exports.all = all;
exports.t_sexp_grammar = t_sexp_grammar;
exports.hash_fold_t = hash_fold_t;
exports.hash = hash;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.of_string = of_string;
exports.to_string = to_string;
exports.$great$eq = $great$eq;
exports.$less$eq = $less$eq;
exports.$eq = $eq;
exports.$great = $great;
exports.$less = $less;
exports.$less$great = $less$great;
exports.equal = equal;
exports.compare = compare;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.pp = pp;
exports.hashable = hashable;
exports.invariant = invariant;
exports.to_int = to_int;
exports.Non_short_circuiting = Non_short_circuiting;
/* include Not a pure module */
