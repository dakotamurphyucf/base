// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Sexp$negBase = require("./sexp.bs.js");
var Poly0$negBase = require("./poly0.bs.js");
var Sign0$negBase = require("./sign0.bs.js");
var Import$negBase = require("./import.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Comparator$negBase = require("./comparator.bs.js");

function gt(cmp, a, b) {
  return Import$negBase.$great(Curry._2(cmp, a, b), 0);
}

function lt(cmp, a, b) {
  return Import$negBase.$less(Curry._2(cmp, a, b), 0);
}

function geq(cmp, a, b) {
  return Import$negBase.$great$eq(Curry._2(cmp, a, b), 0);
}

function leq(cmp, a, b) {
  return Import$negBase.$less$eq(Curry._2(cmp, a, b), 0);
}

function equal(cmp, a, b) {
  return Curry._2(cmp, a, b) === 0;
}

function not_equal(cmp, a, b) {
  return Import$negBase.$less$great(Curry._2(cmp, a, b), 0);
}

function min(cmp, t, t$p) {
  if (leq(cmp, t, t$p)) {
    return t;
  } else {
    return t$p;
  }
}

function max(cmp, t, t$p) {
  if (geq(cmp, t, t$p)) {
    return t;
  } else {
    return t$p;
  }
}

function Infix(T) {
  var $great = function (a, b) {
    return gt(T.compare, a, b);
  };
  var $less = function (a, b) {
    return lt(T.compare, a, b);
  };
  var $great$eq = function (a, b) {
    return geq(T.compare, a, b);
  };
  var $less$eq = function (a, b) {
    return leq(T.compare, a, b);
  };
  var $eq = function (a, b) {
    return equal(T.compare, a, b);
  };
  var $less$great = function (a, b) {
    return not_equal(T.compare, a, b);
  };
  return {
          $great$eq: $great$eq,
          $less$eq: $less$eq,
          $eq: $eq,
          $great: $great,
          $less: $less,
          $less$great: $less$great
        };
}

function Polymorphic_compare(T) {
  var $great = function (a, b) {
    return gt(T.compare, a, b);
  };
  var $less = function (a, b) {
    return lt(T.compare, a, b);
  };
  var $great$eq = function (a, b) {
    return geq(T.compare, a, b);
  };
  var $less$eq = function (a, b) {
    return leq(T.compare, a, b);
  };
  var $eq = function (a, b) {
    return equal(T.compare, a, b);
  };
  var $less$great = function (a, b) {
    return not_equal(T.compare, a, b);
  };
  var compare = T.compare;
  var min$1 = function (t, t$p) {
    return min(compare, t, t$p);
  };
  var max$1 = function (t, t$p) {
    return max(compare, t, t$p);
  };
  return {
          $great$eq: $great$eq,
          $less$eq: $less$eq,
          $eq: $eq,
          $great: $great,
          $less: $less,
          $less$great: $less$great,
          equal: $eq,
          compare: compare,
          min: min$1,
          max: max$1
        };
}

function Make_using_comparator(T) {
  var sexp_of_t = T.sexp_of_t;
  var comparator = T.comparator;
  var compare = comparator.compare;
  var $great = function (a, b) {
    return gt(compare, a, b);
  };
  var $less = function (a, b) {
    return lt(compare, a, b);
  };
  var $great$eq = function (a, b) {
    return geq(compare, a, b);
  };
  var $less$eq = function (a, b) {
    return leq(compare, a, b);
  };
  var $eq = function (a, b) {
    return equal(compare, a, b);
  };
  var $less$great = function (a, b) {
    return not_equal(compare, a, b);
  };
  var min$1 = function (t, t$p) {
    return min(compare, t, t$p);
  };
  var max$1 = function (t, t$p) {
    return max(compare, t, t$p);
  };
  var descending = function (t, t$p) {
    return Curry._2(compare, t$p, t);
  };
  var between = function (t, low, high) {
    if (leq(compare, low, t)) {
      return leq(compare, t, high);
    } else {
      return false;
    }
  };
  var clamp_unchecked = function (t, min, max) {
    if (lt(compare, t, min)) {
      return min;
    } else if (leq(compare, t, max)) {
      return t;
    } else {
      return max;
    }
  };
  var clamp_exn = function (t, min, max) {
    if (!leq(compare, min, max)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "comparable.ml",
              133,
              4
            ],
            Error: new Error()
          };
    }
    return clamp_unchecked(t, min, max);
  };
  var clamp = function (t, min, max) {
    if (gt(compare, min, max)) {
      return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                      hd: [
                        "min",
                        Curry._1(sexp_of_t, min)
                      ],
                      tl: {
                        hd: [
                          "max",
                          Curry._1(sexp_of_t, max)
                        ],
                        tl: /* [] */0
                      }
                    }));
    } else {
      return {
              TAG: /* Ok */0,
              _0: clamp_unchecked(t, min, max)
            };
    }
  };
  return {
          $great$eq: $great$eq,
          $less$eq: $less$eq,
          $eq: $eq,
          $great: $great,
          $less: $less,
          $less$great: $less$great,
          equal: $eq,
          compare: compare,
          min: min$1,
          max: max$1,
          ascending: compare,
          descending: descending,
          between: between,
          clamp_exn: clamp_exn,
          clamp: clamp,
          comparator: comparator
        };
}

function Make(T) {
  var sexp_of_t = T.sexp_of_t;
  var include = Comparator$negBase.Make(T);
  var comparator = include.comparator;
  var compare = comparator.compare;
  var $great = function (a, b) {
    return gt(compare, a, b);
  };
  var $less = function (a, b) {
    return lt(compare, a, b);
  };
  var $great$eq = function (a, b) {
    return geq(compare, a, b);
  };
  var $less$eq = function (a, b) {
    return leq(compare, a, b);
  };
  var $eq = function (a, b) {
    return equal(compare, a, b);
  };
  var $less$great = function (a, b) {
    return not_equal(compare, a, b);
  };
  var min$1 = function (t, t$p) {
    return min(compare, t, t$p);
  };
  var max$1 = function (t, t$p) {
    return max(compare, t, t$p);
  };
  var descending = function (t, t$p) {
    return Curry._2(compare, t$p, t);
  };
  var between = function (t, low, high) {
    if (leq(compare, low, t)) {
      return leq(compare, t, high);
    } else {
      return false;
    }
  };
  var clamp_unchecked = function (t, min, max) {
    if (lt(compare, t, min)) {
      return min;
    } else if (leq(compare, t, max)) {
      return t;
    } else {
      return max;
    }
  };
  var clamp_exn = function (t, min, max) {
    if (!leq(compare, min, max)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "comparable.ml",
              133,
              4
            ],
            Error: new Error()
          };
    }
    return clamp_unchecked(t, min, max);
  };
  var clamp = function (t, min, max) {
    if (gt(compare, min, max)) {
      return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                      hd: [
                        "min",
                        Curry._1(sexp_of_t, min)
                      ],
                      tl: {
                        hd: [
                          "max",
                          Curry._1(sexp_of_t, max)
                        ],
                        tl: /* [] */0
                      }
                    }));
    } else {
      return {
              TAG: /* Ok */0,
              _0: clamp_unchecked(t, min, max)
            };
    }
  };
  return {
          $great$eq: $great$eq,
          $less$eq: $less$eq,
          $eq: $eq,
          $great: $great,
          $less: $less,
          $less$great: $less$great,
          equal: $eq,
          compare: compare,
          min: min$1,
          max: max$1,
          ascending: compare,
          descending: descending,
          between: between,
          clamp_exn: clamp_exn,
          clamp: clamp,
          comparator: comparator
        };
}

function Inherit(C, T) {
  var sexp_of_t = T.sexp_of_t;
  var compare = function (t, t$p) {
    return Curry._2(C.compare, Curry._1(T.component, t), Curry._1(T.component, t$p));
  };
  var T$1 = {
    compare: compare,
    sexp_of_t: sexp_of_t
  };
  var include = Comparator$negBase.Make(T$1);
  var comparator = include.comparator;
  var compare$1 = comparator.compare;
  var $great = function (a, b) {
    return gt(compare$1, a, b);
  };
  var $less = function (a, b) {
    return lt(compare$1, a, b);
  };
  var $great$eq = function (a, b) {
    return geq(compare$1, a, b);
  };
  var $less$eq = function (a, b) {
    return leq(compare$1, a, b);
  };
  var $eq = function (a, b) {
    return equal(compare$1, a, b);
  };
  var $less$great = function (a, b) {
    return not_equal(compare$1, a, b);
  };
  var min$1 = function (t, t$p) {
    return min(compare$1, t, t$p);
  };
  var max$1 = function (t, t$p) {
    return max(compare$1, t, t$p);
  };
  var descending = function (t, t$p) {
    return Curry._2(compare$1, t$p, t);
  };
  var between = function (t, low, high) {
    if (leq(compare$1, low, t)) {
      return leq(compare$1, t, high);
    } else {
      return false;
    }
  };
  var clamp_unchecked = function (t, min, max) {
    if (lt(compare$1, t, min)) {
      return min;
    } else if (leq(compare$1, t, max)) {
      return t;
    } else {
      return max;
    }
  };
  var clamp_exn = function (t, min, max) {
    if (!leq(compare$1, min, max)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "comparable.ml",
              133,
              4
            ],
            Error: new Error()
          };
    }
    return clamp_unchecked(t, min, max);
  };
  var clamp = function (t, min, max) {
    if (gt(compare$1, min, max)) {
      return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                      hd: [
                        "min",
                        Curry._1(sexp_of_t, min)
                      ],
                      tl: {
                        hd: [
                          "max",
                          Curry._1(sexp_of_t, max)
                        ],
                        tl: /* [] */0
                      }
                    }));
    } else {
      return {
              TAG: /* Ok */0,
              _0: clamp_unchecked(t, min, max)
            };
    }
  };
  return {
          $great$eq: $great$eq,
          $less$eq: $less$eq,
          $eq: $eq,
          $great: $great,
          $less: $less,
          $less$great: $less$great,
          equal: $eq,
          compare: compare$1,
          min: min$1,
          max: max$1,
          ascending: compare$1,
          descending: descending,
          between: between,
          clamp_exn: clamp_exn,
          clamp: clamp,
          comparator: comparator
        };
}

function lexicographic(cmps, x, y) {
  var _param = cmps;
  while(true) {
    var param = _param;
    if (!param) {
      return 0;
    }
    var res = Curry._2(param.hd, x, y);
    if (res !== 0) {
      return res;
    }
    _param = param.tl;
    continue ;
  };
}

function lift(cmp, f, x, y) {
  return Curry._2(cmp, Curry._1(f, x), Curry._1(f, y));
}

function reverse(cmp, x, y) {
  return Curry._2(cmp, y, x);
}

function Poly(funarg) {
  var between = function (t, low, high) {
    if (Caml_obj.caml_lessequal(low, t)) {
      return Caml_obj.caml_lessequal(t, high);
    } else {
      return false;
    }
  };
  var clamp_unchecked = function (t, min, max) {
    if (Caml_obj.caml_lessthan(t, min)) {
      return min;
    } else if (Caml_obj.caml_lessequal(t, max)) {
      return t;
    } else {
      return max;
    }
  };
  var clamp_exn = function (t, min, max) {
    if (!Caml_obj.caml_lessequal(min, max)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "comparable.ml",
              47,
              4
            ],
            Error: new Error()
          };
    }
    return clamp_unchecked(t, min, max);
  };
  var clamp = function (t, min, max) {
    if (Caml_obj.caml_greaterthan(min, max)) {
      return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                      hd: [
                        "min",
                        Curry._1(funarg.sexp_of_t, min)
                      ],
                      tl: {
                        hd: [
                          "max",
                          Curry._1(funarg.sexp_of_t, max)
                        ],
                        tl: /* [] */0
                      }
                    }));
    } else {
      return {
              TAG: /* Ok */0,
              _0: clamp_unchecked(t, min, max)
            };
    }
  };
  var include = Comparator$negBase.Make({
        compare: Caml_obj.caml_compare,
        sexp_of_t: funarg.sexp_of_t
      });
  return {
          $great$eq: Caml_obj.caml_greaterequal,
          $less$eq: Caml_obj.caml_lessequal,
          $eq: Caml_obj.caml_equal,
          $great: Caml_obj.caml_greaterthan,
          $less: Caml_obj.caml_lessthan,
          $less$great: Caml_obj.caml_notequal,
          equal: Caml_obj.caml_equal,
          compare: Caml_obj.caml_compare,
          min: Poly0$negBase.min,
          max: Poly0$negBase.max,
          ascending: Poly0$negBase.ascending,
          descending: Poly0$negBase.descending,
          between: between,
          clamp_exn: clamp_exn,
          clamp: clamp,
          comparator: include.comparator
        };
}

function With_zero(funarg) {
  var is_positive = function (t) {
    return Import$negBase.$great(Curry._2(funarg.compare, t, funarg.zero), 0);
  };
  var is_non_negative = function (t) {
    return Import$negBase.$great$eq(Curry._2(funarg.compare, t, funarg.zero), 0);
  };
  var is_negative = function (t) {
    return Import$negBase.$less(Curry._2(funarg.compare, t, funarg.zero), 0);
  };
  var is_non_positive = function (t) {
    return Import$negBase.$less$eq(Curry._2(funarg.compare, t, funarg.zero), 0);
  };
  var sign = function (t) {
    return Sign0$negBase.of_int(Curry._2(funarg.compare, t, funarg.zero));
  };
  return {
          is_positive: is_positive,
          is_non_negative: is_non_negative,
          is_negative: is_negative,
          is_non_positive: is_non_positive,
          sign: sign
        };
}

exports.lexicographic = lexicographic;
exports.lift = lift;
exports.reverse = reverse;
exports.equal = equal;
exports.max = max;
exports.min = min;
exports.Infix = Infix;
exports.Polymorphic_compare = Polymorphic_compare;
exports.Inherit = Inherit;
exports.Make = Make;
exports.Make_using_comparator = Make_using_comparator;
exports.Poly = Poly;
exports.With_zero = With_zero;
/* Sexp-Base Not a pure module */
