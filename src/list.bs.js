// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Sys$negBase = require("./sys.bs.js");
var List1$negBase = require("./list1.bs.js");
var Monad$negBase = require("./monad.bs.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Random$negBase = require("./random.bs.js");
var Result$negBase = require("./result.bs.js");
var Ordering$negBase = require("./ordering.bs.js");
var Container$negBase = require("./container.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Array_permute$negBase = require("./array_permute.bs.js");
var Sexp_conv$negSexplib0 = require("sexplib0/./sexp_conv.bs.js");
var Ppx_compare_lib$negBase = require("./ppx_compare_lib.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

var t_sexp_grammar = Import$negBase.list_sexp_grammar;

function compare(_cmp__a, a__001_, b__002_) {
  if (Ppx_compare_lib$negBase.phys_equal(a__001_, b__002_)) {
    return 0;
  } else if (a__001_) {
    if (b__002_) {
      return Curry._2(_cmp__a, a__001_._0, b__002_._0);
    } else {
      return -1;
    }
  } else if (b__002_) {
    return 1;
  } else {
    return 0;
  }
}

function sexp_of_t(_of_a, v0) {
  if (!v0) {
    return {
            TAG: /* Atom */0,
            _0: "Unequal_lengths"
          };
  }
  var v0$1 = Curry._1(_of_a, v0._0);
  return {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* Atom */0,
              _0: "Ok"
            },
            tl: {
              hd: v0$1,
              tl: /* [] */0
            }
          }
        };
}

var Or_unequal_lengths = {
  compare: compare,
  sexp_of_t: sexp_of_t
};

function invariant(f, t) {
  return List1$negBase.iter(t, f);
}

function of_list(t) {
  return t;
}

function range$p(compare, stride, startOpt, stopOpt, start_i, stop_i) {
  var start = startOpt !== undefined ? startOpt : "inclusive";
  var stop = stopOpt !== undefined ? stopOpt : "exclusive";
  var next_i = Curry._1(stride, start_i);
  var match = Ordering$negBase.of_int(Curry._2(compare, start_i, next_i));
  var initial_stride_order;
  switch (match) {
    case /* Less */0 :
        initial_stride_order = "Less";
        break;
    case /* Equal */1 :
        initial_stride_order = Import$negBase.invalid_arg("List.range': stride function cannot return the same value");
        break;
    case /* Greater */2 :
        initial_stride_order = "Greater";
        break;
    
  }
  var loop = function (_i, _accum) {
    while(true) {
      var accum = _accum;
      var i = _i;
      var i_to_stop_order = Ordering$negBase.of_int(Curry._2(compare, i, stop_i));
      switch (i_to_stop_order) {
        case /* Less */0 :
            if (initial_stride_order !== "Less") {
              return accum;
            }
            break;
        case /* Equal */1 :
            if (stop === "inclusive") {
              return {
                      hd: i,
                      tl: accum
                    };
            } else {
              return accum;
            }
        case /* Greater */2 :
            if (initial_stride_order === "Less") {
              return accum;
            }
            break;
        
      }
      var next_i = Curry._1(stride, i);
      var match = Ordering$negBase.of_int(Curry._2(compare, i, next_i));
      switch (match) {
        case /* Less */0 :
            if (initial_stride_order !== "Less") {
              return Import$negBase.invalid_arg("List.range': stride function cannot change direction");
            }
            _accum = {
              hd: i,
              tl: accum
            };
            _i = next_i;
            continue ;
        case /* Equal */1 :
            return Import$negBase.invalid_arg("List.range': stride function cannot return the same value");
        case /* Greater */2 :
            if (initial_stride_order === "Less") {
              return Import$negBase.invalid_arg("List.range': stride function cannot change direction");
            }
            _accum = {
              hd: i,
              tl: accum
            };
            _i = next_i;
            continue ;
        
      }
    };
  };
  var start_i$1 = start === "inclusive" ? start_i : next_i;
  return List1$negBase.rev(loop(start_i$1, /* [] */0));
}

function range(strideOpt, startOpt, stopOpt, start_i, stop_i) {
  var stride = strideOpt !== undefined ? strideOpt : 1;
  var start = startOpt !== undefined ? startOpt : "inclusive";
  var stop = stopOpt !== undefined ? stopOpt : "exclusive";
  if (stride === 0) {
    Import$negBase.invalid_arg("List.range: stride must be non-zero");
  }
  return range$p(Import$negBase.compare, (function (x) {
                return Import$negBase.$plus(x, stride);
              }), start, stop, start_i, stop_i);
}

function hd(t) {
  if (t) {
    return Caml_option.some(t.hd);
  }
  
}

function tl(t) {
  if (t) {
    return t.tl;
  }
  
}

function nth(t, n) {
  if (Import$negBase.$less(n, 0)) {
    return ;
  }
  var _t = t;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var t$1 = _t;
    if (!t$1) {
      return ;
    }
    if (n$1 === 0) {
      return Caml_option.some(t$1.hd);
    }
    _n = Import$negBase.$neg(n$1, 1);
    _t = t$1.tl;
    continue ;
  };
}

function nth_exn(t, n) {
  var a = nth(t, n);
  if (a !== undefined) {
    return Caml_option.valFromOption(a);
  } else {
    return Curry._3(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "List.nth_exn ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: " called on list of length ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "List.nth_exn %d called on list of length %d"
                  }), n, List1$negBase.length(t), undefined);
  }
}

function unordered_append(l1, l2) {
  if (l1) {
    if (l2) {
      return List1$negBase.rev_append(l1, l2);
    } else {
      return l1;
    }
  } else {
    return l2;
  }
}

function of_lists(l1, l2) {
  var _a = l1;
  var _b = l2;
  var _shared_length = 0;
  while(true) {
    var shared_length = _shared_length;
    var b = _b;
    var a = _a;
    if (!a) {
      if (b) {
        return {
                TAG: /* Unequal_lengths */1,
                shared_length: shared_length,
                tail_of_a: a,
                tail_of_b: b
              };
      } else {
        return {
                TAG: /* Same_length */0,
                _0: shared_length
              };
      }
    }
    if (!b) {
      return {
              TAG: /* Unequal_lengths */1,
              shared_length: shared_length,
              tail_of_a: a,
              tail_of_b: b
            };
    }
    _shared_length = Import$negBase.$plus(shared_length, 1);
    _b = b.tl;
    _a = a.tl;
    continue ;
  };
}

function check_length2_exn(name, l1, l2) {
  var match = of_lists(l1, l2);
  if (match.TAG === /* Same_length */0) {
    return ;
  }
  var shared_length = match.shared_length;
  return Curry._4(Printf$negBase.invalid_argf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "length mismatch in ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: " <> ",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "length mismatch in %s: %d <> %d"
                }), name, Import$negBase.$plus(shared_length, List1$negBase.length(match.tail_of_a)), Import$negBase.$plus(shared_length, List1$negBase.length(match.tail_of_b)), undefined);
}

function check_length2(l1, l2, f) {
  var match = of_lists(l1, l2);
  if (match.TAG === /* Same_length */0) {
    return /* Ok */{
            _0: Curry._2(f, l1, l2)
          };
  } else {
    return /* Unequal_lengths */0;
  }
}

function of_lists$1(l1, l2, l3) {
  var _a = l1;
  var _b = l2;
  var _c = l3;
  var _shared_length = 0;
  while(true) {
    var shared_length = _shared_length;
    var c = _c;
    var b = _b;
    var a = _a;
    if (a) {
      if (b && c) {
        _shared_length = Import$negBase.$plus(shared_length, 1);
        _c = c.tl;
        _b = b.tl;
        _a = a.tl;
        continue ;
      }
      
    } else if (!b && !c) {
      return {
              TAG: /* Same_length */0,
              _0: shared_length
            };
    }
    return {
            TAG: /* Unequal_lengths */1,
            shared_length: shared_length,
            tail_of_a: a,
            tail_of_b: b,
            tail_of_c: c
          };
  };
}

function check_length3_exn(name, l1, l2, l3) {
  var match = of_lists$1(l1, l2, l3);
  if (match.TAG === /* Same_length */0) {
    return ;
  }
  var shared_length = match.shared_length;
  var n1 = Import$negBase.$plus(shared_length, List1$negBase.length(match.tail_of_a));
  var n2 = Import$negBase.$plus(shared_length, List1$negBase.length(match.tail_of_b));
  var n3 = Import$negBase.$plus(shared_length, List1$negBase.length(match.tail_of_c));
  return Curry._6(Printf$negBase.invalid_argf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "length mismatch in ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: " <> ",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* String_literal */11,
                                _0: " || ",
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: {
                                    TAG: /* String_literal */11,
                                    _0: " <> ",
                                    _1: {
                                      TAG: /* Int */4,
                                      _0: /* Int_d */0,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "length mismatch in %s: %d <> %d || %d <> %d"
                }), name, n1, n2, n2, n3, undefined);
}

function check_length3(l1, l2, l3, f) {
  var match = of_lists$1(l1, l2, l3);
  if (match.TAG === /* Same_length */0) {
    return /* Ok */{
            _0: Curry._3(f, l1, l2, l3)
          };
  } else {
    return /* Unequal_lengths */0;
  }
}

function iter2(l1, l2, f) {
  return check_length2(l1, l2, (function (param) {
                return function (param$1) {
                  return List1$negBase.iter2_ok(param, param$1, f);
                };
              }));
}

function iter2_exn(l1, l2, f) {
  check_length2_exn("iter2_exn", l1, l2);
  return List1$negBase.iter2_ok(l1, l2, f);
}

function rev_map2(l1, l2, f) {
  return check_length2(l1, l2, (function (param) {
                return function (param$1) {
                  return List1$negBase.rev_map2_ok(param, param$1, f);
                };
              }));
}

function rev_map2_exn(l1, l2, f) {
  check_length2_exn("rev_map2_exn", l1, l2);
  return List1$negBase.rev_map2_ok(l1, l2, f);
}

function fold2(l1, l2, init, f) {
  return check_length2(l1, l2, (function (param) {
                return function (param$1) {
                  return List1$negBase.fold2_ok(param, param$1, init, f);
                };
              }));
}

function fold2_exn(l1, l2, init, f) {
  check_length2_exn("fold2_exn", l1, l2);
  return List1$negBase.fold2_ok(l1, l2, init, f);
}

function for_all2(l1, l2, f) {
  return check_length2(l1, l2, (function (param) {
                return function (param$1) {
                  return List1$negBase.for_all2_ok(param, param$1, f);
                };
              }));
}

function for_all2_exn(l1, l2, f) {
  check_length2_exn("for_all2_exn", l1, l2);
  return List1$negBase.for_all2_ok(l1, l2, f);
}

function exists2(l1, l2, f) {
  return check_length2(l1, l2, (function (param) {
                return function (param$1) {
                  return List1$negBase.exists2_ok(param, param$1, f);
                };
              }));
}

function exists2_exn(l1, l2, f) {
  check_length2_exn("exists2_exn", l1, l2);
  return List1$negBase.exists2_ok(l1, l2, f);
}

function mem(t, a, equal) {
  var _param = t;
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Curry._2(equal, a, param.hd)) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function rev_filter(t, f) {
  var _accu = /* [] */0;
  var _param = t;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    var l = param.tl;
    var x = param.hd;
    if (Curry._1(f, x)) {
      _param = l;
      _accu = {
        hd: x,
        tl: accu
      };
      continue ;
    }
    _param = l;
    continue ;
  };
}

function filter(t, f) {
  return List1$negBase.rev(rev_filter(t, f));
}

function find_map(t, f) {
  var _param = t;
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var r = Curry._1(f, param.hd);
    if (r !== undefined) {
      return r;
    }
    _param = param.tl;
    continue ;
  };
}

var not_found_1 = {
  TAG: /* Atom */0,
  _0: "List.find_map_exn: not found"
};

var not_found = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1
};

function find_map_exn(t, f) {
  var x = find_map(t, f);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw not_found;
}

function find(t, f) {
  var _param = t;
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var x = param.hd;
    if (Curry._1(f, x)) {
      return Caml_option.some(x);
    }
    _param = param.tl;
    continue ;
  };
}

var not_found_1$1 = {
  TAG: /* Atom */0,
  _0: "List.find_exn: not found"
};

var not_found$1 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$1
};

function find_exn(_t, f) {
  while(true) {
    var t = _t;
    if (t) {
      var x = t.hd;
      if (Curry._1(f, x)) {
        return x;
      }
      _t = t.tl;
      continue ;
    }
    throw not_found$1;
  };
}

function findi(t, f) {
  var _i = 0;
  var _t = t;
  while(true) {
    var t$1 = _t;
    var i = _i;
    if (!t$1) {
      return ;
    }
    var x = t$1.hd;
    if (Curry._2(f, i, x)) {
      return [
              i,
              x
            ];
    }
    _t = t$1.tl;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function find_mapi(t, f) {
  var _i = 0;
  var _t = t;
  while(true) {
    var t$1 = _t;
    var i = _i;
    if (!t$1) {
      return ;
    }
    var result = Curry._2(f, i, t$1.hd);
    if (result !== undefined) {
      return result;
    }
    _t = t$1.tl;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

var not_found_1$2 = {
  TAG: /* Atom */0,
  _0: "List.find_mapi_exn: not found"
};

var not_found$2 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$2
};

function find_mapi_exn(t, f) {
  var x = find_mapi(t, f);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw not_found$2;
}

function for_alli(t, f) {
  var _i = 0;
  var _t = t;
  while(true) {
    var t$1 = _t;
    var i = _i;
    if (!t$1) {
      return true;
    }
    if (!Curry._2(f, i, t$1.hd)) {
      return false;
    }
    _t = t$1.tl;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function existsi(t, f) {
  var _i = 0;
  var _t = t;
  while(true) {
    var t$1 = _t;
    var i = _i;
    if (!t$1) {
      return false;
    }
    if (Curry._2(f, i, t$1.hd)) {
      return true;
    }
    _t = t$1.tl;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function to_list(t) {
  return t;
}

var max_non_tailcall = typeof Sys$negBase.backend_type === "number" ? 1000 : 50;

function count_append(l1, l2, count) {
  if (!l2) {
    return l1;
  }
  if (!l1) {
    return l2;
  }
  var match = l1.tl;
  var x1 = l1.hd;
  if (!match) {
    return {
            hd: x1,
            tl: l2
          };
  }
  var match$1 = match.tl;
  var x2 = match.hd;
  if (!match$1) {
    return {
            hd: x1,
            tl: {
              hd: x2,
              tl: l2
            }
          };
  }
  var match$2 = match$1.tl;
  var x3 = match$1.hd;
  if (!match$2) {
    return {
            hd: x1,
            tl: {
              hd: x2,
              tl: {
                hd: x3,
                tl: l2
              }
            }
          };
  }
  var match$3 = match$2.tl;
  var x4 = match$2.hd;
  if (!match$3) {
    return {
            hd: x1,
            tl: {
              hd: x2,
              tl: {
                hd: x3,
                tl: {
                  hd: x4,
                  tl: l2
                }
              }
            }
          };
  }
  var tl = match$3.tl;
  return {
          hd: x1,
          tl: {
            hd: x2,
            tl: {
              hd: x3,
              tl: {
                hd: x4,
                tl: {
                  hd: match$3.hd,
                  tl: Import$negBase.$great(count, max_non_tailcall) ? List1$negBase.rev_append(List1$negBase.rev(tl), l2) : count_append(tl, l2, Import$negBase.$plus(count, 1))
                }
              }
            }
          }
        };
}

function append(l1, l2) {
  return count_append(l1, l2, 0);
}

function tail_map(xs, f) {
  var _bs = /* [] */0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var bs = _bs;
    if (xs$1) {
      var match = xs$1.tl;
      if (match) {
        var match$1 = match.tl;
        if (match$1) {
          var match$2 = match$1.tl;
          if (match$2) {
            var match$3 = match$2.tl;
            if (match$3) {
              var match$4 = match$3.tl;
              if (match$4) {
                var match$5 = match$4.tl;
                if (match$5) {
                  var match$6 = match$5.tl;
                  if (match$6) {
                    var match$7 = match$6.tl;
                    if (match$7) {
                      var y0 = Curry._1(f, xs$1.hd);
                      var y1 = Curry._1(f, match.hd);
                      var y2 = Curry._1(f, match$1.hd);
                      var y3 = Curry._1(f, match$2.hd);
                      var y4 = Curry._1(f, match$3.hd);
                      var y5 = Curry._1(f, match$4.hd);
                      var y6 = Curry._1(f, match$5.hd);
                      var y7 = Curry._1(f, match$6.hd);
                      var y8 = Curry._1(f, match$7.hd);
                      _xs = match$7.tl;
                      _bs = {
                        hd: [
                          y0,
                          y1,
                          y2,
                          y3,
                          y4,
                          y5,
                          y6,
                          y7,
                          y8
                        ],
                        tl: bs
                      };
                      continue ;
                    }
                    
                  }
                  
                }
                
              }
              
            }
            
          }
          
        }
        
      }
      
    }
    var _ys = List1$negBase.nontail_map(xs$1, f);
    var _param = bs;
    while(true) {
      var param = _param;
      var ys = _ys;
      if (!param) {
        return ys;
      }
      var match$8 = param.hd;
      _param = param.tl;
      _ys = {
        hd: match$8[0],
        tl: {
          hd: match$8[1],
          tl: {
            hd: match$8[2],
            tl: {
              hd: match$8[3],
              tl: {
                hd: match$8[4],
                tl: {
                  hd: match$8[5],
                  tl: {
                    hd: match$8[6],
                    tl: {
                      hd: match$8[7],
                      tl: {
                        hd: match$8[8],
                        tl: ys
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      continue ;
    };
  };
}

function count_map(f, l, ctr) {
  if (!l) {
    return /* [] */0;
  }
  var match = l.tl;
  var x1 = l.hd;
  if (match) {
    var match$1 = match.tl;
    var x2 = match.hd;
    if (match$1) {
      var match$2 = match$1.tl;
      var x3 = match$1.hd;
      if (match$2) {
        var match$3 = match$2.tl;
        var x4 = match$2.hd;
        if (match$3) {
          var tl = match$3.tl;
          var f1 = Curry._1(f, x1);
          var f2 = Curry._1(f, x2);
          var f3 = Curry._1(f, x3);
          var f4 = Curry._1(f, x4);
          var f5 = Curry._1(f, match$3.hd);
          return {
                  hd: f1,
                  tl: {
                    hd: f2,
                    tl: {
                      hd: f3,
                      tl: {
                        hd: f4,
                        tl: {
                          hd: f5,
                          tl: Import$negBase.$great(ctr, max_non_tailcall) ? tail_map(tl, f) : count_map(f, tl, Import$negBase.$plus(ctr, 1))
                        }
                      }
                    }
                  }
                };
        }
        var f1$1 = Curry._1(f, x1);
        var f2$1 = Curry._1(f, x2);
        var f3$1 = Curry._1(f, x3);
        var f4$1 = Curry._1(f, x4);
        return {
                hd: f1$1,
                tl: {
                  hd: f2$1,
                  tl: {
                    hd: f3$1,
                    tl: {
                      hd: f4$1,
                      tl: /* [] */0
                    }
                  }
                }
              };
      }
      var f1$2 = Curry._1(f, x1);
      var f2$2 = Curry._1(f, x2);
      var f3$2 = Curry._1(f, x3);
      return {
              hd: f1$2,
              tl: {
                hd: f2$2,
                tl: {
                  hd: f3$2,
                  tl: /* [] */0
                }
              }
            };
    }
    var f1$3 = Curry._1(f, x1);
    var f2$3 = Curry._1(f, x2);
    return {
            hd: f1$3,
            tl: {
              hd: f2$3,
              tl: /* [] */0
            }
          };
  }
  var f1$4 = Curry._1(f, x1);
  return {
          hd: f1$4,
          tl: /* [] */0
        };
}

function map(l, f) {
  return count_map(f, l, 0);
}

function folding_map(t, init, f) {
  var acc = {
    contents: init
  };
  return map(t, (function (x) {
                var match = Curry._2(f, acc[0], x);
                acc[0] = match[0];
                return match[1];
              }));
}

function fold_map(t, init, f) {
  var acc = {
    contents: init
  };
  var result = map(t, (function (x) {
          var match = Curry._2(f, acc[0], x);
          acc[0] = match[0];
          return match[1];
        }));
  return [
          acc[0],
          result
        ];
}

var $great$great$pipe = map;

function map2_ok(l1, l2, f) {
  return List1$negBase.rev(List1$negBase.rev_map2_ok(l1, l2, f));
}

function map2(l1, l2, f) {
  return check_length2(l1, l2, (function (param) {
                return function (param$1) {
                  return map2_ok(param, param$1, f);
                };
              }));
}

function map2_exn(l1, l2, f) {
  check_length2_exn("map2_exn", l1, l2);
  return map2_ok(l1, l2, f);
}

function rev_map3_ok(l1, l2, l3, f) {
  var _l1 = l1;
  var _l2 = l2;
  var _l3 = l3;
  var _ac = /* [] */0;
  while(true) {
    var ac = _ac;
    var l3$1 = _l3;
    var l2$1 = _l2;
    var l1$1 = _l1;
    if (l1$1) {
      if (l2$1 && l3$1) {
        _ac = {
          hd: Curry._3(f, l1$1.hd, l2$1.hd, l3$1.hd),
          tl: ac
        };
        _l3 = l3$1.tl;
        _l2 = l2$1.tl;
        _l1 = l1$1.tl;
        continue ;
      }
      
    } else if (!l2$1 && !l3$1) {
      return ac;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "list.ml",
            535,
            11
          ],
          Error: new Error()
        };
  };
}

function rev_map3(l1, l2, l3, f) {
  return check_length3(l1, l2, l3, (function (param) {
                return function (param$1) {
                  return function (param$2) {
                    return rev_map3_ok(param, param$1, param$2, f);
                  };
                };
              }));
}

function rev_map3_exn(l1, l2, l3, f) {
  check_length3_exn("rev_map3_exn", l1, l2, l3);
  return rev_map3_ok(l1, l2, l3, f);
}

function map3_ok(l1, l2, l3, f) {
  return List1$negBase.rev(rev_map3_ok(l1, l2, l3, f));
}

function map3(l1, l2, l3, f) {
  return check_length3(l1, l2, l3, (function (param) {
                return function (param$1) {
                  return function (param$2) {
                    return map3_ok(param, param$1, param$2, f);
                  };
                };
              }));
}

function map3_exn(l1, l2, l3, f) {
  check_length3_exn("map3_exn", l1, l2, l3);
  return map3_ok(l1, l2, l3, f);
}

function rev_map_append(_l1, _l2, f) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: Curry._1(f, l1.hd),
      tl: l2
    };
    _l1 = l1.tl;
    continue ;
  };
}

function fold_right(l, f, init) {
  if (l) {
    return List1$negBase.fold(List1$negBase.rev(l), init, (function (a, b) {
                  return Curry._2(f, b, a);
                }));
  } else {
    return init;
  }
}

function unzip(list) {
  var _list = List1$negBase.rev(list);
  var _l1 = /* [] */0;
  var _l2 = /* [] */0;
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var list$1 = _list;
    if (!list$1) {
      return [
              l1,
              l2
            ];
    }
    var match = list$1.hd;
    _l2 = {
      hd: match[1],
      tl: l2
    };
    _l1 = {
      hd: match[0],
      tl: l1
    };
    _list = list$1.tl;
    continue ;
  };
}

function unzip3(list) {
  var _list = List1$negBase.rev(list);
  var _l1 = /* [] */0;
  var _l2 = /* [] */0;
  var _l3 = /* [] */0;
  while(true) {
    var l3 = _l3;
    var l2 = _l2;
    var l1 = _l1;
    var list$1 = _list;
    if (!list$1) {
      return [
              l1,
              l2,
              l3
            ];
    }
    var match = list$1.hd;
    _l3 = {
      hd: match[2],
      tl: l3
    };
    _l2 = {
      hd: match[1],
      tl: l2
    };
    _l1 = {
      hd: match[0],
      tl: l1
    };
    _list = list$1.tl;
    continue ;
  };
}

function zip_exn(l1, l2) {
  try {
    return map2_ok(l1, l2, (function (a, b) {
                  return [
                          a,
                          b
                        ];
                }));
  }
  catch (exn){
    return Curry._3(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "length mismatch in zip_exn: ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: " <> ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "length mismatch in zip_exn: %d <> %d"
                  }), List1$negBase.length(l1), List1$negBase.length(l2), undefined);
  }
}

function zip(l1, l2) {
  return map2(l1, l2, (function (a, b) {
                return [
                        a,
                        b
                      ];
              }));
}

function rev_mapi(l, f) {
  var _i = 0;
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    var i = _i;
    if (!param) {
      return acc;
    }
    _param = param.tl;
    _acc = {
      hd: Curry._2(f, i, param.hd),
      tl: acc
    };
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function mapi(l, f) {
  return List1$negBase.rev(rev_mapi(l, f));
}

function folding_mapi(t, init, f) {
  var acc = {
    contents: init
  };
  return List1$negBase.rev(rev_mapi(t, (function (i, x) {
                    var match = Curry._3(f, i, acc[0], x);
                    acc[0] = match[0];
                    return match[1];
                  })));
}

function fold_mapi(t, init, f) {
  var acc = {
    contents: init
  };
  var result = List1$negBase.rev(rev_mapi(t, (function (i, x) {
              var match = Curry._3(f, i, acc[0], x);
              acc[0] = match[0];
              return match[1];
            })));
  return [
          acc[0],
          result
        ];
}

function iteri(l, f) {
  List1$negBase.fold(l, 0, (function (i, x) {
          Curry._2(f, i, x);
          return Import$negBase.$plus(i, 1);
        }));
  
}

function foldi(t, init, f) {
  return Import$negBase.snd(List1$negBase.fold(t, [
                  0,
                  init
                ], (function (param, v) {
                    var i = param[0];
                    return [
                            Import$negBase.$plus(i, 1),
                            Curry._3(f, i, param[1], v)
                          ];
                  })));
}

function filteri(l, f) {
  return List1$negBase.rev(foldi(l, /* [] */0, (function (pos, acc, x) {
                    if (Curry._2(f, pos, x)) {
                      return {
                              hd: x,
                              tl: acc
                            };
                    } else {
                      return acc;
                    }
                  })));
}

function reduce(l, f) {
  if (l) {
    return Caml_option.some(List1$negBase.fold(l.tl, l.hd, f));
  }
  
}

function reduce_exn(l, f) {
  var v = reduce(l, f);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  } else {
    return Import$negBase.invalid_arg("List.reduce_exn");
  }
}

function reduce_balanced(l, f) {
  var step_accum = function (_num, _acc, _x) {
    while(true) {
      var x = _x;
      var acc = _acc;
      var num = _num;
      if (Import$negBase.land(num, 1) === 0) {
        return {
                hd: x,
                tl: acc
              };
      }
      if (acc) {
        _x = Curry._2(f, acc.hd, x);
        _acc = acc.tl;
        _num = Import$negBase.asr(num, 1);
        continue ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "list.ml",
              674,
              14
            ],
            Error: new Error()
          };
    };
  };
  var match = foldi(l, /* [] */0, step_accum);
  if (match) {
    return Caml_option.some(List1$negBase.fold(match.tl, match.hd, (function (x, y) {
                      return Curry._2(f, y, x);
                    })));
  }
  
}

function reduce_balanced_exn(l, f) {
  var v = reduce_balanced(l, f);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  } else {
    return Import$negBase.invalid_arg("List.reduce_balanced_exn");
  }
}

function groupi(l, $$break) {
  var groups = foldi(l, /* [] */0, (function (i, acc, x) {
          if (!acc) {
            return {
                    hd: {
                      hd: x,
                      tl: /* [] */0
                    },
                    tl: /* [] */0
                  };
          }
          var tl = acc.tl;
          var current_group = acc.hd;
          if (Curry._3($$break, i, List1$negBase.hd_exn(current_group), x)) {
            return {
                    hd: {
                      hd: x,
                      tl: /* [] */0
                    },
                    tl: {
                      hd: current_group,
                      tl: tl
                    }
                  };
          } else {
            return {
                    hd: {
                      hd: x,
                      tl: current_group
                    },
                    tl: tl
                  };
          }
        }));
  if (groups) {
    return List1$negBase.rev_map(groups, List1$negBase.rev);
  } else {
    return /* [] */0;
  }
}

function group(l, $$break) {
  return groupi(l, (function (param, x, y) {
                return Curry._2($$break, x, y);
              }));
}

function sort_and_group(compare, l) {
  var arg = function (x, y) {
    return Import$negBase.$less$great(Curry._2(compare, x, y), 0);
  };
  return group(List1$negBase.stable_sort(l, compare), arg);
}

function concat_map(l, f) {
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return List1$negBase.rev(acc);
    }
    _param = param.tl;
    _acc = List1$negBase.rev_append(Curry._1(f, param.hd), acc);
    continue ;
  };
}

function concat_mapi(l, f) {
  var _cont = 0;
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    var cont = _cont;
    if (!param) {
      return List1$negBase.rev(acc);
    }
    _param = param.tl;
    _acc = List1$negBase.rev_append(Curry._2(f, cont, param.hd), acc);
    _cont = Import$negBase.$plus(cont, 1);
    continue ;
  };
}

function merge(l1, l2, compare) {
  var _acc = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var acc = _acc;
    if (!l1$1) {
      return List1$negBase.rev_append(acc, l2$1);
    }
    if (!l2$1) {
      return List1$negBase.rev_append(acc, l1$1);
    }
    var h2 = l2$1.hd;
    var h1 = l1$1.hd;
    if (Import$negBase.$less$eq(Curry._2(compare, h1, h2), 0)) {
      _l1 = l1$1.tl;
      _acc = {
        hd: h1,
        tl: acc
      };
      continue ;
    }
    _l2 = l2$1.tl;
    _acc = {
      hd: h2,
      tl: acc
    };
    continue ;
  };
}

var bind = concat_map;

var map$1 = {
  NAME: "Custom",
  VAL: map
};

function $$return(x) {
  return {
          hd: x,
          tl: /* [] */0
        };
}

var Monad = Monad$negBase.Make({
      bind: bind,
      $$return: $$return,
      map: map$1
    });

var bind$1 = Monad.bind;

var $great$great$eq = Curry.__2(bind$1);

function last_exn(_list) {
  while(true) {
    var list = _list;
    if (!list) {
      return Import$negBase.invalid_arg("List.last");
    }
    if (!list.tl) {
      return list.hd;
    }
    _list = list.tl;
    continue ;
  };
}

function last(_list) {
  while(true) {
    var list = _list;
    if (!list) {
      return ;
    }
    if (!list.tl) {
      return Caml_option.some(list.hd);
    }
    _list = list.tl;
    continue ;
  };
}

function is_prefix(_list, _prefix, equal) {
  while(true) {
    var prefix = _prefix;
    var list = _list;
    if (!prefix) {
      return true;
    }
    if (!list) {
      return false;
    }
    if (!Curry._2(equal, prefix.hd, list.hd)) {
      return false;
    }
    _prefix = prefix.tl;
    _list = list.tl;
    continue ;
  };
}

function find_consecutive_duplicate(t, equal) {
  if (!t) {
    return ;
  }
  var _a1 = t.hd;
  var _t = t.tl;
  while(true) {
    var t$1 = _t;
    var a1 = _a1;
    if (!t$1) {
      return ;
    }
    var a2 = t$1.hd;
    if (Curry._2(equal, a1, a2)) {
      return [
              a1,
              a2
            ];
    }
    _t = t$1.tl;
    _a1 = a2;
    continue ;
  };
}

function remove_consecutive_duplicates(which_to_keepOpt, list, equal) {
  var which_to_keep = which_to_keepOpt !== undefined ? which_to_keepOpt : "Last";
  var loop = function (_to_keep, _accum, _param) {
    while(true) {
      var param = _param;
      var accum = _accum;
      var to_keep = _to_keep;
      if (!param) {
        return {
                hd: to_keep,
                tl: accum
              };
      }
      var tl = param.tl;
      var hd = param.hd;
      if (Curry._2(equal, hd, to_keep)) {
        var to_keep$1 = which_to_keep === "Last" ? hd : to_keep;
        _param = tl;
        _to_keep = to_keep$1;
        continue ;
      }
      _param = tl;
      _accum = {
        hd: to_keep,
        tl: accum
      };
      _to_keep = hd;
      continue ;
    };
  };
  if (list) {
    return List1$negBase.rev(loop(list.hd, /* [] */0, list.tl));
  } else {
    return /* [] */0;
  }
}

function dedup_and_sort(compare, list) {
  if (!list) {
    return list;
  }
  if (!list.tl) {
    return list;
  }
  var equal = function (x, x$p) {
    return Curry._2(compare, x, x$p) === 0;
  };
  var sorted = List1$negBase.sort(list, compare);
  return remove_consecutive_duplicates(undefined, sorted, equal);
}

function find_a_dup(compare, l) {
  var sorted = List1$negBase.sort(l, compare);
  var _l = sorted;
  while(true) {
    var l$1 = _l;
    if (!l$1) {
      return ;
    }
    var tl = l$1.tl;
    if (!tl) {
      return ;
    }
    var hd1 = l$1.hd;
    if (Curry._2(compare, hd1, tl.hd) === 0) {
      return Caml_option.some(hd1);
    }
    _l = tl;
    continue ;
  };
}

function contains_dup(compare, lst) {
  return find_a_dup(compare, lst) !== undefined;
}

function find_all_dups(compare, l) {
  var compare$1 = function (a, b) {
    return Import$negBase.$star(-1, Curry._2(compare, a, b));
  };
  var sorted = List1$negBase.sort(l, compare$1);
  if (sorted) {
    var _sorted = sorted.tl;
    var _prev = sorted.hd;
    var _already_recorded = false;
    var _acc = /* [] */0;
    while(true) {
      var acc = _acc;
      var already_recorded = _already_recorded;
      var prev = _prev;
      var sorted$1 = _sorted;
      if (!sorted$1) {
        return acc;
      }
      var tl = sorted$1.tl;
      var hd = sorted$1.hd;
      if (Import$negBase.$less$great(compare$1(prev, hd), 0)) {
        _already_recorded = false;
        _prev = hd;
        _sorted = tl;
        continue ;
      }
      if (already_recorded) {
        _already_recorded = true;
        _prev = hd;
        _sorted = tl;
        continue ;
      }
      _acc = {
        hd: hd,
        tl: acc
      };
      _already_recorded = true;
      _prev = hd;
      _sorted = tl;
      continue ;
    };
  } else {
    return /* [] */0;
  }
}

function count(t, f) {
  return Container$negBase.count(List1$negBase.fold, t, f);
}

function sum(m, t, f) {
  return Container$negBase.sum(List1$negBase.fold, m, t, f);
}

function min_elt(t, compare) {
  return Container$negBase.min_elt(List1$negBase.fold, t, compare);
}

function max_elt(t, compare) {
  return Container$negBase.max_elt(List1$negBase.fold, t, compare);
}

function counti(t, f) {
  return foldi(t, 0, (function (idx, count, a) {
                if (Curry._2(f, idx, a)) {
                  return Import$negBase.$plus(count, 1);
                } else {
                  return count;
                }
              }));
}

function init(n, f) {
  if (Import$negBase.$less(n, 0)) {
    Curry._2(Printf$negBase.invalid_argf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "List.init ",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: /* End_of_format */0
                }
              },
              _1: "List.init %d"
            }), n, undefined);
  }
  var _i = n;
  var _accum = /* [] */0;
  while(true) {
    var accum = _accum;
    var i = _i;
    if (!Import$negBase.$great$eq(i, 0)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "list.ml",
              887,
              4
            ],
            Error: new Error()
          };
    }
    if (i === 0) {
      return accum;
    }
    _accum = {
      hd: Curry._1(f, Import$negBase.$neg(i, 1)),
      tl: accum
    };
    _i = Import$negBase.$neg(i, 1);
    continue ;
  };
}

function rev_filter_map(l, f) {
  var _l = l;
  var _accum = /* [] */0;
  while(true) {
    var accum = _accum;
    var l$1 = _l;
    if (!l$1) {
      return accum;
    }
    var tl = l$1.tl;
    var x = Curry._1(f, l$1.hd);
    if (x !== undefined) {
      _accum = {
        hd: Caml_option.valFromOption(x),
        tl: accum
      };
      _l = tl;
      continue ;
    }
    _l = tl;
    continue ;
  };
}

function filter_map(l, f) {
  return List1$negBase.rev(rev_filter_map(l, f));
}

function rev_filter_mapi(l, f) {
  var _i = 0;
  var _l = l;
  var _accum = /* [] */0;
  while(true) {
    var accum = _accum;
    var l$1 = _l;
    var i = _i;
    if (!l$1) {
      return accum;
    }
    var tl = l$1.tl;
    var x = Curry._2(f, i, l$1.hd);
    if (x !== undefined) {
      _accum = {
        hd: Caml_option.valFromOption(x),
        tl: accum
      };
      _l = tl;
      _i = Import$negBase.$plus(i, 1);
      continue ;
    }
    _l = tl;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function filter_mapi(l, f) {
  return List1$negBase.rev(rev_filter_mapi(l, f));
}

function filter_opt(l) {
  return List1$negBase.rev(rev_filter_map(l, (function (prim) {
                    return prim;
                  })));
}

function partition3_map(t, f) {
  var _t = t;
  var _fst = /* [] */0;
  var _snd = /* [] */0;
  var _trd = /* [] */0;
  while(true) {
    var trd = _trd;
    var snd = _snd;
    var fst = _fst;
    var t$1 = _t;
    if (!t$1) {
      return [
              List1$negBase.rev(fst),
              List1$negBase.rev(snd),
              List1$negBase.rev(trd)
            ];
    }
    var t$2 = t$1.tl;
    var match = Curry._1(f, t$1.hd);
    var variant = match.NAME;
    if (variant === "Snd") {
      _snd = {
        hd: match.VAL,
        tl: snd
      };
      _t = t$2;
      continue ;
    }
    if (variant === "Trd") {
      _trd = {
        hd: match.VAL,
        tl: trd
      };
      _t = t$2;
      continue ;
    }
    _fst = {
      hd: match.VAL,
      tl: fst
    };
    _t = t$2;
    continue ;
  };
}

function partition_tf(t, f) {
  var f$1 = function (x) {
    if (Curry._1(f, x)) {
      return {
              TAG: /* First */0,
              _0: x
            };
    } else {
      return {
              TAG: /* Second */1,
              _0: x
            };
    }
  };
  return List1$negBase.partition_map(t, f$1);
}

function partition_result(t) {
  return List1$negBase.partition_map(t, Result$negBase.to_either);
}

var _tp_loc = "list.ml.Assoc.t";

function t_of_sexp(_of_a, _of_b, t) {
  return Import$negBase.list_of_sexp((function (sexp) {
                if (sexp.TAG === /* Atom */0) {
                  return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
                }
                var match = sexp._0;
                if (!match) {
                  return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
                }
                var match$1 = match.tl;
                if (!match$1) {
                  return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
                }
                if (match$1.tl) {
                  return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
                }
                var v0 = Curry._1(_of_a, match.hd);
                var v1 = Curry._1(_of_b, match$1.hd);
                return [
                        v0,
                        v1
                      ];
              }), t);
}

function sexp_of_t$1(_of_a, _of_b, v) {
  return Import$negBase.sexp_of_list((function (param) {
                var v0 = Curry._1(_of_a, param[0]);
                var v1 = Curry._1(_of_b, param[1]);
                return {
                        TAG: /* List */1,
                        _0: {
                          hd: v0,
                          tl: {
                            hd: v1,
                            tl: /* [] */0
                          }
                        }
                      };
              }), v);
}

function t_sexp_grammar$1(_$pa_sexp_grammar, _$pb_sexp_grammar) {
  return Import$negBase.list_sexp_grammar({
              TAG: /* List */3,
              _0: {
                TAG: /* Cons */0,
                _0: _$pa_sexp_grammar,
                _1: {
                  TAG: /* Cons */0,
                  _0: _$pb_sexp_grammar,
                  _1: /* Empty */0
                }
              }
            });
}

function pair_of_group(list) {
  if (list) {
    return [
            list.hd[0],
            map(list, Import$negBase.snd)
          ];
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "list.ml",
          990,
          12
        ],
        Error: new Error()
      };
}

function group$1(alist, equal) {
  return map(group(alist, (function (param, param$1) {
                    return !Curry._2(equal, param[0], param$1[0]);
                  })), pair_of_group);
}

function sort_and_group$1(alist, compare) {
  return map(sort_and_group((function (param, param$1) {
                    return Curry._2(compare, param[0], param$1[0]);
                  }), alist), pair_of_group);
}

function find$1(t, equal, key) {
  var x = find(t, (function (param) {
          return Curry._2(equal, key, param[0]);
        }));
  if (x !== undefined) {
    return Caml_option.some(Import$negBase.snd(x));
  }
  
}

var not_found_1$3 = {
  TAG: /* Atom */0,
  _0: "List.Assoc.find_exn: not found"
};

var not_found$3 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$3
};

function find_exn$1(t, equal, key) {
  var value = find$1(t, equal, key);
  if (value !== undefined) {
    return Caml_option.valFromOption(value);
  }
  throw not_found$3;
}

function mem$1(t, equal, key) {
  return find$1(t, equal, key) !== undefined;
}

function remove(t, equal, key) {
  return List1$negBase.rev(rev_filter(t, (function (param) {
                    return !Curry._2(equal, key, param[0]);
                  })));
}

function add(t, equal, key, value) {
  return {
          hd: [
            key,
            value
          ],
          tl: remove(t, equal, key)
        };
}

function inverse(t) {
  return map(t, (function (param) {
                return [
                        param[1],
                        param[0]
                      ];
              }));
}

function map$2(t, f) {
  return map(t, (function (param) {
                return [
                        param[0],
                        Curry._1(f, param[1])
                      ];
              }));
}

function sub(l, pos, len) {
  if (Import$negBase.$less(pos, 0) || Import$negBase.$less(len, 0) || Import$negBase.$great(pos, Import$negBase.$neg(List1$negBase.length(l), len))) {
    Import$negBase.invalid_arg("List.sub");
  }
  return List1$negBase.rev(foldi(l, /* [] */0, (function (i, acc, el) {
                    if (Import$negBase.$great$eq(i, pos) && Import$negBase.$less(i, Import$negBase.$plus(pos, len))) {
                      return {
                              hd: el,
                              tl: acc
                            };
                    } else {
                      return acc;
                    }
                  })));
}

function split_n(t_orig, n) {
  if (Import$negBase.$less$eq(n, 0)) {
    return [
            /* [] */0,
            t_orig
          ];
  }
  var _n = n;
  var _t = t_orig;
  var _accum = /* [] */0;
  while(true) {
    var accum = _accum;
    var t = _t;
    var n$1 = _n;
    if (n$1 === 0) {
      return [
              List1$negBase.rev(accum),
              t
            ];
    }
    if (!t) {
      return [
              t_orig,
              /* [] */0
            ];
    }
    _accum = {
      hd: t.hd,
      tl: accum
    };
    _t = t.tl;
    _n = Import$negBase.$neg(n$1, 1);
    continue ;
  };
}

function take(t_orig, n) {
  if (Import$negBase.$less$eq(n, 0)) {
    return /* [] */0;
  }
  var _n = n;
  var _t = t_orig;
  var _accum = /* [] */0;
  while(true) {
    var accum = _accum;
    var t = _t;
    var n$1 = _n;
    if (n$1 === 0) {
      return List1$negBase.rev(accum);
    }
    if (!t) {
      return t_orig;
    }
    _accum = {
      hd: t.hd,
      tl: accum
    };
    _t = t.tl;
    _n = Import$negBase.$neg(n$1, 1);
    continue ;
  };
}

function drop(_t, _n) {
  while(true) {
    var n = _n;
    var t = _t;
    if (!t) {
      return t;
    }
    if (!Import$negBase.$great(n, 0)) {
      return t;
    }
    _n = Import$negBase.$neg(n, 1);
    _t = t.tl;
    continue ;
  };
}

function chunks_of(l, length) {
  if (Import$negBase.$less$eq(length, 0)) {
    Curry._2(Printf$negBase.invalid_argf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "List.chunks_of: Expected length > 0, got ",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: /* End_of_format */0
                }
              },
              _1: "List.chunks_of: Expected length > 0, got %d"
            }), length, undefined);
  }
  var _acc = /* [] */0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (!l$1) {
      return List1$negBase.rev(acc);
    }
    var match = split_n(l$1, length);
    _l = match[1];
    _acc = {
      hd: match[0],
      tl: acc
    };
    continue ;
  };
}

function split_while(xs, f) {
  var _acc = /* [] */0;
  var _t = xs;
  while(true) {
    var t = _t;
    var acc = _acc;
    if (!t) {
      return [
              List1$negBase.rev(acc),
              t
            ];
    }
    var hd = t.hd;
    if (!Curry._1(f, hd)) {
      return [
              List1$negBase.rev(acc),
              t
            ];
    }
    _t = t.tl;
    _acc = {
      hd: hd,
      tl: acc
    };
    continue ;
  };
}

function take_while(xs, f) {
  var _acc = /* [] */0;
  var _param = xs;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return List1$negBase.rev(acc);
    }
    var hd = param.hd;
    if (!Curry._1(f, hd)) {
      return List1$negBase.rev(acc);
    }
    _param = param.tl;
    _acc = {
      hd: hd,
      tl: acc
    };
    continue ;
  };
}

function drop_while(_t, f) {
  while(true) {
    var t = _t;
    if (!t) {
      return t;
    }
    if (!Curry._1(f, t.hd)) {
      return t;
    }
    _t = t.tl;
    continue ;
  };
}

function drop_last(t) {
  var match = List1$negBase.rev(t);
  if (match) {
    return List1$negBase.rev(match.tl);
  }
  
}

function drop_last_exn(t) {
  var lst = drop_last(t);
  if (lst !== undefined) {
    return lst;
  } else {
    return Import$negBase.failwith("List.drop_last_exn: empty list");
  }
}

function cartesian_product(list1, list2) {
  if (List1$negBase.is_empty(list2)) {
    return /* [] */0;
  }
  var loop = function (_l1, l2, _accum) {
    while(true) {
      var accum = _accum;
      var l1 = _l1;
      if (!l1) {
        return accum;
      }
      var hd = l1.hd;
      _accum = List1$negBase.rev_append(map(l2, (function(hd){
              return function (x) {
                return [
                        hd,
                        x
                      ];
              }
              }(hd))), accum);
      _l1 = l1.tl;
      continue ;
    };
  };
  return List1$negBase.rev(loop(list1, list2, /* [] */0));
}

function concat(l) {
  return fold_right(l, append, /* [] */0);
}

function concat_no_order(l) {
  return List1$negBase.fold(l, /* [] */0, (function (acc, l) {
                return List1$negBase.rev_append(l, acc);
              }));
}

function cons(x, l) {
  return {
          hd: x,
          tl: l
        };
}

function is_sorted(l, compare) {
  var _l = l;
  while(true) {
    var l$1 = _l;
    if (!l$1) {
      return true;
    }
    var rest = l$1.tl;
    if (!rest) {
      return true;
    }
    if (!Import$negBase.$less$eq(Curry._2(compare, l$1.hd, rest.hd), 0)) {
      return false;
    }
    _l = rest;
    continue ;
  };
}

function is_sorted_strictly(l, compare) {
  var _l = l;
  while(true) {
    var l$1 = _l;
    if (!l$1) {
      return true;
    }
    var rest = l$1.tl;
    if (!rest) {
      return true;
    }
    if (!Import$negBase.$less(Curry._2(compare, l$1.hd, rest.hd), 0)) {
      return false;
    }
    _l = rest;
    continue ;
  };
}

var Infix = {
  $at: append
};

function permute(random_stateOpt, list) {
  var random_state = random_stateOpt !== undefined ? Caml_option.valFromOption(random_stateOpt) : Random$negBase.State.$$default;
  if (!list) {
    return list;
  }
  var match = list.tl;
  if (!match) {
    return list;
  }
  if (!match.tl) {
    if (Random$negBase.State.bool(random_state)) {
      return {
              hd: match.hd,
              tl: {
                hd: list.hd,
                tl: /* [] */0
              }
            };
    } else {
      return list;
    }
  }
  var arr = Array0$negBase.of_list(list);
  Array_permute$negBase.permute(Caml_option.some(random_state), undefined, undefined, arr);
  return Array0$negBase.to_list(arr);
}

function random_element_exn(random_stateOpt, list) {
  var random_state = random_stateOpt !== undefined ? Caml_option.valFromOption(random_stateOpt) : Random$negBase.State.$$default;
  if (List1$negBase.is_empty(list)) {
    return Import$negBase.failwith("List.random_element_exn: empty list");
  } else {
    return nth_exn(list, Curry._2(Random$negBase.State.$$int, random_state, List1$negBase.length(list)));
  }
}

function random_element(random_stateOpt, list) {
  var random_state = random_stateOpt !== undefined ? Caml_option.valFromOption(random_stateOpt) : Random$negBase.State.$$default;
  try {
    return Caml_option.some(random_element_exn(Caml_option.some(random_state), list));
  }
  catch (exn){
    return ;
  }
}

function compare$1(cmp, _a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (!a) {
      if (b) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!b) {
      return 1;
    }
    var n = Curry._2(cmp, a.hd, b.hd);
    if (n !== 0) {
      return n;
    }
    _b = b.tl;
    _a = a.tl;
    continue ;
  };
}

function equal(equal$1, t1, t2) {
  var _t1 = t1;
  var _t2 = t2;
  while(true) {
    var t2$1 = _t2;
    var t1$1 = _t1;
    if (!t1$1) {
      if (t2$1) {
        return false;
      } else {
        return true;
      }
    }
    if (!t2$1) {
      return false;
    }
    if (!Curry._2(equal$1, t1$1.hd, t2$1.hd)) {
      return false;
    }
    _t2 = t2$1.tl;
    _t1 = t1$1.tl;
    continue ;
  };
}

function split_off_first_column(rows) {
  var _t = rows;
  var _column_acc = /* [] */0;
  var _trimmed = /* [] */0;
  var _found_empty = false;
  while(true) {
    var found_empty = _found_empty;
    var trimmed = _trimmed;
    var column_acc = _column_acc;
    var t = _t;
    if (!t) {
      return [
              column_acc,
              trimmed,
              found_empty
            ];
    }
    var match = t.hd;
    if (match) {
      _trimmed = {
        hd: match.tl,
        tl: trimmed
      };
      _column_acc = {
        hd: match.hd,
        tl: column_acc
      };
      _t = t.tl;
      continue ;
    }
    _found_empty = true;
    _t = t.tl;
    continue ;
  };
}

function transpose(t) {
  var _rows = t;
  var _columns = /* [] */0;
  var _do_rev = true;
  while(true) {
    var do_rev = _do_rev;
    var columns = _columns;
    var rows = _rows;
    var match = split_off_first_column(rows);
    var column = match[0];
    if (!column && !match[1]) {
      return List1$negBase.rev(columns);
    }
    if (match[2]) {
      return ;
    }
    var column$1 = do_rev ? List1$negBase.rev(column) : column;
    _do_rev = !do_rev;
    _columns = {
      hd: column$1,
      tl: columns
    };
    _rows = match[1];
    continue ;
  };
}

var Transpose_got_lists_of_different_lengths = /* @__PURE__ */Caml_exceptions.create("List-Base.Transpose_got_lists_of_different_lengths");

Sexp_conv$negSexplib0.Exn_converter.add(undefined, undefined, Transpose_got_lists_of_different_lengths, (function (v0) {
        if (v0.RE_EXN_ID === Transpose_got_lists_of_different_lengths) {
          var v0$1 = Import$negBase.sexp_of_list(Import$negBase.sexp_of_int, v0._1);
          return {
                  TAG: /* List */1,
                  _0: {
                    hd: {
                      TAG: /* Atom */0,
                      _0: "list.ml.Transpose_got_lists_of_different_lengths"
                    },
                    tl: {
                      hd: v0$1,
                      tl: /* [] */0
                    }
                  }
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "list.ml",
                1246,
                13
              ],
              Error: new Error()
            };
      }));

function transpose_exn(l) {
  var l$1 = transpose(l);
  if (l$1 !== undefined) {
    return l$1;
  }
  throw {
        RE_EXN_ID: Transpose_got_lists_of_different_lengths,
        _1: map(l, List1$negBase.length),
        Error: new Error()
      };
}

function intersperse(t, sep) {
  if (t) {
    return {
            hd: t.hd,
            tl: fold_right(t.tl, (function (y, acc) {
                    return {
                            hd: sep,
                            tl: {
                              hd: y,
                              tl: acc
                            }
                          };
                  }), /* [] */0)
          };
  } else {
    return /* [] */0;
  }
}

function fold_result(t, init, f) {
  return Container$negBase.fold_result(List1$negBase.fold, init, f, t);
}

function fold_until(t, init, f) {
  return function (param) {
    return Container$negBase.fold_until(List1$negBase.fold, init, f, param, t);
  };
}

function is_suffix(list, suffix, equal_elt) {
  var list_len = List1$negBase.length(list);
  var suffix_len = List1$negBase.length(suffix);
  if (Import$negBase.$great$eq(list_len, suffix_len)) {
    return equal(equal_elt, drop(list, Import$negBase.$neg(list_len, suffix_len)), suffix);
  } else {
    return false;
  }
}

var hash_fold_t = Import$negBase.hash_fold_list;

var t_of_sexp$1 = Import$negBase.list_of_sexp;

var sexp_of_t$2 = Import$negBase.sexp_of_list;

var length = List1$negBase.length;

var is_empty = List1$negBase.is_empty;

var iter = List1$negBase.iter;

var fold = List1$negBase.fold;

var exists = List1$negBase.exists;

var for_all = List1$negBase.for_all;

var to_array = Array0$negBase.of_list;

var Monad_infix = Monad.Monad_infix;

var $$return$1 = Monad.$$return;

var join = Monad.join;

var ignore_m = Monad.ignore_m;

var all = Monad.all;

var all_unit = Monad.all_unit;

var Let_syntax = Monad.Let_syntax;

var rev = List1$negBase.rev;

var rev_append = List1$negBase.rev_append;

var rev_map = List1$negBase.rev_map;

var partition_map = List1$negBase.partition_map;

var sort = List1$negBase.sort;

var stable_sort = List1$negBase.stable_sort;

var hd_exn = List1$negBase.hd_exn;

var tl_exn = List1$negBase.tl_exn;

var fold_left = List1$negBase.fold;

var Assoc = {
  t_of_sexp: t_of_sexp,
  sexp_of_t: sexp_of_t$1,
  t_sexp_grammar: t_sexp_grammar$1,
  add: add,
  find: find$1,
  find_exn: find_exn$1,
  mem: mem$1,
  remove: remove,
  map: map$2,
  inverse: inverse,
  group: group$1,
  sort_and_group: sort_and_group$1
};

exports.compare = compare$1;
exports.hash_fold_t = hash_fold_t;
exports.t_of_sexp = t_of_sexp$1;
exports.sexp_of_t = sexp_of_t$2;
exports.t_sexp_grammar = t_sexp_grammar;
exports.mem = mem;
exports.length = length;
exports.is_empty = is_empty;
exports.iter = iter;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.invariant = invariant;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.Monad_infix = Monad_infix;
exports.bind = bind$1;
exports.$$return = $$return$1;
exports.join = join;
exports.ignore_m = ignore_m;
exports.all = all;
exports.all_unit = all_unit;
exports.Let_syntax = Let_syntax;
exports.Or_unequal_lengths = Or_unequal_lengths;
exports.of_list = of_list;
exports.nth = nth;
exports.nth_exn = nth_exn;
exports.rev = rev;
exports.rev_append = rev_append;
exports.unordered_append = unordered_append;
exports.rev_map = rev_map;
exports.iter2_exn = iter2_exn;
exports.iter2 = iter2;
exports.rev_map2_exn = rev_map2_exn;
exports.rev_map2 = rev_map2;
exports.fold2_exn = fold2_exn;
exports.fold2 = fold2;
exports.for_alli = for_alli;
exports.for_all2_exn = for_all2_exn;
exports.for_all2 = for_all2;
exports.existsi = existsi;
exports.exists2_exn = exists2_exn;
exports.exists2 = exists2;
exports.filter = filter;
exports.rev_filter = rev_filter;
exports.filteri = filteri;
exports.partition_map = partition_map;
exports.partition3_map = partition3_map;
exports.partition_tf = partition_tf;
exports.partition_result = partition_result;
exports.split_n = split_n;
exports.sort = sort;
exports.stable_sort = stable_sort;
exports.merge = merge;
exports.hd = hd;
exports.tl = tl;
exports.hd_exn = hd_exn;
exports.tl_exn = tl_exn;
exports.findi = findi;
exports.find_exn = find_exn;
exports.find_map_exn = find_map_exn;
exports.find_mapi = find_mapi;
exports.find_mapi_exn = find_mapi_exn;
exports.append = append;
exports.map = map;
exports.folding_map = folding_map;
exports.folding_mapi = folding_mapi;
exports.fold_map = fold_map;
exports.fold_mapi = fold_mapi;
exports.concat_map = concat_map;
exports.concat_mapi = concat_mapi;
exports.map2_exn = map2_exn;
exports.map2 = map2;
exports.rev_map3_exn = rev_map3_exn;
exports.rev_map3 = rev_map3;
exports.map3_exn = map3_exn;
exports.map3 = map3;
exports.rev_map_append = rev_map_append;
exports.fold_right = fold_right;
exports.fold_left = fold_left;
exports.unzip = unzip;
exports.unzip3 = unzip3;
exports.zip = zip;
exports.zip_exn = zip_exn;
exports.mapi = mapi;
exports.rev_mapi = rev_mapi;
exports.iteri = iteri;
exports.foldi = foldi;
exports.reduce_exn = reduce_exn;
exports.reduce = reduce;
exports.reduce_balanced = reduce_balanced;
exports.reduce_balanced_exn = reduce_balanced_exn;
exports.group = group;
exports.groupi = groupi;
exports.sort_and_group = sort_and_group;
exports.chunks_of = chunks_of;
exports.last = last;
exports.last_exn = last_exn;
exports.is_prefix = is_prefix;
exports.is_suffix = is_suffix;
exports.find_consecutive_duplicate = find_consecutive_duplicate;
exports.remove_consecutive_duplicates = remove_consecutive_duplicates;
exports.dedup_and_sort = dedup_and_sort;
exports.find_a_dup = find_a_dup;
exports.contains_dup = contains_dup;
exports.find_all_dups = find_all_dups;
exports.count = count;
exports.counti = counti;
exports.range = range;
exports.range$p = range$p;
exports.init = init;
exports.rev_filter_map = rev_filter_map;
exports.rev_filter_mapi = rev_filter_mapi;
exports.filter_map = filter_map;
exports.filter_mapi = filter_mapi;
exports.filter_opt = filter_opt;
exports.Assoc = Assoc;
exports.sub = sub;
exports.take = take;
exports.drop = drop;
exports.take_while = take_while;
exports.drop_while = drop_while;
exports.split_while = split_while;
exports.drop_last = drop_last;
exports.drop_last_exn = drop_last_exn;
exports.concat = concat;
exports.concat_no_order = concat_no_order;
exports.cons = cons;
exports.cartesian_product = cartesian_product;
exports.permute = permute;
exports.random_element = random_element;
exports.random_element_exn = random_element_exn;
exports.is_sorted = is_sorted;
exports.is_sorted_strictly = is_sorted_strictly;
exports.equal = equal;
exports.Infix = Infix;
exports.transpose = transpose;
exports.transpose_exn = transpose_exn;
exports.intersperse = intersperse;
/* Monad Not a pure module */
