// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Hash$negBase = require("./hash.bs.js");
var Poly0$negBase = require("./poly0.bs.js");
var Import$negBase = require("./import.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

var _tp_loc = "sign0.ml.t";

function t_of_sexp(sexp) {
  if (sexp.TAG === /* Atom */0) {
    switch (sexp._0) {
      case "Neg" :
      case "neg" :
          return /* Neg */0;
      case "Pos" :
      case "pos" :
          return /* Pos */2;
      case "Zero" :
      case "zero" :
          return /* Zero */1;
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  } else {
    var match = sexp._0;
    if (!match) {
      return Sexp_conv_error$negSexplib0.empty_list_invalid_sum(_tp_loc, sexp);
    }
    var match$1 = match.hd;
    if (match$1.TAG !== /* Atom */0) {
      return Sexp_conv_error$negSexplib0.nested_list_invalid_sum(_tp_loc, sexp);
    }
    switch (match$1._0) {
      case "Neg" :
      case "Pos" :
      case "Zero" :
      case "neg" :
      case "pos" :
      case "zero" :
          return Sexp_conv_error$negSexplib0.stag_no_args(_tp_loc, sexp);
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  }
}

function sexp_of_t(param) {
  switch (param) {
    case /* Neg */0 :
        return {
                TAG: /* Atom */0,
                _0: "Neg"
              };
    case /* Zero */1 :
        return {
                TAG: /* Atom */0,
                _0: "Zero"
              };
    case /* Pos */2 :
        return {
                TAG: /* Atom */0,
                _0: "Pos"
              };
    
  }
}

var compare = Caml.caml_int_compare;

function hash_fold_t(hsv, arg) {
  switch (arg) {
    case /* Neg */0 :
        return Hash$negBase.fold_int(hsv, 0);
    case /* Zero */1 :
        return Hash$negBase.fold_int(hsv, 1);
    case /* Pos */2 :
        return Hash$negBase.fold_int(hsv, 2);
    
  }
}

function $less(x, y) {
  return x < y;
}

function $less$eq(x, y) {
  return x <= y;
}

function $less$great(x, y) {
  return x !== y;
}

function $eq(x, y) {
  return x === y;
}

function $great(x, y) {
  return x > y;
}

function $great$eq(x, y) {
  return x >= y;
}

var ascending = Poly0$negBase.ascending;

var descending = Poly0$negBase.descending;

var compare$1 = Caml.caml_int_compare;

function equal(x, y) {
  return x === y;
}

function max(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var Replace_polymorphic_compare = {
  $less: $less,
  $less$eq: $less$eq,
  $less$great: $less$great,
  $eq: $eq,
  $great: $great,
  $great$eq: $great$eq,
  ascending: ascending,
  descending: descending,
  compare: compare$1,
  equal: equal,
  max: max,
  min: min
};

function of_string(s) {
  return t_of_sexp(Import$negBase.sexp_of_string(s));
}

function to_string(t) {
  return Import$negBase.string_of_sexp(sexp_of_t(t));
}

function to_int(param) {
  return param - 1 | 0;
}

function of_int(n) {
  if (Import$negBase.$less(n, 0)) {
    return /* Neg */0;
  } else if (n === 0) {
    return /* Zero */1;
  } else {
    return /* Pos */2;
  }
}

var t_sexp_grammar = {
  TAG: /* Enum */1,
  _0: {
    name_kind: /* Capitalized */1,
    names: {
      hd: "Neg",
      tl: {
        hd: "Zero",
        tl: {
          hd: "Pos",
          tl: /* [] */0
        }
      }
    }
  }
};

var all = {
  hd: /* Neg */0,
  tl: {
    hd: /* Zero */1,
    tl: {
      hd: /* Pos */2,
      tl: /* [] */0
    }
  }
};

var hash = to_int;

var module_name = "Base.Sign";

exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.compare = compare;
exports.hash_fold_t = hash_fold_t;
exports.all = all;
exports.Replace_polymorphic_compare = Replace_polymorphic_compare;
exports.of_string = of_string;
exports.to_string = to_string;
exports.to_int = to_int;
exports.hash = hash;
exports.module_name = module_name;
exports.of_int = of_int;
/* Hash-Base Not a pure module */
