// Generated by Melange
'use strict';

var Lazy = require("bs-platform/lib/js/lazy.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hash$negBase = require("./hash.bs.js");
var Monad$negBase = require("./monad.bs.js");
var Import$negBase = require("./import.bs.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");

var t_sexp_grammar = Import$negBase.lazy_t_sexp_grammar;

function map(t, f) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return Curry._1(f, CamlinternalLazy.force(t));
            })
        };
}

function compare(compare_a, t1, t2) {
  if (Import$negBase.phys_equal(t1, t2)) {
    return 0;
  } else {
    return Curry._2(compare_a, CamlinternalLazy.force(t1), CamlinternalLazy.force(t2));
  }
}

var hash_fold_t = Hash$negBase.Builtin.hash_fold_lazy_t;

var $$return = Lazy.from_val;

function bind(t, f) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return CamlinternalLazy.force(Curry._1(f, CamlinternalLazy.force(t)));
            })
        };
}

var map$1 = {
  NAME: "Custom",
  VAL: map
};

var include = Monad$negBase.Make({
      bind: bind,
      $$return: $$return,
      map: map$1
    });

function sexp_of_t(sexp_of_a, t) {
  if (Lazy.is_val(t)) {
    return Curry._1(sexp_of_a, CamlinternalLazy.force(t));
  } else {
    return Import$negBase.sexp_of_string("<unforced lazy>");
  }
}

var T_unforcing = {
  sexp_of_t: sexp_of_t
};

var t_of_sexp = Import$negBase.lazy_t_of_sexp;

var sexp_of_t$1 = Import$negBase.sexp_of_lazy_t;

var $great$great$eq = include.$great$great$eq;

var $great$great$pipe = include.$great$great$pipe;

var Monad_infix = include.Monad_infix;

var bind$1 = include.bind;

var $$return$1 = include.$$return;

var map$2 = include.map;

var join = include.join;

var ignore_m = include.ignore_m;

var all = include.all;

var all_unit = include.all_unit;

var Let_syntax = include.Let_syntax;

var Undefined = Lazy.Undefined;

var force_val = Lazy.force_val;

var from_fun = Lazy.from_fun;

var from_val = Lazy.from_val;

var is_val = Lazy.is_val;

exports.compare = compare;
exports.hash_fold_t = hash_fold_t;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t$1;
exports.t_sexp_grammar = t_sexp_grammar;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.Monad_infix = Monad_infix;
exports.bind = bind$1;
exports.$$return = $$return$1;
exports.map = map$2;
exports.join = join;
exports.ignore_m = ignore_m;
exports.all = all;
exports.all_unit = all_unit;
exports.Let_syntax = Let_syntax;
exports.Undefined = Undefined;
exports.force_val = force_val;
exports.from_fun = from_fun;
exports.from_val = from_val;
exports.is_val = is_val;
exports.T_unforcing = T_unforcing;
/* include Not a pure module */
