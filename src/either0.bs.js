// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Hash$negBase = require("./hash.bs.js");
var Ppx_compare_lib$negBase = require("./ppx_compare_lib.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

function compare(_cmp__f, _cmp__s, a__001_, b__002_) {
  if (Ppx_compare_lib$negBase.phys_equal(a__001_, b__002_)) {
    return 0;
  } else if (a__001_.TAG === /* First */0) {
    if (b__002_.TAG === /* First */0) {
      return Curry._2(_cmp__f, a__001_._0, b__002_._0);
    } else {
      return -1;
    }
  } else if (b__002_.TAG === /* First */0) {
    return 1;
  } else {
    return Curry._2(_cmp__s, a__001_._0, b__002_._0);
  }
}

function hash_fold_t(_hash_fold_f, _hash_fold_s, hsv, arg) {
  if (arg.TAG === /* First */0) {
    var hsv$1 = Hash$negBase.fold_int(hsv, 0);
    return Curry._2(_hash_fold_f, hsv$1, arg._0);
  }
  var hsv$2 = Hash$negBase.fold_int(hsv, 1);
  return Curry._2(_hash_fold_s, hsv$2, arg._0);
}

var _tp_loc = "either0.ml.t";

function t_of_sexp(_of_f, _of_s, _sexp) {
  if (_sexp.TAG === /* Atom */0) {
    switch (_sexp._0) {
      case "First" :
      case "Second" :
      case "first" :
      case "second" :
          return Sexp_conv_error$negSexplib0.stag_takes_args(_tp_loc, _sexp);
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, _sexp);
    }
  } else {
    var match = _sexp._0;
    if (!match) {
      return Sexp_conv_error$negSexplib0.empty_list_invalid_sum(_tp_loc, _sexp);
    }
    var _tag = match.hd;
    if (_tag.TAG !== /* Atom */0) {
      return Sexp_conv_error$negSexplib0.nested_list_invalid_sum(_tp_loc, _sexp);
    }
    var _tag$1 = _tag._0;
    var exit = 0;
    switch (_tag$1) {
      case "First" :
      case "first" :
          exit = 1;
          break;
      case "Second" :
      case "second" :
          exit = 2;
          break;
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, _sexp);
    }
    switch (exit) {
      case 1 :
          var sexp_args = match.tl;
          if (!sexp_args) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          if (sexp_args.tl) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var v0 = Curry._1(_of_f, sexp_args.hd);
          return {
                  TAG: /* First */0,
                  _0: v0
                };
      case 2 :
          var sexp_args$1 = match.tl;
          if (!sexp_args$1) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          if (sexp_args$1.tl) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var v0$1 = Curry._1(_of_s, sexp_args$1.hd);
          return {
                  TAG: /* Second */1,
                  _0: v0$1
                };
      
    }
  }
}

function sexp_of_t(_of_f, _of_s, v0) {
  if (v0.TAG === /* First */0) {
    var v0$1 = Curry._1(_of_f, v0._0);
    return {
            TAG: /* List */1,
            _0: {
              hd: {
                TAG: /* Atom */0,
                _0: "First"
              },
              tl: {
                hd: v0$1,
                tl: /* [] */0
              }
            }
          };
  }
  var v0$2 = Curry._1(_of_s, v0._0);
  return {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* Atom */0,
              _0: "Second"
            },
            tl: {
              hd: v0$2,
              tl: /* [] */0
            }
          }
        };
}

function t_sexp_grammar(_$pf_sexp_grammar, _$ps_sexp_grammar) {
  return {
          TAG: /* Variant */4,
          _0: {
            name_kind: /* Capitalized */1,
            clauses: {
              hd: {
                name: "First",
                args: {
                  TAG: /* Cons */0,
                  _0: _$pf_sexp_grammar,
                  _1: /* Empty */0
                }
              },
              tl: {
                hd: {
                  name: "Second",
                  args: {
                    TAG: /* Cons */0,
                    _0: _$ps_sexp_grammar,
                    _1: /* Empty */0
                  }
                },
                tl: /* [] */0
              }
            }
          }
        };
}

exports.compare = compare;
exports.hash_fold_t = hash_fold_t;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
/* Hash-Base Not a pure module */
