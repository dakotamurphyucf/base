// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Hash$negBase = require("./hash.bs.js");
var Import$negBase = require("./import.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

var compare = Caml.caml_int_compare;

function hash_fold_t(hsv, arg) {
  switch (arg) {
    case /* Less */0 :
        return Hash$negBase.fold_int(hsv, 0);
    case /* Equal */1 :
        return Hash$negBase.fold_int(hsv, 1);
    case /* Greater */2 :
        return Hash$negBase.fold_int(hsv, 2);
    
  }
}

function hash(x) {
  var hsv = Hash$negBase.create(undefined, undefined);
  return Hash$negBase.get_hash_value(hash_fold_t(hsv, x));
}

var _tp_loc = "ordering.ml.t";

function t_of_sexp(sexp) {
  if (sexp.TAG === /* Atom */0) {
    switch (sexp._0) {
      case "Equal" :
      case "equal" :
          return /* Equal */1;
      case "Greater" :
      case "greater" :
          return /* Greater */2;
      case "Less" :
      case "less" :
          return /* Less */0;
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  } else {
    var match = sexp._0;
    if (!match) {
      return Sexp_conv_error$negSexplib0.empty_list_invalid_sum(_tp_loc, sexp);
    }
    var match$1 = match.hd;
    if (match$1.TAG !== /* Atom */0) {
      return Sexp_conv_error$negSexplib0.nested_list_invalid_sum(_tp_loc, sexp);
    }
    switch (match$1._0) {
      case "Equal" :
      case "Greater" :
      case "Less" :
      case "equal" :
      case "greater" :
      case "less" :
          return Sexp_conv_error$negSexplib0.stag_no_args(_tp_loc, sexp);
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  }
}

function sexp_of_t(param) {
  switch (param) {
    case /* Less */0 :
        return {
                TAG: /* Atom */0,
                _0: "Less"
              };
    case /* Equal */1 :
        return {
                TAG: /* Atom */0,
                _0: "Equal"
              };
    case /* Greater */2 :
        return {
                TAG: /* Atom */0,
                _0: "Greater"
              };
    
  }
}

function equal(a, b) {
  return a === b;
}

var Export = {};

function of_int(n) {
  if (Import$negBase.$less(n, 0)) {
    return /* Less */0;
  } else if (n === 0) {
    return /* Equal */1;
  } else {
    return /* Greater */2;
  }
}

function to_int(param) {
  return param - 1 | 0;
}

var all = {
  hd: /* Less */0,
  tl: {
    hd: /* Equal */1,
    tl: {
      hd: /* Greater */2,
      tl: /* [] */0
    }
  }
};

var t_sexp_grammar = {
  TAG: /* Enum */1,
  _0: {
    name_kind: /* Capitalized */1,
    names: {
      hd: "Less",
      tl: {
        hd: "Equal",
        tl: {
          hd: "Greater",
          tl: /* [] */0
        }
      }
    }
  }
};

exports.compare = compare;
exports.all = all;
exports.hash_fold_t = hash_fold_t;
exports.hash = hash;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.equal = equal;
exports.of_int = of_int;
exports.to_int = to_int;
exports.Export = Export;
/* Hash-Base Not a pure module */
