// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Char$negBase = require("./char.bs.js");
var Hash$negBase = require("./hash.bs.js");
var List$negBase = require("./list.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Error$negBase = require("./error.bs.js");
var Array0$negBase = require("./array0.bs.js");
var Bytes0$negBase = require("./bytes0.bs.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Staged$negBase = require("./staged.bs.js");
var String0$negBase = require("./string0.bs.js");
var Bytes_tr$negBase = require("./bytes_tr.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Container$negBase = require("./container.bs.js");
var Comparable$negBase = require("./comparable.bs.js");
var Comparator$negBase = require("./comparator.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Ppx_compare_lib$negBase = require("./ppx_compare_lib.bs.js");
var Indexed_container$negBase = require("./indexed_container.bs.js");
var Ordered_collection_common$negBase = require("./ordered_collection_common.bs.js");

var hash = Import$negBase.hash_string;

var hashable = {
  hash: hash,
  compare: String0$negBase.compare,
  sexp_of_t: Import$negBase.sexp_of_string
};

var include = Comparator$negBase.Make({
      compare: String0$negBase.compare,
      sexp_of_t: Import$negBase.sexp_of_string
    });

function invariant(param) {
  
}

function sub(src, pos, len) {
  if (pos === 0 && len === src.length) {
    return src;
  }
  Ordered_collection_common$negBase.check_pos_len_exn(pos, len, src.length);
  if (len === 0) {
    return "";
  }
  var dst = Bytes0$negBase.create(len);
  Caml_bytes.caml_blit_string(src, pos, dst, 0, len);
  return Bytes0$negBase.unsafe_to_string(dst);
}

function subo(posOpt, len, src) {
  var pos = posOpt !== undefined ? posOpt : 0;
  return sub(src, pos, len !== undefined ? len : Import$negBase.$neg(src.length, pos));
}

function contains(posOpt, len, t, $$char) {
  var pos = posOpt !== undefined ? posOpt : 0;
  var total_length = t.length;
  var len$1 = Option$negBase.value(len, Import$negBase.$neg(total_length, pos));
  Ordered_collection_common$negBase.check_pos_len_exn(pos, len$1, total_length);
  var _pos = pos;
  var end_ = Import$negBase.$plus(pos, len$1);
  while(true) {
    var pos$1 = _pos;
    if (!Import$negBase.$less(pos$1, end_)) {
      return false;
    }
    if (Curry._2(Char$negBase.equal, t.charCodeAt(pos$1), $$char)) {
      return true;
    }
    _pos = Import$negBase.$plus(pos$1, 1);
    continue ;
  };
}

function is_empty(t) {
  return t.length === 0;
}

function index_from_exn_internal(string, _pos, len, not_found, $$char) {
  while(true) {
    var pos = _pos;
    if (Import$negBase.$great$eq(pos, len)) {
      throw not_found;
    }
    if (Curry._2(Char$negBase.equal, string.charCodeAt(pos), $$char)) {
      return pos;
    }
    _pos = Import$negBase.$plus(pos, 1);
    continue ;
  };
}

function index_exn_internal(t, not_found, $$char) {
  return index_from_exn_internal(t, 0, t.length, not_found, $$char);
}

var not_found_1 = {
  TAG: /* Atom */0,
  _0: "String.index_exn: not found"
};

var not_found = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1
};

function index_exn(t, $$char) {
  return index_exn_internal(t, not_found, $$char);
}

var not_found_1$1 = {
  TAG: /* Atom */0,
  _0: "String.index_from_exn: not found"
};

var not_found$1 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$1
};

function index_from_exn(t, pos, $$char) {
  var len = t.length;
  if (Import$negBase.$less(pos, 0) || Import$negBase.$great(pos, len)) {
    return Import$negBase.invalid_arg("String.index_from_exn");
  } else {
    return index_from_exn_internal(t, pos, len, not_found$1, $$char);
  }
}

function rindex_from_exn_internal(string, _pos, len, not_found, $$char) {
  while(true) {
    var pos = _pos;
    if (Import$negBase.$less(pos, 0)) {
      throw not_found;
    }
    if (Curry._2(Char$negBase.equal, string.charCodeAt(pos), $$char)) {
      return pos;
    }
    _pos = Import$negBase.$neg(pos, 1);
    continue ;
  };
}

function rindex_exn_internal(t, not_found, $$char) {
  var len = t.length;
  return rindex_from_exn_internal(t, Import$negBase.$neg(len, 1), len, not_found, $$char);
}

var not_found_1$2 = {
  TAG: /* Atom */0,
  _0: "String.rindex_exn: not found"
};

var not_found$2 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$2
};

function rindex_exn(t, $$char) {
  return rindex_exn_internal(t, not_found$2, $$char);
}

var not_found_1$3 = {
  TAG: /* Atom */0,
  _0: "String.rindex_from_exn: not found"
};

var not_found$3 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$3
};

function rindex_from_exn(t, pos, $$char) {
  var len = t.length;
  if (Import$negBase.$less(pos, -1) || Import$negBase.$great$eq(pos, len)) {
    return Import$negBase.invalid_arg("String.rindex_from_exn");
  } else {
    return rindex_from_exn_internal(t, pos, len, not_found$3, $$char);
  }
}

function index(t, $$char) {
  try {
    return index_exn(t, $$char);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Import$negBase.Not_found_s) {
      return ;
    }
    if (exn.RE_EXN_ID === Import$negBase.Caml.Not_found) {
      return ;
    }
    throw exn;
  }
}

function rindex(t, $$char) {
  try {
    return rindex_exn(t, $$char);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Import$negBase.Not_found_s) {
      return ;
    }
    if (exn.RE_EXN_ID === Import$negBase.Caml.Not_found) {
      return ;
    }
    throw exn;
  }
}

function index_from(t, pos, $$char) {
  try {
    return index_from_exn(t, pos, $$char);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Import$negBase.Not_found_s) {
      return ;
    }
    if (exn.RE_EXN_ID === Import$negBase.Caml.Not_found) {
      return ;
    }
    throw exn;
  }
}

function rindex_from(t, pos, $$char) {
  try {
    return rindex_from_exn(t, pos, $$char);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Import$negBase.Not_found_s) {
      return ;
    }
    if (exn.RE_EXN_ID === Import$negBase.Caml.Not_found) {
      return ;
    }
    throw exn;
  }
}

function sexp_of_t(param) {
  return {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* List */1,
              _0: {
                hd: {
                  TAG: /* Atom */0,
                  _0: "pattern"
                },
                tl: {
                  hd: Import$negBase.sexp_of_string(param.pattern),
                  tl: /* [] */0
                }
              }
            },
            tl: {
              hd: {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "case_sensitive"
                  },
                  tl: {
                    hd: Import$negBase.sexp_of_bool(param.case_sensitive),
                    tl: /* [] */0
                  }
                }
              },
              tl: /* [] */0
            }
          }
        };
}

function pattern(t) {
  return t.pattern;
}

function case_sensitive(t) {
  return t.case_sensitive;
}

function kmp_internal_loop(matched_chars, next_text_char, pattern, kmp_array, char_equal) {
  var matched_chars$1 = matched_chars;
  while(Import$negBase.$great(matched_chars$1, 0) && !Curry._2(char_equal, next_text_char, pattern.charCodeAt(matched_chars$1))) {
    matched_chars$1 = kmp_array[Import$negBase.$neg(matched_chars$1, 1)];
  };
  if (Curry._2(char_equal, next_text_char, pattern.charCodeAt(matched_chars$1))) {
    matched_chars$1 = Import$negBase.$plus(matched_chars$1, 1);
  }
  return matched_chars$1;
}

function get_char_equal(case_sensitive) {
  if (case_sensitive) {
    return Char$negBase.equal;
  } else {
    return Char$negBase.Caseless.equal;
  }
}

function create(pattern, case_sensitive) {
  var n = pattern.length;
  var kmp_array = Array0$negBase.create(n, -1);
  if (Import$negBase.$great(n, 0)) {
    var char_equal = get_char_equal(case_sensitive);
    kmp_array[0] = 0;
    var matched_chars = 0;
    for(var i = 1 ,i_finish = Import$negBase.$neg(n, 1); i <= i_finish; ++i){
      matched_chars = kmp_internal_loop(matched_chars, pattern.charCodeAt(i), pattern, kmp_array, char_equal);
      kmp_array[i] = matched_chars;
    }
  }
  return {
          pattern: pattern,
          case_sensitive: case_sensitive,
          kmp_array: kmp_array
        };
}

function index_internal($staropt$star, param, text) {
  var kmp_array = param.kmp_array;
  var pattern = param.pattern;
  var pos = $staropt$star !== undefined ? $staropt$star : 0;
  if (Import$negBase.$less(pos, 0) || Import$negBase.$great(pos, Import$negBase.$neg(text.length, pattern.length))) {
    return -1;
  }
  var char_equal = get_char_equal(param.case_sensitive);
  var j = pos;
  var matched_chars = 0;
  var k = pattern.length;
  var n = text.length;
  while(Import$negBase.$less(j, n) && Import$negBase.$less(matched_chars, k)) {
    var next_text_char = text.charCodeAt(j);
    matched_chars = kmp_internal_loop(matched_chars, next_text_char, pattern, kmp_array, char_equal);
    j = Import$negBase.$plus(j, 1);
  };
  if (matched_chars === k) {
    return Import$negBase.$neg(j, k);
  } else {
    return -1;
  }
}

function matches(t, str) {
  return Import$negBase.$great$eq(index_internal(undefined, t, str), 0);
}

function index$1(pos, t, in_) {
  var p = index_internal(pos, t, in_);
  if (Import$negBase.$less(p, 0)) {
    return ;
  } else {
    return p;
  }
}

function index_exn$1(pos, t, in_) {
  var p = index_internal(pos, t, in_);
  if (Import$negBase.$great$eq(p, 0)) {
    return p;
  } else {
    return Error$negBase.raise_s(Sexp$negBase.message("Substring not found", {
                    hd: [
                      "substring",
                      Import$negBase.sexp_of_string(t.pattern)
                    ],
                    tl: /* [] */0
                  }));
  }
}

function index_all(param, may_overlap, text) {
  var kmp_array = param.kmp_array;
  var pattern = param.pattern;
  if (pattern.length === 0) {
    return List$negBase.init(Import$negBase.$plus(1, text.length), (function (prim) {
                  return prim;
                }));
  }
  var char_equal = get_char_equal(param.case_sensitive);
  var matched_chars = 0;
  var k = pattern.length;
  var n = text.length;
  var found = /* [] */0;
  for(var j = 0; j <= n; ++j){
    if (matched_chars === k) {
      found = {
        hd: Import$negBase.$neg(j, k),
        tl: found
      };
      matched_chars = may_overlap ? kmp_array[Import$negBase.$neg(k, 1)] : 0;
    }
    if (Import$negBase.$less(j, n)) {
      var next_text_char = text.charCodeAt(j);
      matched_chars = kmp_internal_loop(matched_chars, next_text_char, pattern, kmp_array, char_equal);
    }
    
  }
  return List$negBase.rev(found);
}

function replace_first(pos, t, s, with_) {
  var i = index$1(pos, t, s);
  if (i === undefined) {
    return s;
  }
  var len_s = s.length;
  var len_t = t.pattern.length;
  var len_with = with_.length;
  var dst = Bytes0$negBase.create(Import$negBase.$neg(Import$negBase.$plus(len_s, len_with), len_t));
  Bytes0$negBase.blit_string(s, 0, dst, 0, i);
  Bytes0$negBase.blit_string(with_, 0, dst, i, len_with);
  Bytes0$negBase.blit_string(s, Import$negBase.$plus(i, len_t), dst, Import$negBase.$plus(i, len_with), Import$negBase.$neg(Import$negBase.$neg(len_s, i), len_t));
  return Bytes0$negBase.unsafe_to_string(dst);
}

function replace_all(t, s, with_) {
  var matches = index_all(t, false, s);
  if (!matches) {
    return s;
  }
  var len_s = s.length;
  var len_t = t.pattern.length;
  var len_with = with_.length;
  var num_matches = List$negBase.length(matches);
  var dst = Bytes0$negBase.create(Import$negBase.$plus(len_s, Import$negBase.$star(Import$negBase.$neg(len_with, len_t), num_matches)));
  var next_dst_pos = {
    contents: 0
  };
  var next_src_pos = {
    contents: 0
  };
  List$negBase.iter(matches, (function (i) {
          var len = Import$negBase.$neg(i, next_src_pos[0]);
          Bytes0$negBase.blit_string(s, next_src_pos[0], dst, next_dst_pos[0], len);
          Bytes0$negBase.blit_string(with_, 0, dst, Import$negBase.$plus(next_dst_pos[0], len), len_with);
          next_dst_pos[0] = Import$negBase.$plus(Import$negBase.$plus(next_dst_pos[0], len), len_with);
          next_src_pos[0] = Import$negBase.$plus(Import$negBase.$plus(next_src_pos[0], len), len_t);
          
        }));
  Bytes0$negBase.blit_string(s, next_src_pos[0], dst, next_dst_pos[0], Import$negBase.$neg(len_s, next_src_pos[0]));
  return Bytes0$negBase.unsafe_to_string(dst);
}

function equal(a__001_, b__002_) {
  if (Ppx_compare_lib$negBase.phys_equal(a__001_, b__002_)) {
    return true;
  } else if (Import$negBase.equal_string(a__001_.pattern, b__002_.pattern) && Import$negBase.equal_bool(a__001_.case_sensitive, b__002_.case_sensitive)) {
    return Import$negBase.equal_array(Import$negBase.equal_int, a__001_.kmp_array, b__002_.kmp_array);
  } else {
    return false;
  }
}

function sexp_of_t$1(param) {
  var arg = Import$negBase.sexp_of_array(Import$negBase.sexp_of_int, param.kmp_array);
  var bnds_0 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "kmp_array"
      },
      tl: {
        hd: arg,
        tl: /* [] */0
      }
    }
  };
  var bnds = {
    hd: bnds_0,
    tl: /* [] */0
  };
  var arg$1 = Import$negBase.sexp_of_bool(param.case_sensitive);
  var bnds_0$1 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "case_sensitive"
      },
      tl: {
        hd: arg$1,
        tl: /* [] */0
      }
    }
  };
  var bnds$1 = {
    hd: bnds_0$1,
    tl: bnds
  };
  var arg$2 = Import$negBase.sexp_of_string(param.pattern);
  var bnds_0$2 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "pattern"
      },
      tl: {
        hd: arg$2,
        tl: /* [] */0
      }
    }
  };
  var bnds$2 = {
    hd: bnds_0$2,
    tl: bnds$1
  };
  return {
          TAG: /* List */1,
          _0: bnds$2
        };
}

function representation(prim) {
  return prim;
}

var Private = {
  equal: equal,
  sexp_of_t: sexp_of_t$1,
  representation: representation
};

function substr_index_gen(case_sensitive, pos, t, pattern) {
  return index$1(pos, create(pattern, case_sensitive), t);
}

function substr_index_exn_gen(case_sensitive, pos, t, pattern) {
  return index_exn$1(pos, create(pattern, case_sensitive), t);
}

function substr_index_all_gen(case_sensitive, t, may_overlap, pattern) {
  return index_all(create(pattern, case_sensitive), may_overlap, t);
}

function substr_replace_first_gen(case_sensitive, pos, t, pattern) {
  var partial_arg = create(pattern, case_sensitive);
  return function (param) {
    return replace_first(pos, partial_arg, t, param);
  };
}

function substr_replace_all_gen(case_sensitive, t, pattern) {
  var partial_arg = create(pattern, case_sensitive);
  return function (param) {
    return replace_all(partial_arg, t, param);
  };
}

function is_substring_gen(case_sensitive, t, substring) {
  return Option$negBase.is_some(substr_index_gen(case_sensitive, undefined, t, substring));
}

function substr_index(param, param$1, param$2) {
  return substr_index_gen(true, param, param$1, param$2);
}

function substr_index_exn(param, param$1, param$2) {
  return substr_index_exn_gen(true, param, param$1, param$2);
}

function substr_index_all(param, param$1, param$2) {
  return substr_index_all_gen(true, param, param$1, param$2);
}

function substr_replace_first(param, param$1, param$2) {
  return substr_replace_first_gen(true, param, param$1, param$2);
}

function substr_replace_all(param, param$1) {
  return substr_replace_all_gen(true, param, param$1);
}

function is_substring(param, param$1) {
  return is_substring_gen(true, param, param$1);
}

function is_substring_at_gen(str, str_pos, sub, char_equal) {
  var str_len = str.length;
  var sub_len = sub.length;
  if (Import$negBase.$less(str_pos, 0) || Import$negBase.$great(str_pos, str_len)) {
    Curry._3(Printf$negBase.invalid_argf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "String.is_substring_at: invalid index ",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: {
                    TAG: /* String_literal */11,
                    _0: " for string of length ",
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: /* End_of_format */0
                    }
                  }
                }
              },
              _1: "String.is_substring_at: invalid index %d for string of length %d"
            }), str_pos, str_len, undefined);
  }
  if (Import$negBase.$less$eq(Import$negBase.$plus(str_pos, sub_len), str_len)) {
    var _str_pos = str_pos;
    var _sub_pos = 0;
    while(true) {
      var sub_pos = _sub_pos;
      var str_pos$1 = _str_pos;
      if (sub_pos === sub_len) {
        return true;
      }
      if (!Curry._2(char_equal, str.charCodeAt(str_pos$1), sub.charCodeAt(sub_pos))) {
        return false;
      }
      _sub_pos = Import$negBase.$plus(sub_pos, 1);
      _str_pos = Import$negBase.$plus(str_pos$1, 1);
      continue ;
    };
  } else {
    return false;
  }
}

function is_suffix_gen(string, suffix, char_equal) {
  var string_len = string.length;
  var suffix_len = suffix.length;
  if (Import$negBase.$great$eq(string_len, suffix_len)) {
    return is_substring_at_gen(string, Import$negBase.$neg(string_len, suffix_len), suffix, char_equal);
  } else {
    return false;
  }
}

function is_prefix_gen(string, prefix, char_equal) {
  var string_len = string.length;
  var prefix_len = prefix.length;
  if (Import$negBase.$great$eq(string_len, prefix_len)) {
    return is_substring_at_gen(string, 0, prefix, char_equal);
  } else {
    return false;
  }
}

function char_compare_caseless(c1, c2) {
  return Curry._2(Char$negBase.compare, Char$negBase.lowercase(c1), Char$negBase.lowercase(c2));
}

function compare(string1, string2) {
  if (Import$negBase.phys_equal(string1, string2)) {
    return 0;
  } else {
    var _pos = 0;
    var len1 = string1.length;
    var len2 = string2.length;
    while(true) {
      var pos = _pos;
      if (pos === len1) {
        if (pos === len2) {
          return 0;
        } else {
          return -1;
        }
      }
      if (pos === len2) {
        return 1;
      }
      var c = char_compare_caseless(string1.charCodeAt(pos), string2.charCodeAt(pos));
      if (c !== 0) {
        return c;
      }
      _pos = Import$negBase.$plus(pos, 1);
      continue ;
    };
  }
}

function hash_fold_t(state, t) {
  var len = t.length;
  var state$1 = Import$negBase.hash_fold_int(state, len);
  for(var pos = 0 ,pos_finish = Import$negBase.$neg(len, 1); pos <= pos_finish; ++pos){
    state$1 = Import$negBase.hash_fold_char(state$1, Char$negBase.lowercase(t.charCodeAt(pos)));
  }
  return state$1;
}

function hash$1(t) {
  return Hash$negBase.run(undefined, hash_fold_t, t);
}

function is_suffix(s, suffix) {
  return is_suffix_gen(s, suffix, Char$negBase.Caseless.equal);
}

function is_prefix(s, prefix) {
  return is_prefix_gen(s, prefix, Char$negBase.Caseless.equal);
}

function substr_index$1(param, param$1, param$2) {
  return substr_index_gen(false, param, param$1, param$2);
}

function substr_index_exn$1(param, param$1, param$2) {
  return substr_index_exn_gen(false, param, param$1, param$2);
}

function substr_index_all$1(param, param$1, param$2) {
  return substr_index_all_gen(false, param, param$1, param$2);
}

function substr_replace_first$1(param, param$1, param$2) {
  return substr_replace_first_gen(false, param, param$1, param$2);
}

function substr_replace_all$1(param, param$1) {
  return substr_replace_all_gen(false, param, param$1);
}

function is_substring$1(param, param$1) {
  return is_substring_gen(false, param, param$1);
}

var arg = Char$negBase.Caseless.equal;

function is_substring_at(param) {
  return function (param$1) {
    return function (param$2) {
      return is_substring_at_gen(param, param$1, param$2, arg);
    };
  };
}

var include$1 = Comparable$negBase.Make({
      compare: compare,
      sexp_of_t: Import$negBase.sexp_of_string
    });

function of_string(prim) {
  return prim;
}

function to_string(prim) {
  return prim;
}

function init(n, f) {
  if (Import$negBase.$less(n, 0)) {
    Curry._2(Printf$negBase.invalid_argf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "String.init ",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: /* End_of_format */0
                }
              },
              _1: "String.init %d"
            }), n, undefined);
  }
  var t = Bytes0$negBase.create(n);
  for(var i = 0 ,i_finish = Import$negBase.$neg(n, 1); i <= i_finish; ++i){
    Caml_bytes.set(t, i, Curry._1(f, i));
  }
  return Bytes0$negBase.unsafe_to_string(t);
}

function to_list(s) {
  var _acc = /* [] */0;
  var _i = Import$negBase.$neg(s.length, 1);
  while(true) {
    var i = _i;
    var acc = _acc;
    if (Import$negBase.$less(i, 0)) {
      return acc;
    }
    _i = Import$negBase.$neg(i, 1);
    _acc = {
      hd: Caml_string.get(s, i),
      tl: acc
    };
    continue ;
  };
}

function to_list_rev(s) {
  var len = s.length;
  var _acc = /* [] */0;
  var _i = 0;
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i === len) {
      return acc;
    }
    _i = Import$negBase.$plus(i, 1);
    _acc = {
      hd: Caml_string.get(s, i),
      tl: acc
    };
    continue ;
  };
}

function rev(t) {
  var len = t.length;
  var res = Bytes0$negBase.create(len);
  for(var i = 0 ,i_finish = Import$negBase.$neg(len, 1); i <= i_finish; ++i){
    res[i] = t.charCodeAt(Import$negBase.$neg(Import$negBase.$neg(len, 1), i));
  }
  return Bytes0$negBase.unsafe_to_string(res);
}

var not_found_1$4 = {
  TAG: /* Atom */0,
  _0: "String.lsplit2_exn: not found"
};

var not_found$4 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$4
};

function lsplit2_exn(line, delim) {
  var pos = index_exn_internal(line, not_found$4, delim);
  return [
          sub(line, 0, pos),
          sub(line, Import$negBase.$plus(pos, 1), Import$negBase.$neg(Import$negBase.$neg(line.length, pos), 1))
        ];
}

var not_found_1$5 = {
  TAG: /* Atom */0,
  _0: "String.rsplit2_exn: not found"
};

var not_found$5 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$5
};

function rsplit2_exn(line, delim) {
  var pos = rindex_exn_internal(line, not_found$5, delim);
  return [
          sub(line, 0, pos),
          sub(line, Import$negBase.$plus(pos, 1), Import$negBase.$neg(Import$negBase.$neg(line.length, pos), 1))
        ];
}

function lsplit2(line, on) {
  try {
    return lsplit2_exn(line, on);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Import$negBase.Not_found_s) {
      return ;
    }
    if (exn.RE_EXN_ID === Import$negBase.Caml.Not_found) {
      return ;
    }
    throw exn;
  }
}

function rsplit2(line, on) {
  try {
    return rsplit2_exn(line, on);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Import$negBase.Not_found_s) {
      return ;
    }
    if (exn.RE_EXN_ID === Import$negBase.Caml.Not_found) {
      return ;
    }
    throw exn;
  }
}

function char_list_mem(_l, c) {
  while(true) {
    var l = _l;
    if (!l) {
      return false;
    }
    if (Curry._2(Char$negBase.equal, l.hd, c)) {
      return true;
    }
    _l = l.tl;
    continue ;
  };
}

function split_gen(str, on) {
  var is_delim;
  if (on.NAME === "char_list") {
    var l = on.VAL;
    is_delim = (function (c) {
        return char_list_mem(l, c);
      });
  } else {
    var c$p = on.VAL;
    is_delim = (function (c) {
        return Curry._2(Char$negBase.equal, c, c$p);
      });
  }
  var len = str.length;
  var _acc = /* [] */0;
  var _last_pos = len;
  var _pos = Import$negBase.$neg(len, 1);
  while(true) {
    var pos = _pos;
    var last_pos = _last_pos;
    var acc = _acc;
    if (pos === -1) {
      return {
              hd: sub(str, 0, last_pos),
              tl: acc
            };
    }
    if (Curry._1(is_delim, Caml_string.get(str, pos))) {
      var pos1 = Import$negBase.$plus(pos, 1);
      var sub_str = sub(str, pos1, Import$negBase.$neg(last_pos, pos1));
      _pos = Import$negBase.$neg(pos, 1);
      _last_pos = pos;
      _acc = {
        hd: sub_str,
        tl: acc
      };
      continue ;
    }
    _pos = Import$negBase.$neg(pos, 1);
    continue ;
  };
}

function split(str, on) {
  return split_gen(str, {
              NAME: "char",
              VAL: on
            });
}

function split_on_chars(str, chars) {
  return split_gen(str, {
              NAME: "char_list",
              VAL: chars
            });
}

function back_up_at_newline(t, pos, eol) {
  pos[0] = Import$negBase.$neg(pos[0], Import$negBase.$great(pos[0], 0) && Curry._2(Char$negBase.equal, Caml_string.get(t, Import$negBase.$neg(pos[0], 1)), /* '\r' */13) ? 2 : 1);
  eol[0] = Import$negBase.$plus(pos[0], 1);
  
}

function split_lines(t) {
  var n = t.length;
  if (n === 0) {
    return /* [] */0;
  }
  var pos = {
    contents: Import$negBase.$neg(n, 1)
  };
  var eol = {
    contents: n
  };
  var ac = /* [] */0;
  if (Curry._2(Char$negBase.equal, Caml_string.get(t, pos[0]), /* '\n' */10)) {
    back_up_at_newline(t, pos, eol);
  }
  while(Import$negBase.$great$eq(pos[0], 0)) {
    if (Curry._2(Char$negBase.$less$great, Caml_string.get(t, pos[0]), /* '\n' */10)) {
      Import$negBase.decr(pos);
    } else {
      var start = Import$negBase.$plus(pos[0], 1);
      ac = {
        hd: sub(t, start, Import$negBase.$neg(eol[0], start)),
        tl: ac
      };
      back_up_at_newline(t, pos, eol);
    }
  };
  return {
          hd: sub(t, 0, eol[0]),
          tl: ac
        };
}

function is_suffix$1(s, suffix) {
  return is_suffix_gen(s, suffix, Char$negBase.equal);
}

function is_prefix$1(s, prefix) {
  return is_prefix_gen(s, prefix, Char$negBase.equal);
}

function is_substring_at$1(s, pos, substring) {
  return is_substring_at_gen(s, pos, substring, Char$negBase.equal);
}

function wrap_sub_n(t, n, name, pos, len, on_error) {
  if (Import$negBase.$less(n, 0)) {
    return Import$negBase.invalid_arg(String0$negBase.$caret(name, " expecting nonnegative argument"));
  }
  try {
    return sub(t, pos, len);
  }
  catch (exn){
    return on_error;
  }
}

function drop_prefix(t, n) {
  return wrap_sub_n(t, n, "drop_prefix", n, Import$negBase.$neg(t.length, n), "");
}

function drop_suffix(t, n) {
  return wrap_sub_n(t, n, "drop_suffix", 0, Import$negBase.$neg(t.length, n), "");
}

function prefix(t, n) {
  return wrap_sub_n(t, n, "prefix", 0, n, t);
}

function suffix(t, n) {
  return wrap_sub_n(t, n, "suffix", Import$negBase.$neg(t.length, n), n, t);
}

function lfindi(posOpt, t, f) {
  var pos = posOpt !== undefined ? posOpt : 0;
  var n = t.length;
  var _i = pos;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    if (Curry._2(f, i, Caml_string.get(t, i))) {
      return i;
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function find(t, f) {
  var i = lfindi(undefined, t, (function (param, c) {
          return Curry._1(f, c);
        }));
  if (i !== undefined) {
    return Caml_string.get(t, i);
  }
  
}

function find_map(t, f) {
  var n = t.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    var res = Curry._1(f, Caml_string.get(t, i));
    if (res !== undefined) {
      return res;
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function rfindi(pos, t, f) {
  var _i = pos !== undefined ? pos : Import$negBase.$neg(t.length, 1);
  while(true) {
    var i = _i;
    if (Import$negBase.$less(i, 0)) {
      return ;
    }
    if (Curry._2(f, i, Caml_string.get(t, i))) {
      return i;
    }
    _i = Import$negBase.$neg(i, 1);
    continue ;
  };
}

function last_non_drop(drop, t) {
  return rfindi(undefined, t, (function (param, c) {
                return !Curry._1(drop, c);
              }));
}

function rstrip(dropOpt, t) {
  var drop = dropOpt !== undefined ? dropOpt : Char$negBase.is_whitespace;
  var i = last_non_drop(drop, t);
  if (i !== undefined) {
    if (i === Import$negBase.$neg(t.length, 1)) {
      return t;
    } else {
      return prefix(t, Import$negBase.$plus(i, 1));
    }
  } else {
    return "";
  }
}

function first_non_drop(drop, t) {
  return lfindi(undefined, t, (function (param, c) {
                return !Curry._1(drop, c);
              }));
}

function lstrip(dropOpt, t) {
  var drop = dropOpt !== undefined ? dropOpt : Char$negBase.is_whitespace;
  var n = first_non_drop(drop, t);
  if (n !== undefined) {
    if (n !== 0) {
      return drop_prefix(t, n);
    } else {
      return t;
    }
  } else {
    return "";
  }
}

function strip(dropOpt, t) {
  var drop = dropOpt !== undefined ? dropOpt : Char$negBase.is_whitespace;
  var length = t.length;
  if (length === 0 || !(Curry._1(drop, Caml_string.get(t, 0)) || Curry._1(drop, Caml_string.get(t, Import$negBase.$neg(length, 1))))) {
    return t;
  }
  var first = first_non_drop(drop, t);
  if (first === undefined) {
    return "";
  }
  var last = last_non_drop(drop, t);
  if (last !== undefined) {
    return sub(t, first, Import$negBase.$plus(Import$negBase.$neg(last, first), 1));
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string.ml",
          759,
          17
        ],
        Error: new Error()
      };
}

function mapi(t, f) {
  var l = t.length;
  var t$p = Bytes0$negBase.create(l);
  for(var i = 0 ,i_finish = Import$negBase.$neg(l, 1); i <= i_finish; ++i){
    t$p[i] = Curry._2(f, i, Caml_string.get(t, i));
  }
  return Bytes0$negBase.unsafe_to_string(t$p);
}

function map(t, f) {
  var l = t.length;
  var t$p = Bytes0$negBase.create(l);
  for(var i = 0 ,i_finish = Import$negBase.$neg(l, 1); i <= i_finish; ++i){
    t$p[i] = Curry._1(f, Caml_string.get(t, i));
  }
  return Bytes0$negBase.unsafe_to_string(t$p);
}

function to_array(s) {
  return Array0$negBase.init(s.length, (function (i) {
                return Caml_string.get(s, i);
              }));
}

function exists(s, f) {
  var _i = 0;
  var len = s.length;
  while(true) {
    var i = _i;
    if (!Import$negBase.$less(i, len)) {
      return false;
    }
    if (Curry._1(f, Caml_string.get(s, i))) {
      return true;
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function for_all(s, f) {
  var _i = 0;
  var len = s.length;
  while(true) {
    var i = _i;
    if (i === len) {
      return true;
    }
    if (!Curry._1(f, Caml_string.get(s, i))) {
      return false;
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function fold(t, init, f) {
  var n = t.length;
  var _i = 0;
  var _ac = init;
  while(true) {
    var ac = _ac;
    var i = _i;
    if (i === n) {
      return ac;
    }
    _ac = Curry._2(f, ac, Caml_string.get(t, i));
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function foldi(t, init, f) {
  var n = t.length;
  var _i = 0;
  var _ac = init;
  while(true) {
    var ac = _ac;
    var i = _i;
    if (i === n) {
      return ac;
    }
    _ac = Curry._3(f, i, ac, Caml_string.get(t, i));
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function iteri(t, f) {
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    Curry._2(f, i, t.charCodeAt(i));
  }
  
}

function count(t, f) {
  return Container$negBase.count(fold, t, f);
}

function sum(m, t, f) {
  return Container$negBase.sum(fold, m, t, f);
}

function min_elt(t) {
  return function (param) {
    return Container$negBase.min_elt(fold, t, param);
  };
}

function max_elt(t) {
  return function (param) {
    return Container$negBase.max_elt(fold, t, param);
  };
}

function fold_result(t, init, f) {
  return Container$negBase.fold_result(fold, init, f, t);
}

function fold_until(t, init, f) {
  return function (param) {
    return Container$negBase.fold_until(fold, init, f, param, t);
  };
}

function find_mapi(t, f) {
  return Indexed_container$negBase.find_mapi(iteri, t, f);
}

function findi(t, f) {
  return Indexed_container$negBase.findi(iteri, t, f);
}

function counti(t, f) {
  return Indexed_container$negBase.counti(foldi, t, f);
}

function for_alli(t, f) {
  return Indexed_container$negBase.for_alli(iteri, t, f);
}

function existsi(t, f) {
  return Indexed_container$negBase.existsi(iteri, t, f);
}

function mem(t, c) {
  var _i = 0;
  var len = t.length;
  while(true) {
    var i = _i;
    if (!Import$negBase.$less(i, len)) {
      return false;
    }
    if (Curry._2(Char$negBase.equal, c, t.charCodeAt(i))) {
      return true;
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function tr(target, replacement, s) {
  if (Curry._2(Char$negBase.equal, target, replacement) || !mem(s, target)) {
    return s;
  } else {
    return map(s, (function (c) {
                  if (Curry._2(Char$negBase.equal, c, target)) {
                    return replacement;
                  } else {
                    return c;
                  }
                }));
  }
}

function tr_multi(target, replacement) {
  if (target.length === 0) {
    return Staged$negBase.stage(function (prim) {
                return prim;
              });
  }
  if (replacement.length === 0) {
    return Import$negBase.invalid_arg("tr_multi replacement is empty string");
  }
  var tr_map = Bytes_tr$negBase.tr_create_map(target, replacement);
  if (tr_map !== undefined) {
    return Staged$negBase.stage(function (s) {
                if (exists(s, (function (c) {
                          return Curry._2(Char$negBase.$less$great, c, tr_map.charCodeAt(Char$negBase.to_int(c)));
                        }))) {
                  return map(s, (function (c) {
                                return tr_map.charCodeAt(Char$negBase.to_int(c));
                              }));
                } else {
                  return s;
                }
              });
  } else {
    return Staged$negBase.stage(function (prim) {
                return prim;
              });
  }
}

function concat_array(sep, ar) {
  return String0$negBase.concat(sep, Array0$negBase.to_list(ar));
}

function concat_map(sep, s, f) {
  var ar = Array0$negBase.map(to_array(s), f);
  return String0$negBase.concat(sep, Array0$negBase.to_list(ar));
}

function filter(t, f) {
  var n = t.length;
  var i = {
    contents: 0
  };
  while(Import$negBase.$less(i[0], n) && Curry._1(f, Caml_string.get(t, i[0]))) {
    Import$negBase.incr(i);
  };
  if (i[0] === n) {
    return t;
  }
  var out = Bytes0$negBase.create(Import$negBase.$neg(n, 1));
  Bytes0$negBase.blit_string(t, 0, out, 0, i[0]);
  var out_pos = {
    contents: i[0]
  };
  Import$negBase.incr(i);
  while(Import$negBase.$less(i[0], n)) {
    var c = Caml_string.get(t, i[0]);
    if (Curry._1(f, c)) {
      Caml_bytes.set(out, out_pos[0], c);
      Import$negBase.incr(out_pos);
    }
    Import$negBase.incr(i);
  };
  var out$1 = Bytes0$negBase.unsafe_to_string(out);
  if (out_pos[0] === Import$negBase.$neg(n, 1)) {
    return out$1;
  } else {
    return sub(out$1, 0, out_pos[0]);
  }
}

function chop_prefix(s, prefix) {
  if (is_prefix$1(s, prefix)) {
    return drop_prefix(s, prefix.length);
  }
  
}

function chop_prefix_if_exists(s, prefix) {
  if (is_prefix$1(s, prefix)) {
    return drop_prefix(s, prefix.length);
  } else {
    return s;
  }
}

function chop_prefix_exn(s, prefix) {
  var str = chop_prefix(s, prefix);
  if (str !== undefined) {
    return str;
  } else {
    return Curry._3(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "String.chop_prefix_exn ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* ' ' */32,
                          _1: {
                            TAG: /* Caml_string */3,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "String.chop_prefix_exn %S %S"
                  }), s, prefix, undefined);
  }
}

function chop_suffix(s, suffix) {
  if (is_suffix$1(s, suffix)) {
    return drop_suffix(s, suffix.length);
  }
  
}

function chop_suffix_if_exists(s, suffix) {
  if (is_suffix$1(s, suffix)) {
    return drop_suffix(s, suffix.length);
  } else {
    return s;
  }
}

function chop_suffix_exn(s, suffix) {
  var str = chop_suffix(s, suffix);
  if (str !== undefined) {
    return str;
  } else {
    return Curry._3(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "String.chop_suffix_exn ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* ' ' */32,
                          _1: {
                            TAG: /* Caml_string */3,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "String.chop_suffix_exn %S %S"
                  }), s, suffix, undefined);
  }
}

function shorter(a, b) {
  if (Import$negBase.$less$eq(a.length, b.length)) {
    return a;
  } else {
    return b;
  }
}

function shortest(list) {
  if (list) {
    return List$negBase.fold(list.tl, list.hd, shorter);
  } else {
    return "";
  }
}

function pos_from_left(param, i) {
  return i;
}

function pos_from_right(t, i) {
  return Import$negBase.$neg(Import$negBase.$neg(t.length, i), 1);
}

function common_generic2_length_loop(a, b, get_pos, max_len, _len_so_far) {
  while(true) {
    var len_so_far = _len_so_far;
    if (Import$negBase.$great$eq(len_so_far, max_len)) {
      return max_len;
    }
    if (!Curry._2(Char$negBase.equal, a.charCodeAt(Curry._2(get_pos, a, len_so_far)), b.charCodeAt(Curry._2(get_pos, b, len_so_far)))) {
      return len_so_far;
    }
    _len_so_far = Import$negBase.$plus(len_so_far, 1);
    continue ;
  };
}

function common_generic2_length(a, b, get_pos) {
  var max_len = Import$negBase.min(a.length, b.length);
  return common_generic2_length_loop(a, b, get_pos, max_len, 0);
}

function common_generic_length_loop(_first, _list, get_pos, _max_len) {
  while(true) {
    var max_len = _max_len;
    var list = _list;
    var first = _first;
    if (!list) {
      return max_len;
    }
    var second = list.hd;
    var max_len$1 = common_generic2_length_loop(first, second, get_pos, max_len, 0);
    _max_len = max_len$1;
    _list = list.tl;
    _first = second;
    continue ;
  };
}

function common_generic_length(list, get_pos) {
  if (!list) {
    return 0;
  }
  var max_len = shortest(list).length;
  return common_generic_length_loop(list.hd, list.tl, get_pos, max_len);
}

function common_generic2(a, b, get_pos, take) {
  var len = common_generic2_length(a, b, get_pos);
  return Curry._2(take, shorter(a, b), len);
}

function common_generic(list, get_pos, take) {
  if (!list) {
    return "";
  }
  var s = shortest(list);
  var max_len = s.length;
  if (max_len === 0) {
    return "";
  }
  var len = common_generic_length_loop(list.hd, list.tl, get_pos, max_len);
  return Curry._2(take, s, len);
}

function common_prefix(list) {
  return common_generic(list, pos_from_left, prefix);
}

function common_suffix(list) {
  return common_generic(list, pos_from_right, suffix);
}

function common_prefix2(a, b) {
  return common_generic2(a, b, pos_from_left, prefix);
}

function common_suffix2(a, b) {
  return common_generic2(a, b, pos_from_right, suffix);
}

function common_prefix_length(list) {
  return common_generic_length(list, pos_from_left);
}

function common_suffix_length(list) {
  return common_generic_length(list, pos_from_right);
}

function common_prefix2_length(a, b) {
  return common_generic2_length(a, b, pos_from_left);
}

function common_suffix2_length(a, b) {
  return common_generic2_length(a, b, pos_from_right);
}

function of_char(c) {
  return String0$negBase.make(1, c);
}

function of_char_list(l) {
  var t = Bytes0$negBase.create(List$negBase.length(l));
  List$negBase.iteri(l, (function (i, c) {
          return Caml_bytes.set(t, i, c);
        }));
  return Bytes0$negBase.unsafe_to_string(t);
}

function build_and_validate_escapeworthy_map(escapeworthy_map, escape_char, func) {
  var escapeworthy_map$1 = List$negBase.Assoc.mem(escapeworthy_map, Char$negBase.equal, escape_char) ? escapeworthy_map : ({
        hd: [
          escape_char,
          escape_char
        ],
        tl: escapeworthy_map
      });
  var arr = Array0$negBase.create(256, -1);
  var vals = Array0$negBase.create(256, false);
  var _param = escapeworthy_map$1;
  while(true) {
    var param = _param;
    if (!param) {
      return {
              TAG: /* Ok */0,
              _0: arr
            };
    }
    var match = param.hd;
    var c_to = match[1];
    var c_from = match[0];
    var match$1 = func === "Unescape" ? [
        Char$negBase.to_int(c_to),
        c_from
      ] : [
        Char$negBase.to_int(c_from),
        c_to
      ];
    var v = match$1[1];
    var k = match$1[0];
    if (Import$negBase.$less$great(Caml_array.get(arr, k), -1) || Caml_array.get(vals, Char$negBase.to_int(v))) {
      return Or_error$negBase.error_s(Sexp$negBase.message("escapeworthy_map not one-to-one", {
                      hd: [
                        "c_from",
                        Import$negBase.sexp_of_char(c_from)
                      ],
                      tl: {
                        hd: [
                          "c_to",
                          Import$negBase.sexp_of_char(c_to)
                        ],
                        tl: {
                          hd: [
                            "escapeworthy_map",
                            Import$negBase.sexp_of_list((function (param) {
                                    return Import$negBase.sexp_of_pair(Import$negBase.sexp_of_char, Import$negBase.sexp_of_char, param);
                                  }), escapeworthy_map$1)
                          ],
                          tl: /* [] */0
                        }
                      }
                    }));
    }
    Caml_array.set(arr, k, Char$negBase.to_int(v));
    Caml_array.set(vals, Char$negBase.to_int(v), true);
    _param = param.tl;
    continue ;
  };
}

function escape_gen(escapeworthy_map, escape_char) {
  var x = build_and_validate_escapeworthy_map(escapeworthy_map, escape_char, "Escape");
  if (x.TAG !== /* Ok */0) {
    return x;
  }
  var escapeworthy = x._0;
  return {
          TAG: /* Ok */0,
          _0: (function (src) {
              var to_escape_len = {
                contents: 0
              };
              var to_escape = foldi(src, /* [] */0, (function (i, acc, c) {
                      var n = Caml_array.get(escapeworthy, Char$negBase.to_int(c));
                      if (n !== -1) {
                        Import$negBase.incr(to_escape_len);
                        return {
                                hd: [
                                  i,
                                  Char$negBase.unsafe_of_int(n)
                                ],
                                tl: acc
                              };
                      } else {
                        return acc;
                      }
                    }));
              if (!to_escape) {
                return src;
              }
              var src_len = src.length;
              var dst_len = Import$negBase.$plus(src_len, to_escape_len[0]);
              var dst = Bytes0$negBase.create(dst_len);
              var loop = function (_last_idx, _last_dst_pos, _param) {
                while(true) {
                  var param = _param;
                  var last_dst_pos = _last_dst_pos;
                  var last_idx = _last_idx;
                  if (!param) {
                    return Bytes0$negBase.blit_string(src, 0, dst, 0, last_idx);
                  }
                  var match = param.hd;
                  var idx = match[0];
                  var len = Import$negBase.$neg(Import$negBase.$neg(last_idx, idx), 1);
                  var dst_pos = Import$negBase.$neg(last_dst_pos, len);
                  Bytes0$negBase.blit_string(src, Import$negBase.$plus(idx, 1), dst, dst_pos, len);
                  var dst_pos$1 = Import$negBase.$neg(dst_pos, 2);
                  Caml_bytes.set(dst, dst_pos$1, escape_char);
                  Caml_bytes.set(dst, Import$negBase.$plus(dst_pos$1, 1), match[1]);
                  _param = param.tl;
                  _last_dst_pos = dst_pos$1;
                  _last_idx = idx;
                  continue ;
                };
              };
              loop(src_len, dst_len, to_escape);
              return Bytes0$negBase.unsafe_to_string(dst);
            })
        };
}

function escape_gen_exn(escapeworthy_map, escape_char) {
  return Staged$negBase.stage(Or_error$negBase.ok_exn(escape_gen(escapeworthy_map, escape_char)));
}

function $$escape(escapeworthy, escape_char) {
  var arg = function (c) {
    return [
            c,
            c
          ];
  };
  var escapeworthy_map = (function (param) {
        return List$negBase.map(param, arg);
      })(List$negBase.dedup_and_sort(Char$negBase.compare, escapeworthy));
  return escape_gen_exn(escapeworthy_map, escape_char);
}

function update_escape_status(str, escape_char, i, param) {
  if (param === "Escaped" || param === "Literal") {
    if (Curry._2(Char$negBase.equal, Caml_string.get(str, i), escape_char)) {
      return "Escaping";
    } else {
      return "Literal";
    }
  } else {
    return "Escaped";
  }
}

function unescape_gen(escapeworthy_map, escape_char) {
  var x = build_and_validate_escapeworthy_map(escapeworthy_map, escape_char, "Unescape");
  if (x.TAG !== /* Ok */0) {
    return x;
  }
  var escapeworthy = x._0;
  return {
          TAG: /* Ok */0,
          _0: (function (src) {
              var loop = function (_i, _status, _acc) {
                while(true) {
                  var acc = _acc;
                  var status = _status;
                  var i = _i;
                  if (Import$negBase.$great$eq(i, src.length)) {
                    return acc;
                  }
                  var status$1 = update_escape_status(src, escape_char, i, status);
                  _acc = status$1 === "Escaped" || status$1 === "Literal" ? acc : ({
                        hd: i,
                        tl: acc
                      });
                  _status = status$1;
                  _i = Import$negBase.$plus(i, 1);
                  continue ;
                };
              };
              var to_unescape = loop(0, "Literal", /* [] */0);
              if (!to_unescape) {
                return src;
              }
              var dst = Bytes0$negBase.create(Import$negBase.$neg(src.length, List$negBase.length(to_unescape)));
              var loop$1 = function (_last_idx, _last_dst_pos, _param) {
                while(true) {
                  var param = _param;
                  var last_dst_pos = _last_dst_pos;
                  var last_idx = _last_idx;
                  if (!param) {
                    return Bytes0$negBase.blit_string(src, 0, dst, 0, last_idx);
                  }
                  var idx = param.hd;
                  var len = Import$negBase.$neg(Import$negBase.$neg(last_idx, idx), 2);
                  var dst_pos = Import$negBase.$neg(last_dst_pos, len);
                  Bytes0$negBase.blit_string(src, Import$negBase.$plus(idx, 2), dst, dst_pos, len);
                  var dst_pos$1 = Import$negBase.$neg(dst_pos, 1);
                  var n = Caml_array.get(escapeworthy, Char$negBase.to_int(Caml_string.get(src, Import$negBase.$plus(idx, 1))));
                  Caml_bytes.set(dst, dst_pos$1, n !== -1 ? Char$negBase.unsafe_of_int(n) : Caml_string.get(src, Import$negBase.$plus(idx, 1)));
                  _param = param.tl;
                  _last_dst_pos = dst_pos$1;
                  _last_idx = idx;
                  continue ;
                };
              };
              if (Import$negBase.$less(to_unescape.hd, Import$negBase.$neg(src.length, 1))) {
                loop$1(src.length, dst.length, to_unescape);
              } else {
                loop$1(Import$negBase.$neg(src.length, 1), dst.length, to_unescape.tl);
              }
              return Bytes0$negBase.unsafe_to_string(dst);
            })
        };
}

function unescape_gen_exn(escapeworthy_map, escape_char) {
  return Staged$negBase.stage(Or_error$negBase.ok_exn(unescape_gen(escapeworthy_map, escape_char)));
}

function $$unescape(escape_char) {
  return unescape_gen_exn(/* [] */0, escape_char);
}

function preceding_escape_chars(str, escape_char, pos) {
  var _p = Import$negBase.$neg(pos, 1);
  var _cnt = 0;
  while(true) {
    var cnt = _cnt;
    var p = _p;
    if (Import$negBase.$less(p, 0) || Curry._2(Char$negBase.$less$great, Caml_string.get(str, p), escape_char)) {
      return cnt;
    }
    _cnt = Import$negBase.$plus(cnt, 1);
    _p = Import$negBase.$neg(p, 1);
    continue ;
  };
}

function update_escape_status$1(str, escape_char, i, param) {
  if (param === "Escaped" || param === "Literal") {
    if (Curry._2(Char$negBase.equal, Caml_string.get(str, i), escape_char)) {
      return "Escaping";
    } else {
      return "Literal";
    }
  } else {
    return "Escaped";
  }
}

function escape_status(str, escape_char, pos) {
  var odd = Import$negBase.mod(preceding_escape_chars(str, escape_char, pos), 2) === 1;
  var match = Curry._2(Char$negBase.equal, Caml_string.get(str, pos), escape_char);
  if (odd) {
    return "Escaped";
  } else if (match) {
    return "Escaping";
  } else {
    return "Literal";
  }
}

function check_bound(str, pos, function_name) {
  if (Import$negBase.$great$eq(pos, str.length) || Import$negBase.$less(pos, 0)) {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": out of bounds",
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "%s: out of bounds"
                  }), function_name, undefined);
  }
  
}

function is_char_escaping(str, escape_char, pos) {
  check_bound(str, pos, "is_char_escaping");
  var match = escape_status(str, escape_char, pos);
  return !(match === "Escaped" || match === "Literal");
}

function is_char_escaped(str, escape_char, pos) {
  check_bound(str, pos, "is_char_escaped");
  var match = escape_status(str, escape_char, pos);
  return match === "Escaped";
}

function is_char_literal(str, escape_char, pos) {
  check_bound(str, pos, "is_char_literal");
  var match = escape_status(str, escape_char, pos);
  return match === "Literal";
}

function index_from$1(str, escape_char, pos, $$char) {
  check_bound(str, pos, "index_from");
  var _i = pos;
  var _status = escape_status(str, escape_char, pos);
  while(true) {
    var status = _status;
    var i = _i;
    if (Import$negBase.$great$eq(i, pos) && status === "Literal" && Curry._2(Char$negBase.equal, Caml_string.get(str, i), $$char)) {
      return i;
    }
    var i$1 = Import$negBase.$plus(i, 1);
    if (Import$negBase.$great$eq(i$1, str.length)) {
      return ;
    }
    _status = update_escape_status$1(str, escape_char, i$1, status);
    _i = i$1;
    continue ;
  };
}

function index_from_exn$1(str, escape_char, pos, $$char) {
  var pos$1 = index_from$1(str, escape_char, pos, $$char);
  if (pos$1 !== undefined) {
    return pos$1;
  } else {
    return Error$negBase.raise_s(Sexp$negBase.message("index_from_exn: not found", {
                    hd: [
                      "str",
                      Import$negBase.sexp_of_string(str)
                    ],
                    tl: {
                      hd: [
                        "escape_char",
                        Import$negBase.sexp_of_char(escape_char)
                      ],
                      tl: {
                        hd: [
                          "pos",
                          Import$negBase.sexp_of_int(pos)
                        ],
                        tl: {
                          hd: [
                            "char",
                            Import$negBase.sexp_of_char($$char)
                          ],
                          tl: /* [] */0
                        }
                      }
                    }
                  }));
  }
}

function index$2(str, escape_char, $$char) {
  return index_from$1(str, escape_char, 0, $$char);
}

function index_exn$2(str, escape_char, $$char) {
  return index_from_exn$1(str, escape_char, 0, $$char);
}

function rindex_from$1(str, escape_char, pos, $$char) {
  check_bound(str, pos, "rindex_from");
  if (Curry._2(Char$negBase.equal, $$char, escape_char)) {
    return ;
  }
  var _pos = pos;
  while(true) {
    var pos$1 = _pos;
    if (Import$negBase.$less(pos$1, 0)) {
      return ;
    }
    var escape_chars = preceding_escape_chars(str, escape_char, pos$1);
    if (Import$negBase.mod(escape_chars, 2) === 0 && Curry._2(Char$negBase.equal, Caml_string.get(str, pos$1), $$char)) {
      return pos$1;
    }
    _pos = Import$negBase.$neg(Import$negBase.$neg(pos$1, escape_chars), 1);
    continue ;
  };
}

function rindex_from_exn$1(str, escape_char, pos, $$char) {
  var pos$1 = rindex_from$1(str, escape_char, pos, $$char);
  if (pos$1 !== undefined) {
    return pos$1;
  } else {
    return Error$negBase.raise_s(Sexp$negBase.message("rindex_from_exn: not found", {
                    hd: [
                      "str",
                      Import$negBase.sexp_of_string(str)
                    ],
                    tl: {
                      hd: [
                        "escape_char",
                        Import$negBase.sexp_of_char(escape_char)
                      ],
                      tl: {
                        hd: [
                          "pos",
                          Import$negBase.sexp_of_int(pos)
                        ],
                        tl: {
                          hd: [
                            "char",
                            Import$negBase.sexp_of_char($$char)
                          ],
                          tl: /* [] */0
                        }
                      }
                    }
                  }));
  }
}

function rindex$1(str, escape_char, $$char) {
  if (str.length === 0) {
    return ;
  } else {
    return rindex_from$1(str, escape_char, Import$negBase.$neg(str.length, 1), $$char);
  }
}

function rindex_exn$1(str, escape_char, $$char) {
  return rindex_from_exn$1(str, escape_char, Import$negBase.$neg(str.length, 1), $$char);
}

function split_gen$1(str, escape_char, on) {
  var is_delim;
  if (on.NAME === "char_list") {
    var l = on.VAL;
    is_delim = (function (c) {
        return char_list_mem(l, c);
      });
  } else {
    var c$p = on.VAL;
    is_delim = (function (c) {
        return Curry._2(Char$negBase.equal, c, c$p);
      });
  }
  var len = str.length;
  var _acc = /* [] */0;
  var _status = "Literal";
  var _last_pos = 0;
  var _pos = 0;
  while(true) {
    var pos = _pos;
    var last_pos = _last_pos;
    var status = _status;
    var acc = _acc;
    if (pos === len) {
      return List$negBase.rev({
                  hd: sub(str, last_pos, Import$negBase.$neg(len, last_pos)),
                  tl: acc
                });
    }
    var status$1 = update_escape_status$1(str, escape_char, pos, status);
    if (status$1 === "Literal" && Curry._1(is_delim, Caml_string.get(str, pos))) {
      var sub_str = sub(str, last_pos, Import$negBase.$neg(pos, last_pos));
      _pos = Import$negBase.$plus(pos, 1);
      _last_pos = Import$negBase.$plus(pos, 1);
      _status = status$1;
      _acc = {
        hd: sub_str,
        tl: acc
      };
      continue ;
    }
    _pos = Import$negBase.$plus(pos, 1);
    _status = status$1;
    continue ;
  };
}

function split$1(str, on) {
  var arg = {
    NAME: "char",
    VAL: on
  };
  return function (param) {
    return split_gen$1(str, param, arg);
  };
}

function split_on_chars$1(str, chars) {
  var arg = {
    NAME: "char_list",
    VAL: chars
  };
  return function (param) {
    return split_gen$1(str, param, arg);
  };
}

function split_at(str, pos) {
  return [
          sub(str, 0, pos),
          sub(str, Import$negBase.$plus(pos, 1), Import$negBase.$neg(Import$negBase.$neg(str.length, pos), 1))
        ];
}

function lsplit2$1(str, on, escape_char) {
  return Curry._2(Option$negBase.map, index$2(str, escape_char, on), (function (x) {
                return split_at(str, x);
              }));
}

function rsplit2$1(str, on, escape_char) {
  return Curry._2(Option$negBase.map, rindex$1(str, escape_char, on), (function (x) {
                return split_at(str, x);
              }));
}

function lsplit2_exn$1(str, on, escape_char) {
  return split_at(str, index_exn$2(str, escape_char, on));
}

function rsplit2_exn$1(str, on, escape_char) {
  return split_at(str, rindex_exn$1(str, escape_char, on));
}

function last_non_drop_literal(drop, escape_char, t) {
  return rfindi(undefined, t, (function (i, c) {
                if (!Curry._1(drop, c) || is_char_escaping(t, escape_char, i)) {
                  return true;
                } else {
                  return is_char_escaped(t, escape_char, i);
                }
              }));
}

function first_non_drop_literal(drop, escape_char, t) {
  return lfindi(undefined, t, (function (i, c) {
                if (!Curry._1(drop, c) || is_char_escaping(t, escape_char, i)) {
                  return true;
                } else {
                  return is_char_escaped(t, escape_char, i);
                }
              }));
}

function rstrip_literal(dropOpt, t, escape_char) {
  var drop = dropOpt !== undefined ? dropOpt : Char$negBase.is_whitespace;
  var i = last_non_drop_literal(drop, escape_char, t);
  if (i !== undefined) {
    if (i === Import$negBase.$neg(t.length, 1)) {
      return t;
    } else {
      return prefix(t, Import$negBase.$plus(i, 1));
    }
  } else {
    return "";
  }
}

function lstrip_literal(dropOpt, t, escape_char) {
  var drop = dropOpt !== undefined ? dropOpt : Char$negBase.is_whitespace;
  var n = first_non_drop_literal(drop, escape_char, t);
  if (n !== undefined) {
    if (n !== 0) {
      return drop_prefix(t, n);
    } else {
      return t;
    }
  } else {
    return "";
  }
}

function strip_literal(dropOpt, t, escape_char) {
  var drop = dropOpt !== undefined ? dropOpt : Char$negBase.is_whitespace;
  var length = t.length;
  if (length === 0 || !(Curry._1(drop, Caml_string.get(t, 0)) || Curry._1(drop, Caml_string.get(t, Import$negBase.$neg(length, 1))))) {
    return t;
  }
  var first = first_non_drop_literal(drop, escape_char, t);
  if (first === undefined) {
    return "";
  }
  var last = last_non_drop_literal(drop, escape_char, t);
  if (last !== undefined) {
    return sub(t, first, Import$negBase.$plus(Import$negBase.$neg(last, first), 1));
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "string.ml",
          1542,
          19
        ],
        Error: new Error()
      };
}

function between(t, low, high) {
  if (Curry._2(Import$negBase.String_replace_polymorphic_compare.$less$eq, low, t)) {
    return Curry._2(Import$negBase.String_replace_polymorphic_compare.$less$eq, t, high);
  } else {
    return false;
  }
}

function clamp_unchecked(t, min, max) {
  if (Curry._2(Import$negBase.String_replace_polymorphic_compare.$less, t, min)) {
    return min;
  } else if (Curry._2(Import$negBase.String_replace_polymorphic_compare.$less$eq, t, max)) {
    return t;
  } else {
    return max;
  }
}

function clamp_exn(t, min, max) {
  if (!Curry._2(Import$negBase.String_replace_polymorphic_compare.$less$eq, min, max)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "string.ml",
            1556,
            2
          ],
          Error: new Error()
        };
  }
  return clamp_unchecked(t, min, max);
}

function clamp(t, min, max) {
  if (Curry._2(Import$negBase.String_replace_polymorphic_compare.$great, min, max)) {
    return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                    hd: [
                      "min",
                      Import$negBase.sexp_of_string(min)
                    ],
                    tl: {
                      hd: [
                        "max",
                        Import$negBase.sexp_of_string(max)
                      ],
                      tl: /* [] */0
                    }
                  }));
  } else {
    return {
            TAG: /* Ok */0,
            _0: clamp_unchecked(t, min, max)
          };
  }
}

function create$1(case_sensitiveOpt, pattern) {
  var case_sensitive = case_sensitiveOpt !== undefined ? case_sensitiveOpt : true;
  return create(pattern, case_sensitive);
}

var t_sexp_grammar = Import$negBase.string_sexp_grammar;

var iter = String0$negBase.iter;

var hash_fold_t$1 = Import$negBase.hash_fold_string;

var t_of_sexp = Import$negBase.string_of_sexp;

var sexp_of_t$2 = Import$negBase.sexp_of_string;

var $great$eq = Import$negBase.String_replace_polymorphic_compare.$great$eq;

var $less$eq = Import$negBase.String_replace_polymorphic_compare.$less$eq;

var $eq = Import$negBase.String_replace_polymorphic_compare.$eq;

var $great = Import$negBase.String_replace_polymorphic_compare.$great;

var $less = Import$negBase.String_replace_polymorphic_compare.$less;

var $less$great = Import$negBase.String_replace_polymorphic_compare.$less$great;

var compare$1 = Import$negBase.String_replace_polymorphic_compare.compare;

var min = Import$negBase.String_replace_polymorphic_compare.min;

var max = Import$negBase.String_replace_polymorphic_compare.max;

var ascending = Import$negBase.String_replace_polymorphic_compare.ascending;

var descending = Import$negBase.String_replace_polymorphic_compare.descending;

var comparator = include.comparator;

var pp = Format.pp_print_string;

var max_length = String0$negBase.max_length;

var make = String0$negBase.make;

var copy = String0$negBase.copy;

var $caret = String0$negBase.$caret;

var concat = String0$negBase.concat;

var escaped = String0$negBase.escaped;

var uppercase = String0$negBase.uppercase;

var lowercase = String0$negBase.lowercase;

var capitalize = String0$negBase.capitalize;

var uncapitalize = String0$negBase.uncapitalize;

var Caseless_$great$eq = include$1.$great$eq;

var Caseless_$less$eq = include$1.$less$eq;

var Caseless_$eq = include$1.$eq;

var Caseless_$great = include$1.$great;

var Caseless_$less = include$1.$less;

var Caseless_$less$great = include$1.$less$great;

var Caseless_equal = include$1.equal;

var Caseless_compare = include$1.compare;

var Caseless_min = include$1.min;

var Caseless_max = include$1.max;

var Caseless_ascending = include$1.ascending;

var Caseless_descending = include$1.descending;

var Caseless_between = include$1.between;

var Caseless_clamp_exn = include$1.clamp_exn;

var Caseless_clamp = include$1.clamp;

var Caseless_comparator = include$1.comparator;

var Caseless = {
  hash_fold_t: hash_fold_t,
  hash: hash$1,
  t_of_sexp: Import$negBase.string_of_sexp,
  sexp_of_t: Import$negBase.sexp_of_string,
  t_sexp_grammar: Import$negBase.string_sexp_grammar,
  $great$eq: Caseless_$great$eq,
  $less$eq: Caseless_$less$eq,
  $eq: Caseless_$eq,
  $great: Caseless_$great,
  $less: Caseless_$less,
  $less$great: Caseless_$less$great,
  equal: Caseless_equal,
  compare: Caseless_compare,
  min: Caseless_min,
  max: Caseless_max,
  ascending: Caseless_ascending,
  descending: Caseless_descending,
  between: Caseless_between,
  clamp_exn: Caseless_clamp_exn,
  clamp: Caseless_clamp,
  comparator: Caseless_comparator,
  is_suffix: is_suffix,
  is_prefix: is_prefix,
  is_substring: is_substring$1,
  is_substring_at: is_substring_at,
  substr_index: substr_index$1,
  substr_index_exn: substr_index_exn$1,
  substr_index_all: substr_index_all$1,
  substr_replace_first: substr_replace_first$1,
  substr_replace_all: substr_replace_all$1
};

var Search_pattern = {
  sexp_of_t: sexp_of_t,
  create: create$1,
  pattern: pattern,
  case_sensitive: case_sensitive,
  matches: matches,
  index: index$1,
  index_exn: index_exn$1,
  index_all: index_all,
  replace_first: replace_first,
  replace_all: replace_all,
  Private: Private
};

var equal$1 = Import$negBase.String_replace_polymorphic_compare.equal;

var Escaping = {
  escape_gen_exn: escape_gen_exn,
  escape_gen: escape_gen,
  $$escape: $$escape,
  unescape_gen_exn: unescape_gen_exn,
  unescape_gen: unescape_gen,
  $$unescape: $$unescape,
  is_char_escaping: is_char_escaping,
  is_char_escaped: is_char_escaped,
  is_char_literal: is_char_literal,
  index: index$2,
  index_exn: index_exn$2,
  rindex: rindex$1,
  rindex_exn: rindex_exn$1,
  index_from: index_from$1,
  index_from_exn: index_from_exn$1,
  rindex_from: rindex_from$1,
  rindex_from_exn: rindex_from_exn$1,
  split: split$1,
  split_on_chars: split_on_chars$1,
  lsplit2: lsplit2$1,
  lsplit2_exn: lsplit2_exn$1,
  rsplit2: rsplit2$1,
  rsplit2_exn: rsplit2_exn$1,
  lstrip_literal: lstrip_literal,
  rstrip_literal: rstrip_literal,
  strip_literal: strip_literal
};

exports.t_sexp_grammar = t_sexp_grammar;
exports.sub = sub;
exports.subo = subo;
exports.mem = mem;
exports.is_empty = is_empty;
exports.iter = iter;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.count = count;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.iteri = iteri;
exports.existsi = existsi;
exports.for_alli = for_alli;
exports.counti = counti;
exports.findi = findi;
exports.find_mapi = find_mapi;
exports.hash_fold_t = hash_fold_t$1;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t$2;
exports.of_string = of_string;
exports.to_string = to_string;
exports.$great$eq = $great$eq;
exports.$less$eq = $less$eq;
exports.$eq = $eq;
exports.$great = $great;
exports.$less = $less;
exports.$less$great = $less$great;
exports.compare = compare$1;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.pp = pp;
exports.hashable = hashable;
exports.invariant = invariant;
exports.max_length = max_length;
exports.make = make;
exports.copy = copy;
exports.init = init;
exports.$caret = $caret;
exports.concat = concat;
exports.escaped = escaped;
exports.contains = contains;
exports.uppercase = uppercase;
exports.lowercase = lowercase;
exports.capitalize = capitalize;
exports.uncapitalize = uncapitalize;
exports.Caseless = Caseless;
exports.index = index;
exports.index_exn = index_exn;
exports.index_from = index_from;
exports.index_from_exn = index_from_exn;
exports.rindex = rindex;
exports.rindex_exn = rindex_exn;
exports.rindex_from = rindex_from;
exports.rindex_from_exn = rindex_from_exn;
exports.Search_pattern = Search_pattern;
exports.substr_index = substr_index;
exports.substr_index_exn = substr_index_exn;
exports.substr_index_all = substr_index_all;
exports.substr_replace_first = substr_replace_first;
exports.substr_replace_all = substr_replace_all;
exports.is_substring = is_substring;
exports.is_substring_at = is_substring_at$1;
exports.to_list_rev = to_list_rev;
exports.rev = rev;
exports.is_suffix = is_suffix$1;
exports.is_prefix = is_prefix$1;
exports.lsplit2_exn = lsplit2_exn;
exports.rsplit2_exn = rsplit2_exn;
exports.lsplit2 = lsplit2;
exports.rsplit2 = rsplit2;
exports.split = split;
exports.split_on_chars = split_on_chars;
exports.split_lines = split_lines;
exports.lfindi = lfindi;
exports.rfindi = rfindi;
exports.lstrip = lstrip;
exports.rstrip = rstrip;
exports.strip = strip;
exports.map = map;
exports.mapi = mapi;
exports.foldi = foldi;
exports.concat_map = concat_map;
exports.filter = filter;
exports.tr = tr;
exports.tr_multi = tr_multi;
exports.chop_suffix_exn = chop_suffix_exn;
exports.chop_prefix_exn = chop_prefix_exn;
exports.chop_suffix = chop_suffix;
exports.chop_prefix = chop_prefix;
exports.chop_suffix_if_exists = chop_suffix_if_exists;
exports.chop_prefix_if_exists = chop_prefix_if_exists;
exports.suffix = suffix;
exports.prefix = prefix;
exports.drop_suffix = drop_suffix;
exports.drop_prefix = drop_prefix;
exports.common_suffix = common_suffix;
exports.common_prefix = common_prefix;
exports.common_suffix_length = common_suffix_length;
exports.common_prefix_length = common_prefix_length;
exports.common_suffix2 = common_suffix2;
exports.common_prefix2 = common_prefix2;
exports.common_suffix2_length = common_suffix2_length;
exports.common_prefix2_length = common_prefix2_length;
exports.concat_array = concat_array;
exports.equal = equal$1;
exports.of_char = of_char;
exports.of_char_list = of_char_list;
exports.Escaping = Escaping;
/* include Not a pure module */
