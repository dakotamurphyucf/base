// Generated by Melange
'use strict';

var Caml = require("caml/./Caml.bs.js");
var Uchar = require("bs-platform/lib/js/uchar.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Poly0$negBase = require("./poly0.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Shadow_stdlib = require("shadow_stdlib/./src/shadow_stdlib.bs.js");
var Caml_external_polyfill = require("bs-platform/lib/js/caml_external_polyfill.js");

var Caml$1 = {
  invalid_arg: Pervasives.invalid_arg,
  failwith: Pervasives.failwith,
  Exit: Pervasives.Exit,
  min: Pervasives.min,
  max: Pervasives.max,
  abs: Pervasives.abs,
  max_int: Pervasives.max_int,
  min_int: Pervasives.min_int,
  lnot: Pervasives.lnot,
  infinity: Pervasives.infinity,
  neg_infinity: Pervasives.neg_infinity,
  nan: Pervasives.nan,
  max_float: Pervasives.max_float,
  min_float: Pervasives.min_float,
  epsilon_float: Pervasives.epsilon_float,
  $caret: Pervasives.$caret,
  char_of_int: Pervasives.char_of_int,
  string_of_bool: Pervasives.string_of_bool,
  bool_of_string: Pervasives.bool_of_string,
  bool_of_string_opt: Pervasives.bool_of_string_opt,
  string_of_int: Pervasives.string_of_int,
  int_of_string_opt: Pervasives.int_of_string_opt,
  string_of_float: Pervasives.string_of_float,
  float_of_string_opt: Pervasives.float_of_string_opt,
  $at: Pervasives.$at,
  stdin: Pervasives.stdin,
  stdout: Pervasives.stdout,
  stderr: Pervasives.stderr,
  print_char: Pervasives.print_char,
  print_string: Pervasives.print_string,
  print_bytes: Pervasives.print_bytes,
  print_int: Pervasives.print_int,
  print_float: Pervasives.print_float,
  print_endline: Pervasives.print_endline,
  print_newline: Pervasives.print_newline,
  prerr_char: Pervasives.prerr_char,
  prerr_string: Pervasives.prerr_string,
  prerr_bytes: Pervasives.prerr_bytes,
  prerr_int: Pervasives.prerr_int,
  prerr_float: Pervasives.prerr_float,
  prerr_endline: Pervasives.prerr_endline,
  prerr_newline: Pervasives.prerr_newline,
  read_line: Pervasives.read_line,
  read_int: Pervasives.read_int,
  read_int_opt: Pervasives.read_int_opt,
  read_float: Pervasives.read_float,
  read_float_opt: Pervasives.read_float_opt,
  open_out: Pervasives.open_out,
  open_out_bin: Pervasives.open_out_bin,
  open_out_gen: Pervasives.open_out_gen,
  flush: Pervasives.flush,
  flush_all: Pervasives.flush_all,
  output_char: Pervasives.output_char,
  output_string: Pervasives.output_string,
  output_bytes: Pervasives.output_bytes,
  output: Pervasives.output,
  output_substring: Pervasives.output_substring,
  output_byte: Pervasives.output_byte,
  output_binary_int: Pervasives.output_binary_int,
  output_value: Pervasives.output_value,
  seek_out: Pervasives.seek_out,
  pos_out: Pervasives.pos_out,
  out_channel_length: Pervasives.out_channel_length,
  close_out: Pervasives.close_out,
  close_out_noerr: Pervasives.close_out_noerr,
  set_binary_mode_out: Pervasives.set_binary_mode_out,
  open_in: Pervasives.open_in,
  open_in_bin: Pervasives.open_in_bin,
  open_in_gen: Pervasives.open_in_gen,
  input_char: Pervasives.input_char,
  input_line: Pervasives.input_line,
  input: Pervasives.input,
  really_input: Pervasives.really_input,
  really_input_string: Pervasives.really_input_string,
  input_byte: Pervasives.input_byte,
  input_binary_int: Pervasives.input_binary_int,
  input_value: Pervasives.input_value,
  seek_in: Pervasives.seek_in,
  pos_in: Pervasives.pos_in,
  in_channel_length: Pervasives.in_channel_length,
  close_in: Pervasives.close_in,
  close_in_noerr: Pervasives.close_in_noerr,
  set_binary_mode_in: Pervasives.set_binary_mode_in,
  string_of_format: Pervasives.string_of_format,
  $caret$caret: Pervasives.$caret$caret,
  exit: Pervasives.exit,
  at_exit: Pervasives.at_exit,
  valid_float_lexem: Pervasives.valid_float_lexem,
  do_at_exit: Pervasives.do_at_exit,
  Not_found: Caml.Not_found
};

function bool_to_int(x) {
  if (x) {
    return 1;
  } else {
    return 0;
  }
}

function $bang$eq(prim, prim$1) {
  return prim !== prim$1;
}

function $star(prim, prim$1) {
  return Math.imul(prim, prim$1);
}

function $star$star(prim, prim$1) {
  return Caml_external_polyfill.resolve("caml_power_float")(prim, prim$1);
}

function $star$dot(prim, prim$1) {
  return prim * prim$1;
}

function $plus(prim, prim$1) {
  return prim + prim$1 | 0;
}

function $plus$dot(prim, prim$1) {
  return prim + prim$1;
}

function $neg(prim, prim$1) {
  return prim - prim$1 | 0;
}

function $neg$dot(prim, prim$1) {
  return prim - prim$1;
}

var $slash = Caml_int32.div;

function $slash$dot(prim, prim$1) {
  return prim / prim$1;
}

function $less(x, y) {
  return x < y;
}

function $less$eq(x, y) {
  return x <= y;
}

function $less$great(x, y) {
  return x !== y;
}

function $eq(x, y) {
  return x === y;
}

function $great(x, y) {
  return x > y;
}

function $great$eq(x, y) {
  return x >= y;
}

function compare(x, y) {
  var x$1 = x > y;
  var x$2 = x < y;
  return (
          x$1 ? 1 : 0
        ) - (
          x$2 ? 1 : 0
        ) | 0;
}

var ascending = compare;

function descending(x, y) {
  return compare(y, x);
}

function equal(x, y) {
  return x === y;
}

function max(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var Int_replace_polymorphic_compare = {
  $less: $less,
  $less$eq: $less$eq,
  $less$great: $less$great,
  $eq: $eq,
  $great: $great,
  $great$eq: $great$eq,
  compare: compare,
  ascending: ascending,
  descending: descending,
  equal: equal,
  max: max,
  min: min
};

function $less$1(x, y) {
  return x < y;
}

function $less$eq$1(x, y) {
  return x <= y;
}

function $less$great$1(x, y) {
  return x !== y;
}

function $eq$1(x, y) {
  return x === y;
}

function $great$1(x, y) {
  return x > y;
}

function $great$eq$1(x, y) {
  return x >= y;
}

var ascending$1 = Poly0$negBase.ascending;

var descending$1 = Poly0$negBase.descending;

var compare$1 = Caml.caml_int_compare;

function equal$1(x, y) {
  return x === y;
}

function max$1(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min$1(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var Int32_replace_polymorphic_compare = {
  $less: $less$1,
  $less$eq: $less$eq$1,
  $less$great: $less$great$1,
  $eq: $eq$1,
  $great: $great$1,
  $great$eq: $great$eq$1,
  ascending: ascending$1,
  descending: descending$1,
  compare: compare$1,
  equal: equal$1,
  max: max$1,
  min: min$1
};

var $less$2 = Caml.i64_lt;

var $less$eq$2 = Caml.i64_le;

var $less$great$2 = Caml.i64_neq;

var $eq$2 = Caml.i64_eq;

var $great$2 = Caml.i64_gt;

var $great$eq$2 = Caml.i64_ge;

var ascending$2 = Poly0$negBase.ascending;

var descending$2 = Poly0$negBase.descending;

var compare$2 = Caml_int64.compare;

var equal$2 = Caml.i64_eq;

function max$2(x, y) {
  if (Caml.i64_ge(x, y)) {
    return x;
  } else {
    return y;
  }
}

function min$2(x, y) {
  if (Caml.i64_le(x, y)) {
    return x;
  } else {
    return y;
  }
}

var Int64_replace_polymorphic_compare = {
  $less: $less$2,
  $less$eq: $less$eq$2,
  $less$great: $less$great$2,
  $eq: $eq$2,
  $great: $great$2,
  $great$eq: $great$eq$2,
  ascending: ascending$2,
  descending: descending$2,
  compare: compare$2,
  equal: equal$2,
  max: max$2,
  min: min$2
};

function $less$3(x, y) {
  return x < y;
}

function $less$eq$3(x, y) {
  return x <= y;
}

function $less$great$3(x, y) {
  return x !== y;
}

function $eq$3(x, y) {
  return x === y;
}

function $great$3(x, y) {
  return x > y;
}

function $great$eq$3(x, y) {
  return x >= y;
}

var ascending$3 = Poly0$negBase.ascending;

var descending$3 = Poly0$negBase.descending;

var compare$3 = Caml.caml_int_compare;

function equal$3(x, y) {
  return x === y;
}

function max$3(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min$3(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var Nativeint_replace_polymorphic_compare = {
  $less: $less$3,
  $less$eq: $less$eq$3,
  $less$great: $less$great$3,
  $eq: $eq$3,
  $great: $great$3,
  $great$eq: $great$eq$3,
  ascending: ascending$3,
  descending: descending$3,
  compare: compare$3,
  equal: equal$3,
  max: max$3,
  min: min$3
};

function $less$4(x, y) {
  return x < y;
}

function $less$eq$4(x, y) {
  return x <= y;
}

function $less$great$4(x, y) {
  return x !== y;
}

function $eq$4(x, y) {
  return x === y;
}

function $great$4(x, y) {
  return x > y;
}

function $great$eq$4(x, y) {
  return x >= y;
}

var ascending$4 = Poly0$negBase.ascending;

var descending$4 = Poly0$negBase.descending;

var compare$4 = Caml.caml_int_compare;

function equal$4(x, y) {
  return x === y;
}

function max$4(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min$4(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var Bool_replace_polymorphic_compare = {
  $less: $less$4,
  $less$eq: $less$eq$4,
  $less$great: $less$great$4,
  $eq: $eq$4,
  $great: $great$4,
  $great$eq: $great$eq$4,
  ascending: ascending$4,
  descending: descending$4,
  compare: compare$4,
  equal: equal$4,
  max: max$4,
  min: min$4
};

function $less$5(x, y) {
  return x < y;
}

function $less$eq$5(x, y) {
  return x <= y;
}

function $less$great$5(x, y) {
  return x !== y;
}

function $eq$5(x, y) {
  return x === y;
}

function $great$5(x, y) {
  return x > y;
}

function $great$eq$5(x, y) {
  return x >= y;
}

var ascending$5 = Poly0$negBase.ascending;

var descending$5 = Poly0$negBase.descending;

var compare$5 = Caml.caml_int_compare;

function equal$5(x, y) {
  return x === y;
}

function max$5(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min$5(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var Char_replace_polymorphic_compare = {
  $less: $less$5,
  $less$eq: $less$eq$5,
  $less$great: $less$great$5,
  $eq: $eq$5,
  $great: $great$5,
  $great$eq: $great$eq$5,
  ascending: ascending$5,
  descending: descending$5,
  compare: compare$5,
  equal: equal$5,
  max: max$5,
  min: min$5
};

var i = Uchar.to_int;

function $less$6(x, y) {
  return Uchar.to_int(x) < Uchar.to_int(y);
}

function $less$eq$6(x, y) {
  return Uchar.to_int(x) <= Uchar.to_int(y);
}

function $less$great$6(x, y) {
  return Uchar.to_int(x) !== Uchar.to_int(y);
}

function $eq$6(x, y) {
  return Uchar.to_int(x) === Uchar.to_int(y);
}

function $great$6(x, y) {
  return Uchar.to_int(x) > Uchar.to_int(y);
}

function $great$eq$6(x, y) {
  return Uchar.to_int(x) >= Uchar.to_int(y);
}

function ascending$6(x, y) {
  return compare(Uchar.to_int(x), Uchar.to_int(y));
}

function descending$6(x, y) {
  return compare(Uchar.to_int(y), Uchar.to_int(x));
}

function compare$6(x, y) {
  return compare(Uchar.to_int(x), Uchar.to_int(y));
}

function equal$6(x, y) {
  return Uchar.to_int(x) === Uchar.to_int(y);
}

function max$6(x, y) {
  if ($great$eq$6(x, y)) {
    return x;
  } else {
    return y;
  }
}

function min$6(x, y) {
  if ($less$eq$6(x, y)) {
    return x;
  } else {
    return y;
  }
}

var Uchar_replace_polymorphic_compare = {
  i: i,
  $less: $less$6,
  $less$eq: $less$eq$6,
  $less$great: $less$great$6,
  $eq: $eq$6,
  $great: $great$6,
  $great$eq: $great$eq$6,
  ascending: ascending$6,
  descending: descending$6,
  compare: compare$6,
  equal: equal$6,
  max: max$6,
  min: min$6
};

function $less$7(x, y) {
  return x < y;
}

function $less$eq$7(x, y) {
  return x <= y;
}

function $less$great$7(x, y) {
  return x !== y;
}

function $eq$7(x, y) {
  return x === y;
}

function $great$7(x, y) {
  return x > y;
}

function $great$eq$7(x, y) {
  return x >= y;
}

var ascending$7 = Poly0$negBase.ascending;

var descending$7 = Poly0$negBase.descending;

var compare$7 = Caml.caml_float_compare;

function equal$7(x, y) {
  return x === y;
}

function max$7(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min$7(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var Float_replace_polymorphic_compare = {
  $less: $less$7,
  $less$eq: $less$eq$7,
  $less$great: $less$great$7,
  $eq: $eq$7,
  $great: $great$7,
  $great$eq: $great$eq$7,
  ascending: ascending$7,
  descending: descending$7,
  compare: compare$7,
  equal: equal$7,
  max: max$7,
  min: min$7
};

function $less$8(x, y) {
  return x < y;
}

function $less$eq$8(x, y) {
  return x <= y;
}

function $less$great$8(x, y) {
  return x !== y;
}

function $eq$8(x, y) {
  return x === y;
}

function $great$8(x, y) {
  return x > y;
}

function $great$eq$8(x, y) {
  return x >= y;
}

var ascending$8 = Poly0$negBase.ascending;

var descending$8 = Poly0$negBase.descending;

var compare$8 = Caml.caml_string_compare;

function equal$8(x, y) {
  return x === y;
}

function max$8(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function min$8(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

var String_replace_polymorphic_compare = {
  $less: $less$8,
  $less$eq: $less$eq$8,
  $less$great: $less$great$8,
  $eq: $eq$8,
  $great: $great$8,
  $great$eq: $great$eq$8,
  ascending: ascending$8,
  descending: descending$8,
  compare: compare$8,
  equal: equal$8,
  max: max$8,
  min: min$8
};

var $less$9 = Caml_bytes.caml_bytes_lessthan;

var $less$eq$9 = Caml_bytes.caml_bytes_lessequal;

function $less$great$9(x, y) {
  return Caml_external_polyfill.resolve("caml_bytes_notequal")(x, y);
}

var $eq$9 = Caml_bytes.caml_bytes_equal;

var $great$9 = Caml_bytes.caml_bytes_greaterthan;

var $great$eq$9 = Caml_bytes.caml_bytes_greaterequal;

var ascending$9 = Poly0$negBase.ascending;

var descending$9 = Poly0$negBase.descending;

var compare$9 = Caml_bytes.caml_bytes_compare;

var equal$9 = Caml_bytes.caml_bytes_equal;

function max$9(x, y) {
  if (Caml_bytes.caml_bytes_greaterequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

function min$9(x, y) {
  if (Caml_bytes.caml_bytes_lessequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

var Bytes_replace_polymorphic_compare = {
  $less: $less$9,
  $less$eq: $less$eq$9,
  $less$great: $less$great$9,
  $eq: $eq$9,
  $great: $great$9,
  $great$eq: $great$eq$9,
  ascending: ascending$9,
  descending: descending$9,
  compare: compare$9,
  equal: equal$9,
  max: max$9,
  min: min$9
};

function $tilde$neg(prim) {
  return -prim | 0;
}

function $tilde$neg$dot(prim) {
  return -prim;
}

function asr(prim, prim$1) {
  return (prim >> prim$1);
}

function land(prim, prim$1) {
  return prim & prim$1;
}

function lor(prim, prim$1) {
  return prim | prim$1;
}

function lsl(prim, prim$1) {
  return (prim << prim$1);
}

function lsr(prim, prim$1) {
  return (prim >>> prim$1) | 0;
}

function lxor(prim, prim$1) {
  return prim ^ prim$1;
}

var mod = Caml_int32.mod_;

function fst(prim) {
  return prim[0];
}

function snd(prim) {
  return prim[1];
}

function phys_equal(prim, prim$1) {
  return prim === prim$1;
}

function decr(prim) {
  prim.contents = prim.contents - 1 | 0;
  
}

function incr(prim) {
  prim.contents = prim.contents + 1 | 0;
  
}

var float_of_string = Caml_format.caml_float_of_string;

var am_testing = Caml_external_polyfill.resolve("Base_am_testing")(undefined);

var Exit = Shadow_stdlib.Exit;

var max_int = Shadow_stdlib.max_int;

var min_int = Shadow_stdlib.min_int;

var infinity = Shadow_stdlib.infinity;

var neg_infinity = Shadow_stdlib.neg_infinity;

var nan = Shadow_stdlib.nan;

var max_float = Shadow_stdlib.max_float;

var min_float = Shadow_stdlib.min_float;

var epsilon_float = Shadow_stdlib.epsilon_float;

var classify_float = Shadow_stdlib.classify_float;

var char_of_int = Shadow_stdlib.char_of_int;

var string_of_bool = Shadow_stdlib.string_of_bool;

var bool_of_string_opt = Shadow_stdlib.bool_of_string_opt;

var bool_of_string = Shadow_stdlib.bool_of_string;

var string_of_int = Shadow_stdlib.string_of_int;

var int_of_string_opt = Shadow_stdlib.int_of_string_opt;

var string_of_float = Shadow_stdlib.string_of_float;

var float_of_string_opt = Shadow_stdlib.float_of_string_opt;

var stdin = Shadow_stdlib.stdin;

var stdout = Shadow_stdlib.stdout;

var stderr = Shadow_stdlib.stderr;

var print_char = Shadow_stdlib.print_char;

var print_string = Shadow_stdlib.print_string;

var print_bytes = Shadow_stdlib.print_bytes;

var print_int = Shadow_stdlib.print_int;

var print_float = Shadow_stdlib.print_float;

var print_endline = Shadow_stdlib.print_endline;

var print_newline = Shadow_stdlib.print_newline;

var prerr_char = Shadow_stdlib.prerr_char;

var prerr_string = Shadow_stdlib.prerr_string;

var prerr_bytes = Shadow_stdlib.prerr_bytes;

var prerr_int = Shadow_stdlib.prerr_int;

var prerr_float = Shadow_stdlib.prerr_float;

var prerr_endline = Shadow_stdlib.prerr_endline;

var prerr_newline = Shadow_stdlib.prerr_newline;

var read_line = Shadow_stdlib.read_line;

var read_int_opt = Shadow_stdlib.read_int_opt;

var read_int = Shadow_stdlib.read_int;

var read_float_opt = Shadow_stdlib.read_float_opt;

var read_float = Shadow_stdlib.read_float;

var open_out = Shadow_stdlib.open_out;

var open_out_bin = Shadow_stdlib.open_out_bin;

var open_out_gen = Shadow_stdlib.open_out_gen;

var flush = Shadow_stdlib.flush;

var flush_all = Shadow_stdlib.flush_all;

var output_char = Shadow_stdlib.output_char;

var output_string = Shadow_stdlib.output_string;

var output_bytes = Shadow_stdlib.output_bytes;

var output = Shadow_stdlib.output;

var output_substring = Shadow_stdlib.output_substring;

var output_byte = Shadow_stdlib.output_byte;

var output_binary_int = Shadow_stdlib.output_binary_int;

var output_value = Shadow_stdlib.output_value;

var seek_out = Shadow_stdlib.seek_out;

var pos_out = Shadow_stdlib.pos_out;

var out_channel_length = Shadow_stdlib.out_channel_length;

var close_out = Shadow_stdlib.close_out;

var close_out_noerr = Shadow_stdlib.close_out_noerr;

var set_binary_mode_out = Shadow_stdlib.set_binary_mode_out;

var open_in = Shadow_stdlib.open_in;

var open_in_bin = Shadow_stdlib.open_in_bin;

var open_in_gen = Shadow_stdlib.open_in_gen;

var input_char = Shadow_stdlib.input_char;

var input_line = Shadow_stdlib.input_line;

var input = Shadow_stdlib.input;

var really_input = Shadow_stdlib.really_input;

var really_input_string = Shadow_stdlib.really_input_string;

var input_byte = Shadow_stdlib.input_byte;

var input_binary_int = Shadow_stdlib.input_binary_int;

var input_value = Shadow_stdlib.input_value;

var seek_in = Shadow_stdlib.seek_in;

var pos_in = Shadow_stdlib.pos_in;

var in_channel_length = Shadow_stdlib.in_channel_length;

var close_in = Shadow_stdlib.close_in;

var close_in_noerr = Shadow_stdlib.close_in_noerr;

var set_binary_mode_in = Shadow_stdlib.set_binary_mode_in;

var string_of_format = Shadow_stdlib.string_of_format;

var $caret$caret = Shadow_stdlib.$caret$caret;

var exit = Shadow_stdlib.exit;

var at_exit = Shadow_stdlib.at_exit;

var valid_float_lexem = Shadow_stdlib.valid_float_lexem;

var unsafe_really_input = Shadow_stdlib.unsafe_really_input;

var do_at_exit = Shadow_stdlib.do_at_exit;

var Not_found = Shadow_stdlib.Not_found;

var $at = Pervasives.$at;

var $caret = Pervasives.$caret;

var lnot = Pervasives.lnot;

var abs = Pervasives.abs;

var failwith = Pervasives.failwith;

var invalid_arg = Pervasives.invalid_arg;

exports.Exit = Exit;
exports.max_int = max_int;
exports.min_int = min_int;
exports.infinity = infinity;
exports.neg_infinity = neg_infinity;
exports.nan = nan;
exports.max_float = max_float;
exports.min_float = min_float;
exports.epsilon_float = epsilon_float;
exports.classify_float = classify_float;
exports.char_of_int = char_of_int;
exports.string_of_bool = string_of_bool;
exports.bool_of_string_opt = bool_of_string_opt;
exports.bool_of_string = bool_of_string;
exports.string_of_int = string_of_int;
exports.int_of_string_opt = int_of_string_opt;
exports.string_of_float = string_of_float;
exports.float_of_string_opt = float_of_string_opt;
exports.stdin = stdin;
exports.stdout = stdout;
exports.stderr = stderr;
exports.print_char = print_char;
exports.print_string = print_string;
exports.print_bytes = print_bytes;
exports.print_int = print_int;
exports.print_float = print_float;
exports.print_endline = print_endline;
exports.print_newline = print_newline;
exports.prerr_char = prerr_char;
exports.prerr_string = prerr_string;
exports.prerr_bytes = prerr_bytes;
exports.prerr_int = prerr_int;
exports.prerr_float = prerr_float;
exports.prerr_endline = prerr_endline;
exports.prerr_newline = prerr_newline;
exports.read_line = read_line;
exports.read_int_opt = read_int_opt;
exports.read_int = read_int;
exports.read_float_opt = read_float_opt;
exports.read_float = read_float;
exports.open_out = open_out;
exports.open_out_bin = open_out_bin;
exports.open_out_gen = open_out_gen;
exports.flush = flush;
exports.flush_all = flush_all;
exports.output_char = output_char;
exports.output_string = output_string;
exports.output_bytes = output_bytes;
exports.output = output;
exports.output_substring = output_substring;
exports.output_byte = output_byte;
exports.output_binary_int = output_binary_int;
exports.output_value = output_value;
exports.seek_out = seek_out;
exports.pos_out = pos_out;
exports.out_channel_length = out_channel_length;
exports.close_out = close_out;
exports.close_out_noerr = close_out_noerr;
exports.set_binary_mode_out = set_binary_mode_out;
exports.open_in = open_in;
exports.open_in_bin = open_in_bin;
exports.open_in_gen = open_in_gen;
exports.input_char = input_char;
exports.input_line = input_line;
exports.input = input;
exports.really_input = really_input;
exports.really_input_string = really_input_string;
exports.input_byte = input_byte;
exports.input_binary_int = input_binary_int;
exports.input_value = input_value;
exports.seek_in = seek_in;
exports.pos_in = pos_in;
exports.in_channel_length = in_channel_length;
exports.close_in = close_in;
exports.close_in_noerr = close_in_noerr;
exports.set_binary_mode_in = set_binary_mode_in;
exports.string_of_format = string_of_format;
exports.$caret$caret = $caret$caret;
exports.exit = exit;
exports.at_exit = at_exit;
exports.valid_float_lexem = valid_float_lexem;
exports.unsafe_really_input = unsafe_really_input;
exports.do_at_exit = do_at_exit;
exports.Not_found = Not_found;
exports.Caml = Caml$1;
exports.bool_to_int = bool_to_int;
exports.$bang$eq = $bang$eq;
exports.$star = $star;
exports.$star$star = $star$star;
exports.$star$dot = $star$dot;
exports.$plus = $plus;
exports.$plus$dot = $plus$dot;
exports.$neg = $neg;
exports.$neg$dot = $neg$dot;
exports.$slash = $slash;
exports.$slash$dot = $slash$dot;
exports.Int_replace_polymorphic_compare = Int_replace_polymorphic_compare;
exports.$less = $less;
exports.$less$eq = $less$eq;
exports.$less$great = $less$great;
exports.$eq = $eq;
exports.$great = $great;
exports.$great$eq = $great$eq;
exports.compare = compare;
exports.ascending = ascending;
exports.descending = descending;
exports.equal = equal;
exports.max = max;
exports.min = min;
exports.Int32_replace_polymorphic_compare = Int32_replace_polymorphic_compare;
exports.Int64_replace_polymorphic_compare = Int64_replace_polymorphic_compare;
exports.Nativeint_replace_polymorphic_compare = Nativeint_replace_polymorphic_compare;
exports.Bool_replace_polymorphic_compare = Bool_replace_polymorphic_compare;
exports.Char_replace_polymorphic_compare = Char_replace_polymorphic_compare;
exports.Uchar_replace_polymorphic_compare = Uchar_replace_polymorphic_compare;
exports.Float_replace_polymorphic_compare = Float_replace_polymorphic_compare;
exports.String_replace_polymorphic_compare = String_replace_polymorphic_compare;
exports.Bytes_replace_polymorphic_compare = Bytes_replace_polymorphic_compare;
exports.$at = $at;
exports.$caret = $caret;
exports.$tilde$neg = $tilde$neg;
exports.$tilde$neg$dot = $tilde$neg$dot;
exports.asr = asr;
exports.land = land;
exports.lnot = lnot;
exports.lor = lor;
exports.lsl = lsl;
exports.lsr = lsr;
exports.lxor = lxor;
exports.mod = mod;
exports.abs = abs;
exports.failwith = failwith;
exports.fst = fst;
exports.invalid_arg = invalid_arg;
exports.snd = snd;
exports.phys_equal = phys_equal;
exports.decr = decr;
exports.incr = incr;
exports.float_of_string = float_of_string;
exports.am_testing = am_testing;
/* am_testing Not a pure module */
