// Generated by Melange
'use strict';

var Obj = require("bs-platform/lib/js/obj.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Int$negBase = require("./int.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Error$negBase = require("./error.bs.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function sexp_of_t(_of_a, _of_b, param) {
  return {
          TAG: /* Atom */0,
          _0: "T"
        };
}

function sym(param) {
  return /* T */0;
}

function trans(param, param$1) {
  return /* T */0;
}

function conv(param, a) {
  return a;
}

function Lift(X) {
  var lift = function (param) {
    return /* T */0;
  };
  return {
          lift: lift
        };
}

function Lift2(X) {
  var lift = function (param, param$1) {
    return /* T */0;
  };
  return {
          lift: lift
        };
}

function Lift3(X) {
  var lift = function (param, param$1, param$2) {
    return /* T */0;
  };
  return {
          lift: lift
        };
}

function detuple2(param) {
  return [
          /* T */0,
          /* T */0
        ];
}

function tuple2(param, param$1) {
  return /* T */0;
}

function Composition_preserves_injectivity(M1, M2) {
  var strip = function (e) {
    return Curry._1(M1.strip, Curry._1(M2.strip, e));
  };
  return {
          strip: strip
        };
}

function sexp_of_t$1(sexp_of_a, M) {
  var t = {
    RE_EXN_ID: M.Key
  };
  var param = {
    NAME: "type_witness",
    VAL: Obj.extension_id(Obj.extension_constructor(t))
  };
  return {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* Atom */0,
              _0: "type_witness"
            },
            tl: {
              hd: Import$negBase.sexp_of_int(param.VAL),
              tl: /* [] */0
            }
          }
        };
}

function uid(M) {
  return Obj.extension_id(Obj.extension_constructor({
                  RE_EXN_ID: M.Key
                }));
}

function sexp_of_t$2(param, param$1) {
  var name = param$1.name;
  if (Import$negBase.am_testing) {
    return {
            TAG: /* Atom */0,
            _0: name
          };
  } else {
    return {
            TAG: /* List */1,
            _0: {
              hd: {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "name"
                  },
                  tl: {
                    hd: {
                      TAG: /* Atom */0,
                      _0: name
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* List */1,
                  _0: {
                    hd: {
                      TAG: /* Atom */0,
                      _0: "witness"
                    },
                    tl: {
                      hd: sexp_of_t$1(param$1.to_sexp, param$1.witness),
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          };
  }
}

function to_sexp(t) {
  return t.to_sexp;
}

function name(t) {
  return t.name;
}

function create(name, to_sexp) {
  var Key = /* @__PURE__ */Caml_exceptions.create("Key");
  return {
          witness: {
            Key: Key
          },
          name: name,
          to_sexp: to_sexp
        };
}

function uid$1(t) {
  return uid(t.witness);
}

function hash(t) {
  return uid(t.witness);
}

function hash_fold_t(s, t) {
  return Import$negBase.hash_fold_int(s, uid(t.witness));
}

function same_witness(t1, t2) {
  var a = t1.witness;
  var b = t2.witness;
  if (a.Key === b.Key) {
    return /* T */0;
  }
  
}

function same(t1, t2) {
  return Option$negBase.is_some(same_witness(t1, t2));
}

function same_witness_exn(t1, t2) {
  var w = same_witness(t1, t2);
  if (w !== undefined) {
    return w;
  } else {
    return Error$negBase.raise_s(Sexp$negBase.message("Type_equal.Id.same_witness_exn got different ids", {
                    hd: [
                      "",
                      Import$negBase.sexp_of_pair((function (param) {
                              return sexp_of_t$2(Import$negBase.sexp_of_opaque, param);
                            }), (function (param) {
                              return sexp_of_t$2(Import$negBase.sexp_of_opaque, param);
                            }), [
                            t1,
                            t2
                          ])
                    ],
                    tl: /* [] */0
                  }));
  }
}

var refl = /* T */0;

var Id_Uid = {
  hash_fold_t: Int$negBase.hash_fold_t,
  hash: Int$negBase.hash,
  t_of_sexp: Int$negBase.t_of_sexp,
  sexp_of_t: Int$negBase.sexp_of_t,
  $great$eq: Int$negBase.$great$eq,
  $less$eq: Int$negBase.$less$eq,
  $eq: Int$negBase.$eq,
  $great: Int$negBase.$great,
  $less: Int$negBase.$less,
  $less$great: Int$negBase.$less$great,
  equal: Int$negBase.equal,
  compare: Int$negBase.compare,
  min: Int$negBase.min,
  max: Int$negBase.max,
  ascending: Int$negBase.ascending,
  descending: Int$negBase.descending,
  between: Int$negBase.between,
  clamp_exn: Int$negBase.clamp_exn,
  clamp: Int$negBase.clamp,
  comparator: Int$negBase.comparator
};

var Id = {
  sexp_of_t: sexp_of_t$2,
  Uid: Id_Uid,
  uid: uid$1,
  create: create,
  hash: hash,
  name: name,
  to_sexp: to_sexp,
  hash_fold_t: hash_fold_t,
  same: same,
  same_witness: same_witness,
  same_witness_exn: same_witness_exn
};

exports.sexp_of_t = sexp_of_t;
exports.refl = refl;
exports.sym = sym;
exports.trans = trans;
exports.conv = conv;
exports.Lift = Lift;
exports.Lift2 = Lift2;
exports.Lift3 = Lift3;
exports.detuple2 = detuple2;
exports.tuple2 = tuple2;
exports.Composition_preserves_injectivity = Composition_preserves_injectivity;
exports.Id = Id;
/* Int-Base Not a pure module */
