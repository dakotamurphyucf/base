// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Hash$negBase = require("./hash.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var List1$negBase = require("./list1.bs.js");
var Monad$negBase = require("./monad.bs.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Result$negBase = require("./result.bs.js");
var Container$negBase = require("./container.bs.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var With_return$negBase = require("./with_return.bs.js");
var Ppx_compare_lib$negBase = require("./ppx_compare_lib.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

function sexp_of_t(_of_a, _of_s, v0) {
  if (typeof v0 === "number") {
    return {
            TAG: /* Atom */0,
            _0: "Done"
          };
  }
  if (v0.TAG === /* Skip */0) {
    var v0$1 = Curry._1(_of_s, v0._0);
    return {
            TAG: /* List */1,
            _0: {
              hd: {
                TAG: /* Atom */0,
                _0: "Skip"
              },
              tl: {
                hd: v0$1,
                tl: /* [] */0
              }
            }
          };
  }
  var v0$2 = Curry._1(_of_a, v0._0);
  var v1 = Curry._1(_of_s, v0._1);
  return {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* Atom */0,
              _0: "Yield"
            },
            tl: {
              hd: v0$2,
              tl: {
                hd: v1,
                tl: /* [] */0
              }
            }
          }
        };
}

var Step = {
  sexp_of_t: sexp_of_t
};

function next_step(param) {
  var f = param._1;
  var s = Curry._1(f, param._0);
  if (typeof s === "number") {
    return /* Done */0;
  } else if (s.TAG === /* Skip */0) {
    return {
            TAG: /* Skip */0,
            _0: /* Sequence */{
              _0: s._0,
              _1: f
            }
          };
  } else {
    return {
            TAG: /* Yield */1,
            _0: s._0,
            _1: /* Sequence */{
              _0: s._1,
              _1: f
            }
          };
  }
}

function delayed_fold_step(s, init, f, finish) {
  var loop = function (s, next, finish, f, acc) {
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return Curry._1(finish, acc);
    }
    if (s$1.TAG === /* Skip */0) {
      var s$2 = s$1._0;
      return Curry._3(f, acc, undefined, (function (param) {
                    return loop(s$2, next, finish, f, param);
                  }));
    }
    var s$3 = s$1._1;
    return Curry._3(f, acc, Caml_option.some(s$1._0), (function (param) {
                  return loop(s$3, next, finish, f, param);
                }));
  };
  return loop(s._0, s._1, finish, f, init);
}

var Expert = {
  next_step: next_step,
  delayed_fold_step: delayed_fold_step
};

function unfold_step(init, f) {
  return /* Sequence */{
          _0: init,
          _1: f
        };
}

function unfold(init, f) {
  return /* Sequence */{
          _0: init,
          _1: (function (s) {
              var match = Curry._1(f, s);
              if (match !== undefined) {
                return {
                        TAG: /* Yield */1,
                        _0: match[0],
                        _1: match[1]
                      };
              } else {
                return /* Done */0;
              }
            })
        };
}

function unfold_with(s, init, f) {
  var next = s._1;
  return /* Sequence */{
          _0: [
            init,
            s._0
          ],
          _1: (function (param) {
              var seed = param[0];
              var s = Curry._1(next, param[1]);
              if (typeof s === "number") {
                return /* Done */0;
              }
              if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          seed,
                          s._0
                        ]
                      };
              }
              var s$1 = s._1;
              var seed$1 = Curry._2(f, seed, s._0);
              if (typeof seed$1 === "number") {
                return /* Done */0;
              } else if (seed$1.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          seed$1._0,
                          s$1
                        ]
                      };
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: seed$1._0,
                        _1: [
                          seed$1._1,
                          s$1
                        ]
                      };
              }
            })
        };
}

function unfold_with_and_finish(s, init, running_step, inner_finished, finishing_step) {
  var next = s._1;
  return /* Sequence */{
          _0: {
            NAME: "Inner_running",
            VAL: [
              init,
              s._0
            ]
          },
          _1: (function (state) {
              if (state.NAME === "Inner_finished") {
                var state$1 = Curry._1(finishing_step, state.VAL);
                if (typeof state$1 === "number") {
                  return /* Done */0;
                } else if (state$1.TAG === /* Skip */0) {
                  return {
                          TAG: /* Skip */0,
                          _0: {
                            NAME: "Inner_finished",
                            VAL: state$1._0
                          }
                        };
                } else {
                  return {
                          TAG: /* Yield */1,
                          _0: state$1._0,
                          _1: {
                            NAME: "Inner_finished",
                            VAL: state$1._1
                          }
                        };
                }
              }
              var match = state.VAL;
              var state$2 = match[0];
              var inner_state = Curry._1(next, match[1]);
              if (typeof inner_state === "number") {
                return {
                        TAG: /* Skip */0,
                        _0: {
                          NAME: "Inner_finished",
                          VAL: Curry._1(inner_finished, state$2)
                        }
                      };
              }
              if (inner_state.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: {
                          NAME: "Inner_running",
                          VAL: [
                            state$2,
                            inner_state._0
                          ]
                        }
                      };
              }
              var inner_state$1 = inner_state._1;
              var state$3 = Curry._2(running_step, state$2, inner_state._0);
              if (typeof state$3 === "number") {
                return /* Done */0;
              } else if (state$3.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: {
                          NAME: "Inner_running",
                          VAL: [
                            state$3._0,
                            inner_state$1
                          ]
                        }
                      };
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: state$3._0,
                        _1: {
                          NAME: "Inner_running",
                          VAL: [
                            state$3._1,
                            inner_state$1
                          ]
                        }
                      };
              }
            })
        };
}

function of_list(l) {
  return /* Sequence */{
          _0: l,
          _1: (function (param) {
              if (param) {
                return {
                        TAG: /* Yield */1,
                        _0: param.hd,
                        _1: param.tl
                      };
              } else {
                return /* Done */0;
              }
            })
        };
}

function fold(t, init, f) {
  var _seed = t._0;
  var _v = init;
  var next = t._1;
  while(true) {
    var v = _v;
    var seed = _seed;
    var s = Curry._1(next, seed);
    if (typeof s === "number") {
      return v;
    }
    if (s.TAG === /* Skip */0) {
      _seed = s._0;
      continue ;
    }
    _v = Curry._2(f, v, s._0);
    _seed = s._1;
    continue ;
  };
}

function to_list_rev(t) {
  return fold(t, /* [] */0, (function (l, x) {
                return {
                        hd: x,
                        tl: l
                      };
              }));
}

function to_list(param) {
  var to_list$1 = function (_s, next, i) {
    while(true) {
      var s = _s;
      if (i === 0) {
        return List1$negBase.rev(to_list_rev(/* Sequence */{
                        _0: s,
                        _1: next
                      }));
      }
      var s$1 = Curry._1(next, s);
      if (typeof s$1 === "number") {
        return /* [] */0;
      }
      if (s$1.TAG !== /* Skip */0) {
        return {
                hd: s$1._0,
                tl: to_list$1(s$1._1, next, Import$negBase.$neg(i, 1))
              };
      }
      _s = s$1._0;
      continue ;
    };
  };
  return to_list$1(param._0, param._1, 500);
}

function sexp_of_t$1(sexp_of_a, t) {
  return Import$negBase.sexp_of_list(sexp_of_a, to_list(t));
}

function range(strideOpt, startOpt, stopOpt, start_v, stop_v) {
  var stride = strideOpt !== undefined ? strideOpt : 1;
  var start = startOpt !== undefined ? startOpt : "inclusive";
  var stop = stopOpt !== undefined ? stopOpt : "exclusive";
  var step = stop === "inclusive" ? (
      Import$negBase.$great$eq(stride, 0) ? (function (i) {
            if (Import$negBase.$great(i, stop_v)) {
              return /* Done */0;
            } else {
              return {
                      TAG: /* Yield */1,
                      _0: i,
                      _1: Import$negBase.$plus(i, stride)
                    };
            }
          }) : (function (i) {
            if (Import$negBase.$less(i, stop_v)) {
              return /* Done */0;
            } else {
              return {
                      TAG: /* Yield */1,
                      _0: i,
                      _1: Import$negBase.$plus(i, stride)
                    };
            }
          })
    ) : (
      Import$negBase.$great$eq(stride, 0) ? (function (i) {
            if (Import$negBase.$great$eq(i, stop_v)) {
              return /* Done */0;
            } else {
              return {
                      TAG: /* Yield */1,
                      _0: i,
                      _1: Import$negBase.$plus(i, stride)
                    };
            }
          }) : (function (i) {
            if (Import$negBase.$less$eq(i, stop_v)) {
              return /* Done */0;
            } else {
              return {
                      TAG: /* Yield */1,
                      _0: i,
                      _1: Import$negBase.$plus(i, stride)
                    };
            }
          })
    );
  var init = start === "inclusive" ? start_v : Import$negBase.$plus(start_v, stride);
  return /* Sequence */{
          _0: init,
          _1: step
        };
}

function of_lazy(t_lazy) {
  return /* Sequence */{
          _0: t_lazy,
          _1: (function (t_lazy) {
              var match = CamlinternalLazy.force(t_lazy);
              var next = match._1;
              var s = Curry._1(next, match._0);
              if (typeof s === "number") {
                return /* Done */0;
              }
              if (s.TAG === /* Skip */0) {
                var v_0 = s._0;
                var v = /* Sequence */{
                  _0: v_0,
                  _1: next
                };
                return {
                        TAG: /* Skip */0,
                        _0: {
                          LAZY_DONE: true,
                          VAL: v
                        }
                      };
              }
              var v_0$1 = s._1;
              var v$1 = /* Sequence */{
                _0: v_0$1,
                _1: next
              };
              return {
                      TAG: /* Yield */1,
                      _0: s._0,
                      _1: {
                        LAZY_DONE: true,
                        VAL: v$1
                      }
                    };
            })
        };
}

function map(t, f) {
  var next = t._1;
  return /* Sequence */{
          _0: t._0,
          _1: (function (seed) {
              var s = Curry._1(next, seed);
              if (typeof s === "number") {
                return /* Done */0;
              } else if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: s._0
                      };
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: Curry._1(f, s._0),
                        _1: s._1
                      };
              }
            })
        };
}

function mapi(t, f) {
  var next = t._1;
  return /* Sequence */{
          _0: [
            0,
            t._0
          ],
          _1: (function (param) {
              var i = param[0];
              var s = Curry._1(next, param[1]);
              if (typeof s === "number") {
                return /* Done */0;
              } else if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          i,
                          s._0
                        ]
                      };
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: Curry._2(f, i, s._0),
                        _1: [
                          Import$negBase.$plus(i, 1),
                          s._1
                        ]
                      };
              }
            })
        };
}

function folding_map(t, init, f) {
  return unfold_with(t, init, (function (acc, x) {
                var match = Curry._2(f, acc, x);
                return {
                        TAG: /* Yield */1,
                        _0: match[1],
                        _1: match[0]
                      };
              }));
}

function folding_mapi(t, init, f) {
  return unfold_with(t, [
              0,
              init
            ], (function (param, x) {
                var i = param[0];
                var match = Curry._3(f, i, param[1], x);
                return {
                        TAG: /* Yield */1,
                        _0: match[1],
                        _1: [
                          Import$negBase.$plus(i, 1),
                          match[0]
                        ]
                      };
              }));
}

function filter(t, f) {
  var next = t._1;
  return /* Sequence */{
          _0: t._0,
          _1: (function (seed) {
              var s = Curry._1(next, seed);
              if (typeof s === "number") {
                return /* Done */0;
              }
              if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: s._0
                      };
              }
              var a = s._0;
              if (Curry._1(f, a)) {
                return {
                        TAG: /* Yield */1,
                        _0: a,
                        _1: s._1
                      };
              } else {
                return {
                        TAG: /* Skip */0,
                        _0: s._1
                      };
              }
            })
        };
}

function filteri(t, f) {
  return map(filter(mapi(t, (function (i, s) {
                        return [
                                i,
                                s
                              ];
                      })), (function (param) {
                    return Curry._2(f, param[0], param[1]);
                  })), Import$negBase.snd);
}

function length(t) {
  var _i = 0;
  var _s = t._0;
  var next = t._1;
  while(true) {
    var s = _s;
    var i = _i;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return i;
    }
    if (s$1.TAG === /* Skip */0) {
      _s = s$1._0;
      continue ;
    }
    _s = s$1._1;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function to_list_rev_with_length(t) {
  return fold(t, [
              /* [] */0,
              0
            ], (function (param, x) {
                return [
                        {
                          hd: x,
                          tl: param[0]
                        },
                        Import$negBase.$plus(param[1], 1)
                      ];
              }));
}

function to_array(t) {
  var match = to_list_rev_with_length(t);
  var l = match[0];
  if (!l) {
    return [];
  }
  var len = match[1];
  var a = Array0$negBase.create(len, l.hd);
  var loop = function (_i, _l) {
    while(true) {
      var l = _l;
      var i = _i;
      if (l) {
        Caml_array.set(a, i, l.hd);
        _l = l.tl;
        _i = Import$negBase.$neg(i, 1);
        continue ;
      }
      if (i === -1) {
        return ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "sequence.ml",
              256,
              14
            ],
            Error: new Error()
          };
    };
  };
  loop(Import$negBase.$neg(len, 2), l.tl);
  return a;
}

function find(t, f) {
  var _s = t._0;
  var next = t._1;
  while(true) {
    var s = _s;
    var match = Curry._1(next, s);
    if (typeof match === "number") {
      return ;
    }
    if (match.TAG === /* Skip */0) {
      _s = match._0;
      continue ;
    }
    var a = match._0;
    if (Curry._1(f, a)) {
      return Caml_option.some(a);
    }
    _s = match._1;
    continue ;
  };
}

function find_map(t, f) {
  var _s = t._0;
  var next = t._1;
  while(true) {
    var s = _s;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return ;
    }
    if (s$1.TAG === /* Skip */0) {
      _s = s$1._0;
      continue ;
    }
    var some_b = Curry._1(f, s$1._0);
    if (some_b !== undefined) {
      return some_b;
    }
    _s = s$1._1;
    continue ;
  };
}

function find_mapi(t, f) {
  var _s = t._0;
  var next = t._1;
  var _i = 0;
  while(true) {
    var i = _i;
    var s = _s;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return ;
    }
    if (s$1.TAG === /* Skip */0) {
      _s = s$1._0;
      continue ;
    }
    var some_b = Curry._2(f, i, s$1._0);
    if (some_b !== undefined) {
      return some_b;
    }
    _i = Import$negBase.$plus(i, 1);
    _s = s$1._1;
    continue ;
  };
}

function for_all(t, f) {
  var _s = t._0;
  var next = t._1;
  while(true) {
    var s = _s;
    var match = Curry._1(next, s);
    if (typeof match === "number") {
      return true;
    }
    if (match.TAG === /* Skip */0) {
      _s = match._0;
      continue ;
    }
    if (!Curry._1(f, match._0)) {
      return false;
    }
    _s = match._1;
    continue ;
  };
}

function for_alli(t, f) {
  var _s = t._0;
  var next = t._1;
  var _i = 0;
  while(true) {
    var i = _i;
    var s = _s;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return true;
    }
    if (s$1.TAG === /* Skip */0) {
      _s = s$1._0;
      continue ;
    }
    if (!Curry._2(f, i, s$1._0)) {
      return false;
    }
    _i = Import$negBase.$plus(i, 1);
    _s = s$1._1;
    continue ;
  };
}

function exists(t, f) {
  var _s = t._0;
  var next = t._1;
  while(true) {
    var s = _s;
    var match = Curry._1(next, s);
    if (typeof match === "number") {
      return false;
    }
    if (match.TAG === /* Skip */0) {
      _s = match._0;
      continue ;
    }
    if (Curry._1(f, match._0)) {
      return true;
    }
    _s = match._1;
    continue ;
  };
}

function existsi(t, f) {
  var _s = t._0;
  var next = t._1;
  var _i = 0;
  while(true) {
    var i = _i;
    var s = _s;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return false;
    }
    if (s$1.TAG === /* Skip */0) {
      _s = s$1._0;
      continue ;
    }
    if (Curry._2(f, i, s$1._0)) {
      return true;
    }
    _i = Import$negBase.$plus(i, 1);
    _s = s$1._1;
    continue ;
  };
}

function iter(t, f) {
  var _seed = t._0;
  var next = t._1;
  while(true) {
    var seed = _seed;
    var s = Curry._1(next, seed);
    if (typeof s === "number") {
      return ;
    }
    if (s.TAG === /* Skip */0) {
      _seed = s._0;
      continue ;
    }
    Curry._1(f, s._0);
    _seed = s._1;
    continue ;
  };
}

function is_empty(t) {
  var _s = t._0;
  var next = t._1;
  while(true) {
    var s = _s;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return true;
    }
    if (s$1.TAG !== /* Skip */0) {
      return false;
    }
    _s = s$1._0;
    continue ;
  };
}

function mem(t, a, equal) {
  var _s = t._0;
  var next = t._1;
  while(true) {
    var s = _s;
    var match = Curry._1(next, s);
    if (typeof match === "number") {
      return false;
    }
    if (match.TAG === /* Skip */0) {
      _s = match._0;
      continue ;
    }
    if (Curry._2(equal, a, match._0)) {
      return true;
    }
    _s = match._1;
    continue ;
  };
}

function empty_1(param) {
  return /* Done */0;
}

var empty = /* Sequence */{
  _0: undefined,
  _1: empty_1
};

function bind(t, f) {
  return /* Sequence */{
          _0: [
            empty,
            t
          ],
          _1: (function (param) {
              var rest = param[1];
              var match = param[0];
              var next = match._1;
              var s = Curry._1(next, match._0);
              if (typeof s !== "number") {
                if (s.TAG === /* Skip */0) {
                  return {
                          TAG: /* Skip */0,
                          _0: [
                            /* Sequence */{
                              _0: s._0,
                              _1: next
                            },
                            rest
                          ]
                        };
                } else {
                  return {
                          TAG: /* Yield */1,
                          _0: s._0,
                          _1: [
                            /* Sequence */{
                              _0: s._1,
                              _1: next
                            },
                            rest
                          ]
                        };
                }
              }
              var next$1 = rest._1;
              var s$1 = Curry._1(next$1, rest._0);
              if (typeof s$1 === "number") {
                return /* Done */0;
              } else if (s$1.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          empty,
                          /* Sequence */{
                            _0: s$1._0,
                            _1: next$1
                          }
                        ]
                      };
              } else {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          Curry._1(f, s$1._0),
                          /* Sequence */{
                            _0: s$1._1,
                            _1: next$1
                          }
                        ]
                      };
              }
            })
        };
}

function $$return(x) {
  return /* Sequence */{
          _0: Caml_option.some(x),
          _1: (function (x) {
              if (x !== undefined) {
                return {
                        TAG: /* Yield */1,
                        _0: Caml_option.valFromOption(x),
                        _1: undefined
                      };
              } else {
                return /* Done */0;
              }
            })
        };
}

var map$1 = {
  NAME: "Custom",
  VAL: map
};

var include = Monad$negBase.Make({
      bind: bind,
      $$return: $$return,
      map: map$1
    });

var bind$1 = include.bind;

var $$return$1 = include.$$return;

var map$2 = include.map;

function nth(s, n) {
  if (Import$negBase.$less(n, 0)) {
    return ;
  }
  var _i = n;
  var _s = s._0;
  var next = s._1;
  while(true) {
    var s$1 = _s;
    var i = _i;
    var s$2 = Curry._1(next, s$1);
    if (typeof s$2 === "number") {
      return ;
    }
    if (s$2.TAG === /* Skip */0) {
      _s = s$2._0;
      continue ;
    }
    if (Import$negBase.phys_equal(i, 0)) {
      return Caml_option.some(s$2._0);
    }
    _s = s$2._1;
    _i = Import$negBase.$neg(i, 1);
    continue ;
  };
}

function nth_exn(s, n) {
  if (Import$negBase.$less(n, 0)) {
    return Import$negBase.invalid_arg("Sequence.nth");
  }
  var x = nth(s, n);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return Import$negBase.failwith("Sequence.nth");
  }
}

function compare(_cmp__a, _cmp__b, a__001_, b__002_) {
  if (Ppx_compare_lib$negBase.phys_equal(a__001_, b__002_)) {
    return 0;
  }
  switch (a__001_.TAG | 0) {
    case /* Left */0 :
        switch (b__002_.TAG | 0) {
          case /* Left */0 :
              return Curry._2(_cmp__a, a__001_._0, b__002_._0);
          case /* Right */1 :
          case /* Both */2 :
              return -1;
          
        }
    case /* Right */1 :
        switch (b__002_.TAG | 0) {
          case /* Left */0 :
              return 1;
          case /* Right */1 :
              return Curry._2(_cmp__b, a__001_._0, b__002_._0);
          case /* Both */2 :
              return -1;
          
        }
    case /* Both */2 :
        switch (b__002_.TAG | 0) {
          case /* Left */0 :
          case /* Right */1 :
              return 1;
          case /* Both */2 :
              var n = Curry._2(_cmp__a, a__001_._0, b__002_._0);
              if (n !== 0) {
                return n;
              } else {
                return Curry._2(_cmp__b, a__001_._1, b__002_._1);
              }
          
        }
    
  }
}

function hash_fold_t(_hash_fold_a, _hash_fold_b, hsv, arg) {
  switch (arg.TAG | 0) {
    case /* Left */0 :
        var hsv$1 = Hash$negBase.fold_int(hsv, 0);
        return Curry._2(_hash_fold_a, hsv$1, arg._0);
    case /* Right */1 :
        var hsv$2 = Hash$negBase.fold_int(hsv, 1);
        return Curry._2(_hash_fold_b, hsv$2, arg._0);
    case /* Both */2 :
        var hsv$3 = Hash$negBase.fold_int(hsv, 2);
        var hsv$4 = Curry._2(_hash_fold_a, hsv$3, arg._0);
        return Curry._2(_hash_fold_b, hsv$4, arg._1);
    
  }
}

var _tp_loc = "sequence.ml.Merge_with_duplicates_element.t";

function t_of_sexp(_of_a, _of_b, _sexp) {
  if (_sexp.TAG === /* Atom */0) {
    switch (_sexp._0) {
      case "Both" :
      case "Left" :
      case "Right" :
      case "both" :
      case "left" :
      case "right" :
          return Sexp_conv_error$negSexplib0.stag_takes_args(_tp_loc, _sexp);
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, _sexp);
    }
  } else {
    var match = _sexp._0;
    if (!match) {
      return Sexp_conv_error$negSexplib0.empty_list_invalid_sum(_tp_loc, _sexp);
    }
    var _tag = match.hd;
    if (_tag.TAG !== /* Atom */0) {
      return Sexp_conv_error$negSexplib0.nested_list_invalid_sum(_tp_loc, _sexp);
    }
    var _tag$1 = _tag._0;
    var exit = 0;
    switch (_tag$1) {
      case "Both" :
      case "both" :
          exit = 3;
          break;
      case "Left" :
      case "left" :
          exit = 1;
          break;
      case "Right" :
      case "right" :
          exit = 2;
          break;
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, _sexp);
    }
    switch (exit) {
      case 1 :
          var sexp_args = match.tl;
          if (!sexp_args) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          if (sexp_args.tl) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var v0 = Curry._1(_of_a, sexp_args.hd);
          return {
                  TAG: /* Left */0,
                  _0: v0
                };
      case 2 :
          var sexp_args$1 = match.tl;
          if (!sexp_args$1) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          if (sexp_args$1.tl) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var v0$1 = Curry._1(_of_b, sexp_args$1.hd);
          return {
                  TAG: /* Right */1,
                  _0: v0$1
                };
      case 3 :
          var sexp_args$2 = match.tl;
          if (!sexp_args$2) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var match$1 = sexp_args$2.tl;
          if (!match$1) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          if (match$1.tl) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var v0$2 = Curry._1(_of_a, sexp_args$2.hd);
          var v1 = Curry._1(_of_b, match$1.hd);
          return {
                  TAG: /* Both */2,
                  _0: v0$2,
                  _1: v1
                };
      
    }
  }
}

function sexp_of_t$2(_of_a, _of_b, v0) {
  switch (v0.TAG | 0) {
    case /* Left */0 :
        var v0$1 = Curry._1(_of_a, v0._0);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Left"
                  },
                  tl: {
                    hd: v0$1,
                    tl: /* [] */0
                  }
                }
              };
    case /* Right */1 :
        var v0$2 = Curry._1(_of_b, v0._0);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Right"
                  },
                  tl: {
                    hd: v0$2,
                    tl: /* [] */0
                  }
                }
              };
    case /* Both */2 :
        var v0$3 = Curry._1(_of_a, v0._0);
        var v1 = Curry._1(_of_b, v0._1);
        return {
                TAG: /* List */1,
                _0: {
                  hd: {
                    TAG: /* Atom */0,
                    _0: "Both"
                  },
                  tl: {
                    hd: v0$3,
                    tl: {
                      hd: v1,
                      tl: /* [] */0
                    }
                  }
                }
              };
    
  }
}

function t_sexp_grammar(_$pa_sexp_grammar, _$pb_sexp_grammar) {
  return {
          TAG: /* Variant */4,
          _0: {
            name_kind: /* Capitalized */1,
            clauses: {
              hd: {
                name: "Left",
                args: {
                  TAG: /* Cons */0,
                  _0: _$pa_sexp_grammar,
                  _1: /* Empty */0
                }
              },
              tl: {
                hd: {
                  name: "Right",
                  args: {
                    TAG: /* Cons */0,
                    _0: _$pb_sexp_grammar,
                    _1: /* Empty */0
                  }
                },
                tl: {
                  hd: {
                    name: "Both",
                    args: {
                      TAG: /* Cons */0,
                      _0: _$pa_sexp_grammar,
                      _1: {
                        TAG: /* Cons */0,
                        _0: _$pb_sexp_grammar,
                        _1: /* Empty */0
                      }
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        };
}

var Merge_with_duplicates_element = {
  compare: compare,
  hash_fold_t: hash_fold_t,
  t_of_sexp: t_of_sexp,
  sexp_of_t: sexp_of_t$2,
  t_sexp_grammar: t_sexp_grammar
};

function merge_with_duplicates(param, param$1, compare) {
  var next2 = param$1._1;
  var next1 = param._1;
  var next = function (param) {
    var s1 = param[0];
    if (typeof s1 === "number") {
      var match = param[1];
      if (typeof match === "number") {
        return /* Done */0;
      }
      if (match.TAG !== /* Skip */0) {
        return {
                TAG: /* Yield */1,
                _0: {
                  TAG: /* Right */1,
                  _0: match._0
                },
                _1: [
                  /* Done */0,
                  {
                    TAG: /* Skip */0,
                    _0: match._1
                  }
                ]
              };
      }
      
    } else {
      if (s1.TAG === /* Skip */0) {
        return {
                TAG: /* Skip */0,
                _0: [
                  Curry._1(next1, s1._0),
                  param[1]
                ]
              };
      }
      var s2 = param[1];
      var s1$p = s1._1;
      var a = s1._0;
      if (typeof s2 === "number") {
        return {
                TAG: /* Yield */1,
                _0: {
                  TAG: /* Left */0,
                  _0: a
                },
                _1: [
                  {
                    TAG: /* Skip */0,
                    _0: s1$p
                  },
                  /* Done */0
                ]
              };
      }
      if (s2.TAG !== /* Skip */0) {
        var s2$p = s2._1;
        var b = s2._0;
        var comparison = Curry._2(compare, a, b);
        if (Import$negBase.$less(comparison, 0)) {
          return {
                  TAG: /* Yield */1,
                  _0: {
                    TAG: /* Left */0,
                    _0: a
                  },
                  _1: [
                    {
                      TAG: /* Skip */0,
                      _0: s1$p
                    },
                    s2
                  ]
                };
        } else if (comparison === 0) {
          return {
                  TAG: /* Yield */1,
                  _0: {
                    TAG: /* Both */2,
                    _0: a,
                    _1: b
                  },
                  _1: [
                    {
                      TAG: /* Skip */0,
                      _0: s1$p
                    },
                    {
                      TAG: /* Skip */0,
                      _0: s2$p
                    }
                  ]
                };
        } else {
          return {
                  TAG: /* Yield */1,
                  _0: {
                    TAG: /* Right */1,
                    _0: b
                  },
                  _1: [
                    s1,
                    {
                      TAG: /* Skip */0,
                      _0: s2$p
                    }
                  ]
                };
        }
      }
      
    }
    return {
            TAG: /* Skip */0,
            _0: [
              s1,
              Curry._1(next2, param[1]._0)
            ]
          };
  };
  return /* Sequence */{
          _0: [
            {
              TAG: /* Skip */0,
              _0: param._0
            },
            {
              TAG: /* Skip */0,
              _0: param$1._0
            }
          ],
          _1: next
        };
}

function merge(s1, s2, compare) {
  return Curry._2(map$2, merge_with_duplicates(s1, s2, compare), (function (param) {
                return param._0;
              }));
}

function hd(s) {
  var _s = s._0;
  var next = s._1;
  while(true) {
    var s$1 = _s;
    var s$2 = Curry._1(next, s$1);
    if (typeof s$2 === "number") {
      return ;
    }
    if (s$2.TAG !== /* Skip */0) {
      return Caml_option.some(s$2._0);
    }
    _s = s$2._0;
    continue ;
  };
}

function hd_exn(s) {
  var a = hd(s);
  if (a !== undefined) {
    return Caml_option.valFromOption(a);
  } else {
    return Import$negBase.failwith("hd_exn");
  }
}

function tl(s) {
  var loop = function (_s, next) {
    while(true) {
      var s = _s;
      var s$1 = Curry._1(next, s);
      if (typeof s$1 === "number") {
        return ;
      }
      if (s$1.TAG !== /* Skip */0) {
        return Caml_option.some(s$1._1);
      }
      _s = s$1._0;
      continue ;
    };
  };
  var next = s._1;
  var s$1 = loop(s._0, next);
  if (s$1 !== undefined) {
    return /* Sequence */{
            _0: Caml_option.valFromOption(s$1),
            _1: next
          };
  }
  
}

function tl_eagerly_exn(s) {
  var s$1 = tl(s);
  if (s$1 !== undefined) {
    return s$1;
  } else {
    return Import$negBase.failwith("Sequence.tl_exn");
  }
}

function lift_identity(next, s) {
  var s$1 = Curry._1(next, s);
  if (typeof s$1 === "number") {
    return /* Done */0;
  } else if (s$1.TAG === /* Skip */0) {
    return {
            TAG: /* Skip */0,
            _0: {
              NAME: "Identity",
              VAL: s$1._0
            }
          };
  } else {
    return {
            TAG: /* Yield */1,
            _0: s$1._0,
            _1: {
              NAME: "Identity",
              VAL: s$1._1
            }
          };
  }
}

function next(s) {
  var _s = s._0;
  var next$1 = s._1;
  while(true) {
    var s$1 = _s;
    var s$2 = Curry._1(next$1, s$1);
    if (typeof s$2 === "number") {
      return ;
    }
    if (s$2.TAG !== /* Skip */0) {
      return [
              s$2._0,
              /* Sequence */{
                _0: s$2._1,
                _1: next$1
              }
            ];
    }
    _s = s$2._0;
    continue ;
  };
}

function filter_opt(s) {
  var next = s._1;
  return /* Sequence */{
          _0: s._0,
          _1: (function (s) {
              var s$1 = Curry._1(next, s);
              if (typeof s$1 === "number") {
                return /* Done */0;
              }
              if (s$1.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: s$1._0
                      };
              }
              var a = s$1._0;
              if (a !== undefined) {
                return {
                        TAG: /* Yield */1,
                        _0: Caml_option.valFromOption(a),
                        _1: s$1._1
                      };
              } else {
                return {
                        TAG: /* Skip */0,
                        _0: s$1._1
                      };
              }
            })
        };
}

function filter_map(s, f) {
  return filter_opt(Curry._2(map$2, s, f));
}

function filter_mapi(s, f) {
  var s$1 = mapi(s, (function (i, s) {
          return [
                  i,
                  s
                ];
        }));
  return filter_opt(Curry._2(map$2, s$1, (function (param) {
                    return Curry._2(f, param[0], param[1]);
                  })));
}

function split_n(s, n) {
  var _s = s._0;
  var _i = n;
  var _accum = /* [] */0;
  var next = s._1;
  while(true) {
    var accum = _accum;
    var i = _i;
    var s$1 = _s;
    if (Import$negBase.$less$eq(i, 0)) {
      return [
              List1$negBase.rev(accum),
              /* Sequence */{
                _0: s$1,
                _1: next
              }
            ];
    }
    var s$2 = Curry._1(next, s$1);
    if (typeof s$2 === "number") {
      return [
              List1$negBase.rev(accum),
              empty
            ];
    }
    if (s$2.TAG === /* Skip */0) {
      _s = s$2._0;
      continue ;
    }
    _accum = {
      hd: s$2._0,
      tl: accum
    };
    _i = Import$negBase.$neg(i, 1);
    _s = s$2._1;
    continue ;
  };
}

function chunks_exn(t, n) {
  if (Import$negBase.$less$eq(n, 0)) {
    return Import$negBase.invalid_arg("Sequence.chunks_exn");
  } else {
    return /* Sequence */{
            _0: t,
            _1: (function (t) {
                var match = split_n(t, n);
                var xs = match[0];
                if (xs) {
                  return {
                          TAG: /* Yield */1,
                          _0: xs,
                          _1: match[1]
                        };
                } else {
                  return /* Done */0;
                }
              })
          };
  }
}

function findi(s, f) {
  return find(mapi(s, (function (i, s) {
                    return [
                            i,
                            s
                          ];
                  })), (function (param) {
                return Curry._2(f, param[0], param[1]);
              }));
}

function find_exn(s, f) {
  var x = find(s, f);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return Import$negBase.failwith("Sequence.find_exn");
  }
}

function append(s1, s2) {
  var next2 = s2._1;
  var s2$1 = s2._0;
  var next1 = s1._1;
  return /* Sequence */{
          _0: {
            NAME: "First_list",
            VAL: s1._0
          },
          _1: (function (param) {
              if (param.NAME === "First_list") {
                var s1 = Curry._1(next1, param.VAL);
                if (typeof s1 === "number") {
                  return {
                          TAG: /* Skip */0,
                          _0: {
                            NAME: "Second_list",
                            VAL: s2$1
                          }
                        };
                } else if (s1.TAG === /* Skip */0) {
                  return {
                          TAG: /* Skip */0,
                          _0: {
                            NAME: "First_list",
                            VAL: s1._0
                          }
                        };
                } else {
                  return {
                          TAG: /* Yield */1,
                          _0: s1._0,
                          _1: {
                            NAME: "First_list",
                            VAL: s1._1
                          }
                        };
                }
              }
              var s2$2 = Curry._1(next2, param.VAL);
              if (typeof s2$2 === "number") {
                return /* Done */0;
              } else if (s2$2.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: {
                          NAME: "Second_list",
                          VAL: s2$2._0
                        }
                      };
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: s2$2._0,
                        _1: {
                          NAME: "Second_list",
                          VAL: s2$2._1
                        }
                      };
              }
            })
        };
}

var concat_map = Curry.__2(bind$1);

function concat(s) {
  return Curry._2(bind$1, s, (function (prim) {
                return prim;
              }));
}

function concat_mapi(s, f) {
  return Curry._2(bind$1, mapi(s, (function (i, s) {
                    return [
                            i,
                            s
                          ];
                  })), (function (param) {
                return Curry._2(f, param[0], param[1]);
              }));
}

function zip(param, param$1) {
  var next2 = param$1._1;
  var next1 = param._1;
  var next = function (param) {
    var s1 = param[0];
    if (typeof s1 === "number") {
      return /* Done */0;
    }
    if (s1.TAG !== /* Skip */0) {
      var match = param[1];
      if (typeof match !== "number") {
        if (match.TAG === /* Skip */0) {
          return {
                  TAG: /* Skip */0,
                  _0: [
                    s1,
                    Curry._1(next2, param[1]._0)
                  ]
                };
        } else {
          return {
                  TAG: /* Yield */1,
                  _0: [
                    s1._0,
                    match._0
                  ],
                  _1: [
                    {
                      TAG: /* Skip */0,
                      _0: s1._1
                    },
                    {
                      TAG: /* Skip */0,
                      _0: match._1
                    }
                  ]
                };
        }
      }
      
    }
    if (typeof param[1] === "number") {
      return /* Done */0;
    } else {
      return {
              TAG: /* Skip */0,
              _0: [
                Curry._1(next1, s1._0),
                param[1]
              ]
            };
    }
  };
  return /* Sequence */{
          _0: [
            {
              TAG: /* Skip */0,
              _0: param._0
            },
            {
              TAG: /* Skip */0,
              _0: param$1._0
            }
          ],
          _1: next
        };
}

function zip_full(param, param$1) {
  var next2 = param$1._1;
  var next1 = param._1;
  var next = function (param) {
    var s1 = param[0];
    if (typeof s1 === "number") {
      var match = param[1];
      if (typeof match === "number") {
        return /* Done */0;
      }
      if (match.TAG !== /* Skip */0) {
        return {
                TAG: /* Yield */1,
                _0: {
                  NAME: "Right",
                  VAL: match._0
                },
                _1: [
                  /* Done */0,
                  Curry._1(next2, match._1)
                ]
              };
      }
      
    } else {
      if (s1.TAG === /* Skip */0) {
        return {
                TAG: /* Skip */0,
                _0: [
                  Curry._1(next1, s1._0),
                  param[1]
                ]
              };
      }
      var match$1 = param[1];
      var s1$1 = s1._1;
      var a = s1._0;
      if (typeof match$1 === "number") {
        return {
                TAG: /* Yield */1,
                _0: {
                  NAME: "Left",
                  VAL: a
                },
                _1: [
                  Curry._1(next1, s1$1),
                  /* Done */0
                ]
              };
      }
      if (match$1.TAG !== /* Skip */0) {
        return {
                TAG: /* Yield */1,
                _0: {
                  NAME: "Both",
                  VAL: [
                    a,
                    match$1._0
                  ]
                },
                _1: [
                  {
                    TAG: /* Skip */0,
                    _0: s1$1
                  },
                  {
                    TAG: /* Skip */0,
                    _0: match$1._1
                  }
                ]
              };
      }
      
    }
    return {
            TAG: /* Skip */0,
            _0: [
              s1,
              Curry._1(next2, param[1]._0)
            ]
          };
  };
  return /* Sequence */{
          _0: [
            {
              TAG: /* Skip */0,
              _0: param._0
            },
            {
              TAG: /* Skip */0,
              _0: param$1._0
            }
          ],
          _1: next
        };
}

function bounded_length(param, at_most) {
  var _i = 0;
  var _seed = param._0;
  var next = param._1;
  while(true) {
    var seed = _seed;
    var i = _i;
    if (Import$negBase.$great(i, at_most)) {
      return "Greater";
    }
    var seed$1 = Curry._1(next, seed);
    if (typeof seed$1 === "number") {
      return {
              NAME: "Is",
              VAL: i
            };
    }
    if (seed$1.TAG === /* Skip */0) {
      _seed = seed$1._0;
      continue ;
    }
    _seed = seed$1._1;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function length_is_bounded_by(minOpt, max, t) {
  var min = minOpt !== undefined ? minOpt : -1;
  if (max === undefined) {
    var next = t._1;
    var _s = t._0;
    var _acc = 0;
    while(true) {
      var acc = _acc;
      var s = _s;
      if (Import$negBase.$great$eq(acc, min)) {
        return true;
      }
      var s$1 = Curry._1(next, s);
      if (typeof s$1 === "number") {
        return false;
      }
      if (s$1.TAG === /* Skip */0) {
        _s = s$1._0;
        continue ;
      }
      _acc = Import$negBase.$plus(acc, 1);
      _s = s$1._1;
      continue ;
    };
  }
  var match = bounded_length(t, max);
  if (typeof match === "string" || !(match.NAME === "Is" && Import$negBase.$great$eq(match.VAL, min))) {
    return false;
  } else {
    return true;
  }
}

function iteri(s, f) {
  return iter(mapi(s, (function (i, s) {
                    return [
                            i,
                            s
                          ];
                  })), (function (param) {
                return Curry._2(f, param[0], param[1]);
              }));
}

function foldi(s, init, f) {
  return fold(mapi(s, (function (i, s) {
                    return [
                            i,
                            s
                          ];
                  })), init, (function (acc, param) {
                return Curry._3(f, param[0], acc, param[1]);
              }));
}

function reduce(s, f) {
  var match = next(s);
  if (match !== undefined) {
    return Caml_option.some(fold(match[1], match[0], f));
  }
  
}

function reduce_exn(s, f) {
  var res = reduce(s, f);
  if (res !== undefined) {
    return Caml_option.valFromOption(res);
  } else {
    return Import$negBase.failwith("Sequence.reduce_exn");
  }
}

function group(param, $$break) {
  var next = param._1;
  return /* Sequence */{
          _0: [
            /* [] */0,
            param._0
          ],
          _1: (function (param) {
              if (param === undefined) {
                return /* Done */0;
              }
              var acc = param[0];
              var match = Curry._1(next, param[1]);
              if (typeof match !== "number" && match.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          acc,
                          match._0
                        ]
                      };
              }
              if (!acc) {
                if (typeof match === "number") {
                  return /* Done */0;
                } else {
                  return {
                          TAG: /* Skip */0,
                          _0: [
                            {
                              hd: match._0,
                              tl: /* [] */0
                            },
                            match._1
                          ]
                        };
                }
              }
              if (typeof match === "number") {
                return {
                        TAG: /* Yield */1,
                        _0: List1$negBase.rev(acc),
                        _1: undefined
                      };
              }
              var s = match._1;
              var cur = match._0;
              if (Curry._2($$break, acc.hd, cur)) {
                return {
                        TAG: /* Yield */1,
                        _0: List1$negBase.rev(acc),
                        _1: [
                          {
                            hd: cur,
                            tl: /* [] */0
                          },
                          s
                        ]
                      };
              } else {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          {
                            hd: cur,
                            tl: acc
                          },
                          s
                        ]
                      };
              }
            })
        };
}

function find_consecutive_duplicate(param, equal) {
  var next = param._1;
  var _last_elt;
  var _s = param._0;
  while(true) {
    var s = _s;
    var last_elt = _last_elt;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return ;
    }
    if (s$1.TAG === /* Skip */0) {
      _s = s$1._0;
      continue ;
    }
    var s$2 = s$1._1;
    var a = s$1._0;
    if (last_elt !== undefined) {
      var b = Caml_option.valFromOption(last_elt);
      if (Curry._2(equal, a, b)) {
        return [
                b,
                a
              ];
      }
      _s = s$2;
      _last_elt = Caml_option.some(a);
      continue ;
    }
    _s = s$2;
    _last_elt = Caml_option.some(a);
    continue ;
  };
}

function remove_consecutive_duplicates(s, equal) {
  return unfold_with(s, undefined, (function (prev, a) {
                if (prev !== undefined && Curry._2(equal, a, Caml_option.valFromOption(prev))) {
                  return {
                          TAG: /* Skip */0,
                          _0: Caml_option.some(a)
                        };
                } else {
                  return {
                          TAG: /* Yield */1,
                          _0: a,
                          _1: Caml_option.some(a)
                        };
                }
              }));
}

function count(s, f) {
  return length(filter(s, f));
}

function counti(t, f) {
  return length(filteri(t, f));
}

function sum(m, t, f) {
  return Container$negBase.sum(fold, m, t, f);
}

function min_elt(t, compare) {
  return Container$negBase.min_elt(fold, t, compare);
}

function max_elt(t, compare) {
  return Container$negBase.max_elt(fold, t, compare);
}

function init(n, f) {
  return /* Sequence */{
          _0: 0,
          _1: (function (i) {
              if (Import$negBase.$great$eq(i, n)) {
                return /* Done */0;
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: Curry._1(f, i),
                        _1: Import$negBase.$plus(i, 1)
                      };
              }
            })
        };
}

function sub(s, pos, len) {
  if (Import$negBase.$less(pos, 0) || Import$negBase.$less(len, 0)) {
    Import$negBase.failwith("Sequence.sub");
  }
  var next = s._1;
  return /* Sequence */{
          _0: [
            0,
            s._0
          ],
          _1: (function (param) {
              var i = param[0];
              if (Import$negBase.$great$eq(Import$negBase.$neg(i, pos), len)) {
                return /* Done */0;
              }
              var s = Curry._1(next, param[1]);
              if (typeof s === "number") {
                return /* Done */0;
              } else if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          i,
                          s._0
                        ]
                      };
              } else if (Import$negBase.$great$eq(i, pos)) {
                return {
                        TAG: /* Yield */1,
                        _0: s._0,
                        _1: [
                          Import$negBase.$plus(i, 1),
                          s._1
                        ]
                      };
              } else {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          Import$negBase.$plus(i, 1),
                          s._1
                        ]
                      };
              }
            })
        };
}

function take(s, len) {
  if (Import$negBase.$less(len, 0)) {
    Import$negBase.failwith("Sequence.take");
  }
  var next = s._1;
  return /* Sequence */{
          _0: [
            0,
            s._0
          ],
          _1: (function (param) {
              var i = param[0];
              if (Import$negBase.$great$eq(i, len)) {
                return /* Done */0;
              }
              var s = Curry._1(next, param[1]);
              if (typeof s === "number") {
                return /* Done */0;
              } else if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          i,
                          s._0
                        ]
                      };
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: s._0,
                        _1: [
                          Import$negBase.$plus(i, 1),
                          s._1
                        ]
                      };
              }
            })
        };
}

function drop(s, len) {
  if (Import$negBase.$less(len, 0)) {
    Import$negBase.failwith("Sequence.drop");
  }
  var next = s._1;
  return /* Sequence */{
          _0: [
            0,
            s._0
          ],
          _1: (function (param) {
              var i = param[0];
              var s = Curry._1(next, param[1]);
              if (typeof s === "number") {
                return /* Done */0;
              } else if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          i,
                          s._0
                        ]
                      };
              } else if (Import$negBase.$great$eq(i, len)) {
                return {
                        TAG: /* Yield */1,
                        _0: s._0,
                        _1: [
                          Import$negBase.$plus(i, 1),
                          s._1
                        ]
                      };
              } else {
                return {
                        TAG: /* Skip */0,
                        _0: [
                          Import$negBase.$plus(i, 1),
                          s._1
                        ]
                      };
              }
            })
        };
}

function take_while(s, f) {
  var next = s._1;
  return /* Sequence */{
          _0: s._0,
          _1: (function (s) {
              var s$1 = Curry._1(next, s);
              if (typeof s$1 === "number") {
                return /* Done */0;
              }
              if (s$1.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: s$1._0
                      };
              }
              var a = s$1._0;
              if (Curry._1(f, a)) {
                return {
                        TAG: /* Yield */1,
                        _0: a,
                        _1: s$1._1
                      };
              } else {
                return /* Done */0;
              }
            })
        };
}

function drop_while(s, f) {
  var next = s._1;
  return /* Sequence */{
          _0: {
            NAME: "Dropping",
            VAL: s._0
          },
          _1: (function (param) {
              if (param.NAME === "Identity") {
                return lift_identity(next, param.VAL);
              }
              var s = Curry._1(next, param.VAL);
              if (typeof s === "number") {
                return /* Done */0;
              }
              if (s.TAG === /* Skip */0) {
                return {
                        TAG: /* Skip */0,
                        _0: {
                          NAME: "Dropping",
                          VAL: s._0
                        }
                      };
              }
              var a = s._0;
              if (Curry._1(f, a)) {
                return {
                        TAG: /* Skip */0,
                        _0: {
                          NAME: "Dropping",
                          VAL: s._1
                        }
                      };
              } else {
                return {
                        TAG: /* Yield */1,
                        _0: a,
                        _1: {
                          NAME: "Identity",
                          VAL: s._1
                        }
                      };
              }
            })
        };
}

function shift_right(s, x) {
  var next = s._1;
  return /* Sequence */{
          _0: {
            NAME: "Consing",
            VAL: [
              s._0,
              x
            ]
          },
          _1: (function (param) {
              if (param.NAME === "Identity") {
                return lift_identity(next, param.VAL);
              }
              var match = param.VAL;
              return {
                      TAG: /* Yield */1,
                      _0: match[1],
                      _1: {
                        NAME: "Identity",
                        VAL: match[0]
                      }
                    };
            })
        };
}

function shift_right_with_list(s, l) {
  return append(of_list(l), s);
}

var Infix = {
  $at: append
};

function intersperse(s, sep) {
  var next = s._1;
  return /* Sequence */{
          _0: {
            NAME: "Init",
            VAL: s._0
          },
          _1: (function (param) {
              var variant = param.NAME;
              if (variant === "Init") {
                var s = Curry._1(next, param.VAL);
                if (typeof s === "number") {
                  return /* Done */0;
                } else if (s.TAG === /* Skip */0) {
                  return {
                          TAG: /* Skip */0,
                          _0: {
                            NAME: "Init",
                            VAL: s._0
                          }
                        };
                } else {
                  return {
                          TAG: /* Yield */1,
                          _0: s._0,
                          _1: {
                            NAME: "Running",
                            VAL: s._1
                          }
                        };
                }
              }
              if (variant === "Running") {
                var s$1 = Curry._1(next, param.VAL);
                if (typeof s$1 === "number") {
                  return /* Done */0;
                } else if (s$1.TAG === /* Skip */0) {
                  return {
                          TAG: /* Skip */0,
                          _0: {
                            NAME: "Running",
                            VAL: s$1._0
                          }
                        };
                } else {
                  return {
                          TAG: /* Yield */1,
                          _0: sep,
                          _1: {
                            NAME: "Putting",
                            VAL: [
                              s$1._0,
                              s$1._1
                            ]
                          }
                        };
                }
              }
              var match = param.VAL;
              return {
                      TAG: /* Yield */1,
                      _0: match[0],
                      _1: {
                        NAME: "Running",
                        VAL: match[1]
                      }
                    };
            })
        };
}

function repeat(x) {
  return /* Sequence */{
          _0: x,
          _1: (function (x) {
              return {
                      TAG: /* Yield */1,
                      _0: x,
                      _1: x
                    };
            })
        };
}

function cycle_list_exn(xs) {
  if (List1$negBase.is_empty(xs)) {
    Import$negBase.invalid_arg("Sequence.cycle_list_exn");
  }
  var s = of_list(xs);
  return Curry._2(bind$1, /* Sequence */{
              _0: undefined,
              _1: (function (x) {
                  return {
                          TAG: /* Yield */1,
                          _0: x,
                          _1: x
                        };
                })
            }, (function (param) {
                return s;
              }));
}

function cartesian_product(sa, sb) {
  return Curry._2(bind$1, sa, (function (a) {
                return zip(repeat(a), sb);
              }));
}

var singleton = Curry.__1($$return$1);

function delayed_fold(s, init, f, finish) {
  return delayed_fold_step(s, init, (function (acc, option, k) {
                if (option !== undefined) {
                  return Curry._3(f, acc, Caml_option.valFromOption(option), k);
                } else {
                  return Curry._1(k, acc);
                }
              }), finish);
}

function fold_m(bind, $$return, t, init, f) {
  return delayed_fold_step(t, init, (function (acc, option, k) {
                if (option !== undefined) {
                  return Curry._2(bind, Curry._2(f, acc, Caml_option.valFromOption(option)), k);
                } else {
                  return Curry._2(bind, Curry._1($$return, acc), k);
                }
              }), $$return);
}

function iter_m(bind, $$return, t, f) {
  return delayed_fold_step(t, undefined, (function (param, option, k) {
                if (option !== undefined) {
                  return Curry._2(bind, Curry._1(f, Caml_option.valFromOption(option)), k);
                } else {
                  return Curry._2(bind, Curry._1($$return, undefined), k);
                }
              }), $$return);
}

function fold_until(s, init, f, finish) {
  var _s = s._0;
  var next = s._1;
  var _acc = init;
  while(true) {
    var acc = _acc;
    var s$1 = _s;
    var s$2 = Curry._1(next, s$1);
    if (typeof s$2 === "number") {
      return Curry._1(finish, acc);
    }
    if (s$2.TAG === /* Skip */0) {
      _s = s$2._0;
      continue ;
    }
    var x = Curry._2(f, acc, s$2._0);
    if (x.TAG !== /* Continue */0) {
      return x._0;
    }
    _acc = x._0;
    _s = s$2._1;
    continue ;
  };
}

function fold_result(s, init, f) {
  var _s = s._0;
  var next = s._1;
  var _acc = init;
  while(true) {
    var acc = _acc;
    var s$1 = _s;
    var s$2 = Curry._1(next, s$1);
    if (typeof s$2 === "number") {
      return Curry._1(Result$negBase.$$return, acc);
    }
    if (s$2.TAG === /* Skip */0) {
      _s = s$2._0;
      continue ;
    }
    var e = Curry._2(f, acc, s$2._0);
    if (e.TAG !== /* Ok */0) {
      return e;
    }
    _acc = e._0;
    _s = s$2._1;
    continue ;
  };
}

function force_eagerly(t) {
  return of_list(to_list(t));
}

function memoize(param) {
  var next = param._1;
  var memoize$1 = function (s) {
    return /* T */{
            _0: {
              LAZY_DONE: false,
              VAL: (function () {
                  var _s = s;
                  while(true) {
                    var s$1 = _s;
                    var s$2 = Curry._1(next, s$1);
                    if (typeof s$2 === "number") {
                      return /* Done */0;
                    }
                    if (s$2.TAG !== /* Skip */0) {
                      return {
                              TAG: /* Yield */1,
                              _0: s$2._0,
                              _1: memoize$1(s$2._1)
                            };
                    }
                    _s = s$2._0;
                    continue ;
                  };
                })
            }
          };
  };
  return /* Sequence */{
          _0: memoize$1(param._0),
          _1: (function (l) {
              return CamlinternalLazy.force(l._0);
            })
        };
}

function drop_eagerly(s, len) {
  var _i = 0;
  var _s = s._0;
  var next = s._1;
  while(true) {
    var s$1 = _s;
    var i = _i;
    if (Import$negBase.$great$eq(i, len)) {
      return /* Sequence */{
              _0: s$1,
              _1: next
            };
    }
    var s$2 = Curry._1(next, s$1);
    if (typeof s$2 === "number") {
      return empty;
    }
    if (s$2.TAG === /* Skip */0) {
      _s = s$2._0;
      continue ;
    }
    _s = s$2._1;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function drop_while_option(param, f) {
  var next = param._1;
  var _s = param._0;
  while(true) {
    var s = _s;
    var s$1 = Curry._1(next, s);
    if (typeof s$1 === "number") {
      return ;
    }
    if (s$1.TAG === /* Skip */0) {
      _s = s$1._0;
      continue ;
    }
    var s$2 = s$1._1;
    var x = s$1._0;
    if (!Curry._1(f, x)) {
      return [
              x,
              /* Sequence */{
                _0: s$2,
                _1: next
              }
            ];
    }
    _s = s$2;
    continue ;
  };
}

function compare$1(compare_a, t1, t2) {
  return With_return$negBase.with_return(function (r) {
              iter(zip_full(t1, t2), (function (param) {
                      var variant = param.NAME;
                      if (variant !== "Both") {
                        if (variant === "Left") {
                          return Curry._1(r, 1);
                        } else {
                          return Curry._1(r, -1);
                        }
                      }
                      var match = param.VAL;
                      var c = Curry._2(compare_a, match[0], match[1]);
                      if (Import$negBase.$less$great(c, 0)) {
                        return Curry._1(r, c);
                      }
                      
                    }));
              return 0;
            });
}

function equal(equal_a, t1, t2) {
  return for_all(zip_full(t1, t2), (function (param) {
                if (param.NAME !== "Both") {
                  return false;
                }
                var match = param.VAL;
                return Curry._2(equal_a, match[0], match[1]);
              }));
}

function round_robin(list) {
  var next = function (param) {
    var done_stack = param[1];
    var todo_stack = param[0];
    if (!todo_stack) {
      if (List1$negBase.is_empty(done_stack)) {
        return /* Done */0;
      } else {
        return {
                TAG: /* Skip */0,
                _0: [
                  List1$negBase.rev(done_stack),
                  /* [] */0
                ]
              };
      }
    }
    var todo_stack$1 = todo_stack.tl;
    var match = todo_stack.hd;
    var f = match._1;
    var s = Curry._1(f, match._0);
    if (typeof s === "number") {
      return {
              TAG: /* Skip */0,
              _0: [
                todo_stack$1,
                done_stack
              ]
            };
    } else if (s.TAG === /* Skip */0) {
      return {
              TAG: /* Skip */0,
              _0: [
                {
                  hd: /* Sequence */{
                    _0: s._0,
                    _1: f
                  },
                  tl: todo_stack$1
                },
                done_stack
              ]
            };
    } else {
      return {
              TAG: /* Yield */1,
              _0: s._0,
              _1: [
                todo_stack$1,
                {
                  hd: /* Sequence */{
                    _0: s._1,
                    _1: f
                  },
                  tl: done_stack
                }
              ]
            };
    }
  };
  var state = [
    list,
    /* [] */0
  ];
  return /* Sequence */{
          _0: state,
          _1: next
        };
}

function interleave(param) {
  var f1 = param._1;
  var next = function (param) {
    var s1 = param[2];
    var done_stack = param[1];
    var todo_stack = param[0];
    if (todo_stack) {
      var todo_stack$1 = todo_stack.tl;
      var match = todo_stack.hd;
      var f2 = match._1;
      var s2 = Curry._1(f2, match._0);
      if (typeof s2 === "number") {
        return {
                TAG: /* Skip */0,
                _0: [
                  todo_stack$1,
                  done_stack,
                  s1
                ]
              };
      } else if (s2.TAG === /* Skip */0) {
        return {
                TAG: /* Skip */0,
                _0: [
                  todo_stack$1,
                  {
                    hd: /* Sequence */{
                      _0: s2._0,
                      _1: f2
                    },
                    tl: done_stack
                  },
                  s1
                ]
              };
      } else {
        return {
                TAG: /* Yield */1,
                _0: s2._0,
                _1: [
                  todo_stack$1,
                  {
                    hd: /* Sequence */{
                      _0: s2._1,
                      _1: f2
                    },
                    tl: done_stack
                  },
                  s1
                ]
              };
      }
    }
    var match$1 = Curry._1(f1, s1);
    if (typeof match$1 === "number") {
      if (done_stack) {
        return {
                TAG: /* Skip */0,
                _0: [
                  List1$negBase.rev(done_stack),
                  /* [] */0,
                  s1
                ]
              };
      } else {
        return /* Done */0;
      }
    } else if (match$1.TAG === /* Skip */0) {
      return {
              TAG: /* Skip */0,
              _0: [
                List1$negBase.rev(done_stack),
                /* [] */0,
                match$1._0
              ]
            };
    } else {
      return {
              TAG: /* Skip */0,
              _0: [
                List1$negBase.rev({
                      hd: match$1._0,
                      tl: done_stack
                    }),
                /* [] */0,
                match$1._1
              ]
            };
    }
  };
  var state_2 = param._0;
  var state = [
    /* [] */0,
    /* [] */0,
    state_2
  ];
  return /* Sequence */{
          _0: state,
          _1: next
        };
}

function interleaved_cartesian_product(s1, s2) {
  return interleave(Curry._2(map$2, s1, (function (x1) {
                    return Curry._2(map$2, s2, (function (x2) {
                                  return [
                                          x1,
                                          x2
                                        ];
                                }));
                  })));
}

function of_seq(seq) {
  return /* Sequence */{
          _0: seq,
          _1: (function (seq) {
              var match = Curry._1(seq, undefined);
              if (match) {
                return {
                        TAG: /* Yield */1,
                        _0: match._0,
                        _1: match._1
                      };
              } else {
                return /* Done */0;
              }
            })
        };
}

function to_seq(param) {
  var next = param._1;
  var state = param._0;
  var loop = function (_state) {
    while(true) {
      var state = _state;
      var state$1 = Curry._1(next, state);
      if (typeof state$1 === "number") {
        return /* Nil */0;
      }
      if (state$1.TAG === /* Skip */0) {
        _state = state$1._0;
        continue ;
      }
      var state$2 = state$1._1;
      return /* Cons */{
              _0: state$1._0,
              _1: (function(state$2){
              return function (param) {
                return loop(state$2);
              }
              }(state$2))
            };
    };
  };
  return function (param) {
    return loop(state);
  };
}

function $$return$2(x, k) {
  return Curry._1(k, x);
}

function bind$2(m, f, k) {
  return Curry._1(m, (function (a) {
                var m$p = Curry._1(f, a);
                return Curry._1(m$p, k);
              }));
}

function map$3(m, f, k) {
  return Curry._1(m, (function (a) {
                return Curry._1(k, Curry._1(f, a));
              }));
}

var map$4 = {
  NAME: "Custom",
  VAL: map$3
};

var include$1 = Monad$negBase.Make2({
      bind: bind$2,
      map: map$4,
      $$return: $$return$2
    });

var $$return$3 = include$1.$$return;

function $$yield(e, k) {
  return /* Wrap */{
          _0: {
            TAG: /* Yield */1,
            _0: e,
            _1: k
          }
        };
}

function of_sequence(sequence) {
  return delayed_fold(sequence, undefined, (function (param, x, k, f) {
                return /* Wrap */{
                        _0: {
                          TAG: /* Yield */1,
                          _0: x,
                          _1: (function (param) {
                              return Curry._2(k, undefined, f);
                            })
                        }
                      };
              }), $$return$3);
}

function run(t) {
  var init = function (param) {
    return Curry._1(t, (function (param) {
                  return /* Wrap */{
                          _0: /* Done */0
                        };
                }));
  };
  var f = function (thunk) {
    return Curry._1(thunk, undefined)._0;
  };
  return /* Sequence */{
          _0: init,
          _1: f
        };
}

var $great$great$eq = include.$great$great$eq;

var $great$great$pipe = include.$great$great$pipe;

var Monad_infix = include.Monad_infix;

var join = include.join;

var ignore_m = include.ignore_m;

var all = include.all;

var all_unit = include.all_unit;

var Let_syntax = include.Let_syntax;

var shift_left = drop;

var Generator_$great$great$eq = include$1.$great$great$eq;

var Generator_$great$great$pipe = include$1.$great$great$pipe;

var Generator_Let_syntax = include$1.Let_syntax;

var Generator_Monad_infix = include$1.Monad_infix;

var Generator_bind = include$1.bind;

var Generator_map = include$1.map;

var Generator_join = include$1.join;

var Generator_ignore_m = include$1.ignore_m;

var Generator_all = include$1.all;

var Generator_all_unit = include$1.all_unit;

var Generator = {
  $great$great$eq: Generator_$great$great$eq,
  $great$great$pipe: Generator_$great$great$pipe,
  Let_syntax: Generator_Let_syntax,
  Monad_infix: Generator_Monad_infix,
  bind: Generator_bind,
  $$return: $$return$3,
  map: Generator_map,
  join: Generator_join,
  ignore_m: Generator_ignore_m,
  all: Generator_all,
  all_unit: Generator_all_unit,
  $$yield: $$yield,
  of_sequence: of_sequence,
  run: run
};

exports.compare = compare$1;
exports.equal = equal;
exports.sexp_of_t = sexp_of_t$1;
exports.mem = mem;
exports.length = length;
exports.is_empty = is_empty;
exports.iter = iter;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.count = count;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.foldi = foldi;
exports.iteri = iteri;
exports.existsi = existsi;
exports.counti = counti;
exports.findi = findi;
exports.find_mapi = find_mapi;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.Monad_infix = Monad_infix;
exports.bind = bind$1;
exports.$$return = $$return$1;
exports.map = map$2;
exports.join = join;
exports.ignore_m = ignore_m;
exports.all = all;
exports.all_unit = all_unit;
exports.Let_syntax = Let_syntax;
exports.empty = empty;
exports.next = next;
exports.Step = Step;
exports.unfold_step = unfold_step;
exports.unfold = unfold;
exports.unfold_with = unfold_with;
exports.unfold_with_and_finish = unfold_with_and_finish;
exports.nth = nth;
exports.nth_exn = nth_exn;
exports.folding_map = folding_map;
exports.folding_mapi = folding_mapi;
exports.mapi = mapi;
exports.filteri = filteri;
exports.filter = filter;
exports.merge = merge;
exports.Merge_with_duplicates_element = Merge_with_duplicates_element;
exports.merge_with_duplicates = merge_with_duplicates;
exports.hd = hd;
exports.hd_exn = hd_exn;
exports.tl = tl;
exports.tl_eagerly_exn = tl_eagerly_exn;
exports.find_exn = find_exn;
exports.for_alli = for_alli;
exports.append = append;
exports.concat = concat;
exports.concat_map = concat_map;
exports.concat_mapi = concat_mapi;
exports.interleave = interleave;
exports.round_robin = round_robin;
exports.zip = zip;
exports.zip_full = zip_full;
exports.reduce_exn = reduce_exn;
exports.reduce = reduce;
exports.group = group;
exports.find_consecutive_duplicate = find_consecutive_duplicate;
exports.remove_consecutive_duplicates = remove_consecutive_duplicates;
exports.range = range;
exports.init = init;
exports.filter_map = filter_map;
exports.filter_mapi = filter_mapi;
exports.filter_opt = filter_opt;
exports.sub = sub;
exports.take = take;
exports.drop = drop;
exports.drop_eagerly = drop_eagerly;
exports.take_while = take_while;
exports.drop_while = drop_while;
exports.drop_while_option = drop_while_option;
exports.split_n = split_n;
exports.chunks_exn = chunks_exn;
exports.shift_right = shift_right;
exports.shift_right_with_list = shift_right_with_list;
exports.shift_left = shift_left;
exports.Infix = Infix;
exports.cartesian_product = cartesian_product;
exports.interleaved_cartesian_product = interleaved_cartesian_product;
exports.intersperse = intersperse;
exports.cycle_list_exn = cycle_list_exn;
exports.repeat = repeat;
exports.singleton = singleton;
exports.delayed_fold = delayed_fold;
exports.fold_m = fold_m;
exports.iter_m = iter_m;
exports.to_list_rev = to_list_rev;
exports.of_list = of_list;
exports.of_lazy = of_lazy;
exports.memoize = memoize;
exports.force_eagerly = force_eagerly;
exports.bounded_length = bounded_length;
exports.length_is_bounded_by = length_is_bounded_by;
exports.of_seq = of_seq;
exports.to_seq = to_seq;
exports.Generator = Generator;
exports.Expert = Expert;
/* include Not a pure module */
