// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Base_int_math = require("./base_int_math");
var Pow_overflow_bounds$negBase = require("./pow_overflow_bounds.bs.js");

function negative_exponent(param) {
  return Curry._1(Printf$negBase.invalid_argf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "exponent can not be negative",
                    _1: /* End_of_format */0
                  },
                  _1: "exponent can not be negative"
                }), undefined);
}

function overflow(param) {
  return Curry._1(Printf$negBase.invalid_argf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "integer overflow in pow",
                    _1: /* End_of_format */0
                  },
                  _1: "integer overflow in pow"
                }), undefined);
}

function int_pow(base, exponent) {
  if (Import$negBase.$less(exponent, 0)) {
    negative_exponent(undefined);
  }
  if (Import$negBase.$great(Import$negBase.abs(base), 1) && (Import$negBase.$great(exponent, 63) || Import$negBase.$great(Import$negBase.abs(base), Caml_array.get(Pow_overflow_bounds$negBase.int_positive_overflow_bounds, exponent)))) {
    overflow(undefined);
  }
  return Base_int_math.Base_int_math_int_pow_stub(base, exponent);
}

function int64_pow(base, exponent) {
  if (Caml.i64_lt(exponent, Caml_int64.zero)) {
    negative_exponent(undefined);
  }
  if ((Caml.i64_gt(base, Caml_int64.one) || Caml.i64_lt(base, Caml_int64.neg_one)) && (Caml.i64_gt(exponent, [
            0,
            63
          ]) || Caml.i64_ge(base, Caml_int64.zero) && Caml.i64_gt(base, Caml_array.get(Pow_overflow_bounds$negBase.int64_positive_overflow_bounds, Caml_int64.to_int32(exponent))) || Caml.i64_lt(base, Caml_int64.zero) && Caml.i64_lt(base, Caml_array.get(Pow_overflow_bounds$negBase.int64_negative_overflow_bounds, Caml_int64.to_int32(exponent))))) {
    overflow(undefined);
  }
  return Base_int_math.Base_int_math_int64_pow_stub(base, exponent);
}

function int63_pow_on_int64(base, exponent) {
  if (Caml.i64_lt(exponent, Caml_int64.zero)) {
    negative_exponent(undefined);
  }
  if (Caml.i64_gt(Int64.abs(base), Caml_int64.one) && (Caml.i64_gt(exponent, [
            0,
            63
          ]) || Caml.i64_gt(Int64.abs(base), Caml_array.get(Pow_overflow_bounds$negBase.int63_on_int64_positive_overflow_bounds, Caml_int64.to_int32(exponent))))) {
    overflow(undefined);
  }
  return Base_int_math.Base_int_math_int64_pow_stub(base, exponent);
}

var Private = {
  int_pow: int_pow,
  int64_pow: int64_pow,
  int63_pow_on_int64: int63_pow_on_int64
};

function Make(funarg) {
  var $percent = function (x, y) {
    if (Curry._2(funarg.$less$eq, y, funarg.zero)) {
      Curry._3(Printf$negBase.invalid_argf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* ' ' */32,
                    _1: {
                      TAG: /* Char_literal */12,
                      _0: /* '%' */37,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* ' ' */32,
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " in core_int.ml: modulus should be positive",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  }
                },
                _1: "%s %% %s in core_int.ml: modulus should be positive"
              }), Curry._1(funarg.to_string, x), Curry._1(funarg.to_string, y), undefined);
    }
    var rval = Curry._2(funarg.rem, x, y);
    if (Curry._2(funarg.$less, rval, funarg.zero)) {
      return Curry._2(funarg.$plus, rval, y);
    } else {
      return rval;
    }
  };
  var one = Curry._1(funarg.of_int_exn, 1);
  var $slash$percent = function (x, y) {
    if (Curry._2(funarg.$less$eq, y, funarg.zero)) {
      Curry._3(Printf$negBase.invalid_argf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* String_literal */11,
                    _0: " /",
                    _1: {
                      TAG: /* Char_literal */12,
                      _0: /* '%' */37,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* ' ' */32,
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " in core_int.ml: divisor should be positive",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  }
                },
                _1: "%s /%% %s in core_int.ml: divisor should be positive"
              }), Curry._1(funarg.to_string, x), Curry._1(funarg.to_string, y), undefined);
    }
    if (Curry._2(funarg.$less, x, funarg.zero)) {
      return Curry._2(funarg.$neg, Curry._2(funarg.$slash, Curry._2(funarg.$plus, x, one), y), one);
    } else {
      return Curry._2(funarg.$slash, x, y);
    }
  };
  var $slash$slash = function (x, y) {
    return Import$negBase.$slash$dot(Curry._1(funarg.to_float, x), Curry._1(funarg.to_float, y));
  };
  var round_down = function (i, modulus) {
    return Curry._2(funarg.$neg, i, $percent(i, modulus));
  };
  var round_up = function (i, modulus) {
    var remainder = $percent(i, modulus);
    if (Curry._2(funarg.$eq, remainder, funarg.zero)) {
      return i;
    } else {
      return Curry._2(funarg.$neg, Curry._2(funarg.$plus, i, modulus), remainder);
    }
  };
  var round_towards_zero = function (i, to_multiple_of) {
    if (Curry._2(funarg.$eq, i, funarg.zero)) {
      return funarg.zero;
    } else if (Curry._2(funarg.$great, i, funarg.zero)) {
      return round_down(i, to_multiple_of);
    } else {
      return round_up(i, to_multiple_of);
    }
  };
  var round_nearest = function (i, modulus) {
    var remainder = $percent(i, modulus);
    var modulus_minus_remainder = Curry._2(funarg.$neg, modulus, remainder);
    if (Curry._2(funarg.$less$eq, modulus_minus_remainder, remainder)) {
      return Curry._2(funarg.$plus, i, modulus_minus_remainder);
    } else {
      return Curry._2(funarg.$neg, i, remainder);
    }
  };
  var round = function (dirOpt, i, to_multiple_of) {
    var dir = dirOpt !== undefined ? dirOpt : "Nearest";
    if (dir === "Down") {
      return round_down(i, to_multiple_of);
    } else if (dir === "Nearest") {
      return round_nearest(i, to_multiple_of);
    } else if (dir === "Zero") {
      return round_towards_zero(i, to_multiple_of);
    } else {
      return round_up(i, to_multiple_of);
    }
  };
  return {
          $percent: $percent,
          $slash$percent: $slash$percent,
          $slash$slash: $slash$slash,
          round: round,
          round_towards_zero: round_towards_zero,
          round_down: round_down,
          round_up: round_up,
          round_nearest: round_nearest
        };
}

exports.Make = Make;
exports.Private = Private;
/* Import-Base Not a pure module */
