// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var List$negBase = require("./list.bs.js");
var Array$negBase = require("./array.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Hashtbl$negBase = require("./hashtbl.bs.js");
var Hashable$negBase = require("./hashable.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Container$negBase = require("./container.bs.js");
var With_return$negBase = require("./with_return.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");

var hashable = Hashtbl$negBase.Private.hashable;

var poly_hashable = Hashtbl$negBase.Poly.hashable;

var is_empty = Hashtbl$negBase.is_empty;

function find_map(t, f) {
  return With_return$negBase.with_return(function (r) {
              Hashtbl$negBase.iter_keys(t, (function (elt) {
                      var o = Curry._1(f, elt);
                      if (o !== undefined) {
                        return Curry._1(r, o);
                      }
                      
                    }));
              
            });
}

function find(t, f) {
  return find_map(t, (function (a) {
                if (Curry._1(f, a)) {
                  return Caml_option.some(a);
                }
                
              }));
}

function add(t, k) {
  return Hashtbl$negBase.set(t, k, undefined);
}

function strict_add(t, k) {
  if (Hashtbl$negBase.mem(t, k)) {
    return Or_error$negBase.error_string("element already exists");
  } else {
    Hashtbl$negBase.set(t, k, undefined);
    return {
            TAG: /* Ok */0,
            _0: undefined
          };
  }
}

function strict_add_exn(t, k) {
  return Or_error$negBase.ok_exn(strict_add(t, k));
}

function strict_remove(t, k) {
  if (Hashtbl$negBase.mem(t, k)) {
    Hashtbl$negBase.remove(t, k);
    return {
            TAG: /* Ok */0,
            _0: undefined
          };
  } else {
    return Or_error$negBase.error(undefined, undefined, "element not in set", k, Hashtbl$negBase.sexp_of_key(t));
  }
}

function strict_remove_exn(t, k) {
  return Or_error$negBase.ok_exn(strict_remove(t, k));
}

function fold(t, init, f) {
  return Hashtbl$negBase.fold(t, init, (function (key, param, acc) {
                return Curry._2(f, acc, key);
              }));
}

var iter = Hashtbl$negBase.iter_keys;

function count(t, f) {
  return Container$negBase.count(fold, t, f);
}

function sum(m, t, f) {
  return Container$negBase.sum(fold, m, t, f);
}

function min_elt(t, compare) {
  return Container$negBase.min_elt(fold, t, compare);
}

function max_elt(t, compare) {
  return Container$negBase.max_elt(fold, t, compare);
}

function fold_result(t, init, f) {
  return Container$negBase.fold_result(fold, init, f, t);
}

function fold_until(t, init, f) {
  return function (param) {
    return Container$negBase.fold_until(fold, init, f, param, t);
  };
}

function sexp_of_t(sexp_of_e, t) {
  var arg = Curry._1(hashable, t).compare;
  return Import$negBase.sexp_of_list(sexp_of_e, (function (param) {
                  return List$negBase.sort(param, arg);
                })(Hashtbl$negBase.keys(t)));
}

function to_array(t) {
  var len = Hashtbl$negBase.length(t);
  var index = {
    contents: Import$negBase.$neg(len, 1)
  };
  return fold(t, [], (function (acc, key) {
                if (Array$negBase.length(acc) === 0) {
                  return Array$negBase.create(len, key);
                } else {
                  index[0] = Import$negBase.$neg(index[0], 1);
                  Caml_array.set(acc, index[0], key);
                  return acc;
                }
              }));
}

function exists(t, f) {
  return Hashtbl$negBase.existsi(t, (function (key, param) {
                return Curry._1(f, key);
              }));
}

function for_all(t, f) {
  return !Hashtbl$negBase.existsi(t, (function (key, param) {
                return !Curry._1(f, key);
              }));
}

function equal(t1, t2) {
  return Hashtbl$negBase.equal((function (param, param$1) {
                return true;
              }), t1, t2);
}

var copy = Hashtbl$negBase.copy;

function filter(t, f) {
  return Hashtbl$negBase.filteri(t, (function (key, param) {
                return Curry._1(f, key);
              }));
}

function union(t1, t2) {
  return Hashtbl$negBase.merge(t1, t2, (function (param, param$1) {
                return Caml_option.some(undefined);
              }));
}

function diff(t1, t2) {
  return Hashtbl$negBase.filteri(t1, (function (key, param) {
                return !Hashtbl$negBase.mem(t2, key);
              }));
}

function inter(t1, t2) {
  var match = Import$negBase.$great(Hashtbl$negBase.length(t1), Hashtbl$negBase.length(t2)) ? [
      t2,
      t1
    ] : [
      t1,
      t2
    ];
  var larger = match[1];
  return Hashtbl$negBase.filteri(match[0], (function (key, param) {
                return Hashtbl$negBase.mem(larger, key);
              }));
}

function filter_inplace(t, f) {
  var to_remove = fold(t, /* [] */0, (function (ac, x) {
          if (Curry._1(f, x)) {
            return ac;
          } else {
            return {
                    hd: x,
                    tl: ac
                  };
          }
        }));
  return List$negBase.iter(to_remove, (function (x) {
                return Hashtbl$negBase.remove(t, x);
              }));
}

function of_hashtbl_keys(hashtbl) {
  return Hashtbl$negBase.map(hashtbl, (function (prim) {
                
              }));
}

function to_hashtbl(t, f) {
  return Hashtbl$negBase.mapi(t, (function (key, param) {
                return Curry._1(f, key);
              }));
}

var create = Hashtbl$negBase.create;

function of_list(growth_allowed, size, m, l) {
  var size$1 = size !== undefined ? size : List$negBase.length(l);
  var t = Hashtbl$negBase.create(growth_allowed, size$1, m);
  List$negBase.iter(l, (function (k) {
          return Hashtbl$negBase.set(t, k, undefined);
        }));
  return t;
}

function t_of_sexp(m, e_of_sexp, sexp) {
  if (sexp.TAG === /* Atom */0) {
    return Import$negBase.of_sexp_error("Hash_set.t_of_sexp requires a list", sexp);
  }
  var list = sexp._0;
  var t = Hashtbl$negBase.create(undefined, List$negBase.length(list), m);
  List$negBase.iter(list, (function (sexp) {
          var e = Curry._1(e_of_sexp, sexp);
          var match = strict_add(t, e);
          if (match.TAG === /* Ok */0) {
            return ;
          } else {
            return Import$negBase.of_sexp_error("Hash_set.t_of_sexp got a duplicate element", sexp);
          }
        }));
  return t;
}

function Creators(Elt) {
  var create = function (growth_allowed, size, param) {
    return Hashtbl$negBase.create(growth_allowed, size, Hashable$negBase.to_key(Elt.hashable));
  };
  var of_list$1 = function (growth_allowed, size, l) {
    return of_list(growth_allowed, size, Hashable$negBase.to_key(Elt.hashable), l);
  };
  var t_of_sexp$1 = function (e_of_sexp, sexp) {
    return t_of_sexp(Hashable$negBase.to_key(Elt.hashable), e_of_sexp, sexp);
  };
  return {
          t_of_sexp: t_of_sexp$1,
          create: create,
          of_list: of_list$1
        };
}

function create$1(growth_allowed, size, param) {
  return Hashtbl$negBase.create(growth_allowed, size, Hashable$negBase.to_key(poly_hashable));
}

function of_list$1(growth_allowed, size, l) {
  return of_list(growth_allowed, size, Hashable$negBase.to_key(poly_hashable), l);
}

function t_of_sexp$1(e_of_sexp, sexp) {
  return t_of_sexp(Hashable$negBase.to_key(poly_hashable), e_of_sexp, sexp);
}

function t_sexp_grammar(grammar) {
  return Sexp_grammar$negSexplib0.coerce(List$negBase.t_sexp_grammar(grammar));
}

function M(Elt) {
  return {};
}

function sexp_of_m__t(Elt, t) {
  return sexp_of_t(Elt.sexp_of_t, t);
}

function m__t_of_sexp(Elt, sexp) {
  return t_of_sexp({
              compare: Elt.compare,
              sexp_of_t: Elt.sexp_of_t,
              hash: Elt.hash
            }, Elt.t_of_sexp, sexp);
}

function m__t_sexp_grammar(Elt) {
  return Sexp_grammar$negSexplib0.coerce(Import$negBase.list_sexp_grammar(Elt.t_sexp_grammar));
}

var hashable$1 = Hashtbl$negBase.Private.hashable;

var Private = {
  hashable: hashable$1
};

var length = Hashtbl$negBase.length;

var to_list = Hashtbl$negBase.keys;

var mem = Hashtbl$negBase.mem;

var remove = Hashtbl$negBase.remove;

var clear = Hashtbl$negBase.clear;

var hashable_s = Hashtbl$negBase.hashable_s;

var Poly = {
  t_of_sexp: t_of_sexp$1,
  sexp_of_t: sexp_of_t,
  t_sexp_grammar: t_sexp_grammar,
  create: create$1,
  of_list: of_list$1,
  length: Hashtbl$negBase.length,
  is_empty: is_empty,
  iter: iter,
  fold: fold,
  fold_result: fold_result,
  fold_until: fold_until,
  exists: exists,
  for_all: for_all,
  count: count,
  sum: sum,
  find: find,
  find_map: find_map,
  to_list: Hashtbl$negBase.keys,
  to_array: to_array,
  min_elt: min_elt,
  max_elt: max_elt,
  mem: Hashtbl$negBase.mem,
  copy: copy,
  add: add,
  strict_add: strict_add,
  strict_add_exn: strict_add_exn,
  remove: Hashtbl$negBase.remove,
  strict_remove: strict_remove,
  strict_remove_exn: strict_remove_exn,
  clear: Hashtbl$negBase.clear,
  equal: equal,
  filter: filter,
  filter_inplace: filter_inplace,
  inter: inter,
  union: union,
  diff: diff,
  of_hashtbl_keys: of_hashtbl_keys,
  to_hashtbl: to_hashtbl
};

exports.sexp_of_t = sexp_of_t;
exports.create = create;
exports.of_list = of_list;
exports.length = length;
exports.is_empty = is_empty;
exports.iter = iter;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.count = count;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.mem = mem;
exports.copy = copy;
exports.add = add;
exports.strict_add = strict_add;
exports.strict_add_exn = strict_add_exn;
exports.remove = remove;
exports.strict_remove = strict_remove;
exports.strict_remove_exn = strict_remove_exn;
exports.clear = clear;
exports.equal = equal;
exports.filter = filter;
exports.filter_inplace = filter_inplace;
exports.inter = inter;
exports.union = union;
exports.diff = diff;
exports.of_hashtbl_keys = of_hashtbl_keys;
exports.to_hashtbl = to_hashtbl;
exports.hashable_s = hashable_s;
exports.Poly = Poly;
exports.Creators = Creators;
exports.M = M;
exports.sexp_of_m__t = sexp_of_m__t;
exports.m__t_of_sexp = m__t_of_sexp;
exports.m__t_sexp_grammar = m__t_sexp_grammar;
exports.Private = Private;
/* List-Base Not a pure module */
