// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Blit$negBase = require("./blit.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Sexpable$negBase = require("./sexpable.bs.js");
var Uniform_array$negBase = require("./uniform_array.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");

var none_substitute = {unique: true};

function is_none(x) {
  return Import$negBase.phys_equal(x, "x6e8ee3478e1d7449");
}

function is_some(x) {
  return !Import$negBase.phys_equal(x, "x6e8ee3478e1d7449");
}

function some(x) {
  if (Import$negBase.phys_equal(x, "x6e8ee3478e1d7449")) {
    return none_substitute;
  } else {
    return x;
  }
}

function value_unsafe(x) {
  if (Import$negBase.phys_equal(x, none_substitute)) {
    return "x6e8ee3478e1d7449";
  } else {
    return x;
  }
}

function value_exn(x) {
  if (Import$negBase.phys_equal(x, "x6e8ee3478e1d7449")) {
    return Import$negBase.failwith("Option_array.get_some_exn: the element is [None]");
  } else {
    return value_unsafe(x);
  }
}

function of_option(x) {
  if (x !== undefined) {
    return some(Caml_option.valFromOption(x));
  } else {
    return "x6e8ee3478e1d7449";
  }
}

function to_option(x) {
  if (!Import$negBase.phys_equal(x, "x6e8ee3478e1d7449")) {
    return Caml_option.some(value_unsafe(x));
  }
  
}

var partial_arg = {
  t_of_sexp: Option$negBase.t_of_sexp,
  sexp_of_t: Option$negBase.sexp_of_t
};

var partial_arg$1 = Sexpable$negBase.Of_sexpable1;

var include = (function (param) {
      return partial_arg$1(partial_arg, param);
    })({
      to_sexpable: to_option,
      of_sexpable: of_option
    });

var t_of_sexp = include.t_of_sexp;

var sexp_of_t = include.sexp_of_t;

function t_of_sexp$1(_of_a, t) {
  return Curry._2(Uniform_array$negBase.t_of_sexp, Curry._1(t_of_sexp, _of_a), t);
}

function sexp_of_t$1(_of_a, v) {
  return Curry._2(Uniform_array$negBase.sexp_of_t, Curry._1(sexp_of_t, _of_a), v);
}

function t_sexp_grammar(_$pa_sexp_grammar) {
  return Uniform_array$negBase.t_sexp_grammar(Sexp_grammar$negSexplib0.coerce(Option$negBase.t_sexp_grammar(_$pa_sexp_grammar)));
}

function create(len) {
  return Uniform_array$negBase.create(len, "x6e8ee3478e1d7449");
}

function init(n, f) {
  return Uniform_array$negBase.init(n, (function (i) {
                return of_option(Curry._1(f, i));
              }));
}

function init_some(n, f) {
  return Uniform_array$negBase.init(n, (function (i) {
                return some(Curry._1(f, i));
              }));
}

function get(t, i) {
  return to_option(Uniform_array$negBase.get(t, i));
}

function get_some_exn(t, i) {
  return value_exn(Uniform_array$negBase.get(t, i));
}

function is_none$1(t, i) {
  return Import$negBase.phys_equal(Uniform_array$negBase.get(t, i), "x6e8ee3478e1d7449");
}

function is_some$1(t, i) {
  var x = Uniform_array$negBase.get(t, i);
  return !Import$negBase.phys_equal(x, "x6e8ee3478e1d7449");
}

function set(t, i, x) {
  return Uniform_array$negBase.set(t, i, of_option(x));
}

function set_some(t, i, x) {
  return Uniform_array$negBase.set(t, i, some(x));
}

function set_none(t, i) {
  return Uniform_array$negBase.set(t, i, "x6e8ee3478e1d7449");
}

var swap = Uniform_array$negBase.swap;

function unsafe_get(t, i) {
  return to_option(Uniform_array$negBase.unsafe_get(t, i));
}

function unsafe_get_some_exn(t, i) {
  return value_exn(Uniform_array$negBase.unsafe_get(t, i));
}

function unsafe_get_some_assuming_some(t, i) {
  return value_unsafe(Uniform_array$negBase.unsafe_get(t, i));
}

function unsafe_is_some(t, i) {
  var x = Uniform_array$negBase.unsafe_get(t, i);
  return !Import$negBase.phys_equal(x, "x6e8ee3478e1d7449");
}

function unsafe_set(t, i, x) {
  return Uniform_array$negBase.unsafe_set(t, i, of_option(x));
}

function unsafe_set_some(t, i, x) {
  return Uniform_array$negBase.unsafe_set(t, i, some(x));
}

function unsafe_set_none(t, i) {
  return Uniform_array$negBase.unsafe_set(t, i, "x6e8ee3478e1d7449");
}

function clear(t) {
  for(var i = 0 ,i_finish = Import$negBase.$neg(Uniform_array$negBase.length(t), 1); i <= i_finish; ++i){
    unsafe_set_none(t, i);
  }
  
}

function create_like(len, param) {
  return create(len);
}

var include$1 = Blit$negBase.Make1_generic({
      create_like: create_like,
      length: Uniform_array$negBase.length,
      unsafe_blit: Uniform_array$negBase.unsafe_blit
    });

var empty = Uniform_array$negBase.empty;

var length = Uniform_array$negBase.length;

var blit = include$1.blit;

var blito = include$1.blito;

var unsafe_blit = include$1.unsafe_blit;

var sub = include$1.sub;

var subo = include$1.subo;

var copy = Uniform_array$negBase.copy;

var For_testing = {
  Unsafe_cheap_option: {
    t_of_sexp: t_of_sexp,
    sexp_of_t: sexp_of_t,
    none: "x6e8ee3478e1d7449",
    some: some,
    is_none: is_none,
    is_some: is_some,
    value_exn: value_exn,
    value_unsafe: value_unsafe,
    to_option: to_option,
    of_option: of_option
  }
};

exports.t_of_sexp = t_of_sexp$1;
exports.sexp_of_t = sexp_of_t$1;
exports.t_sexp_grammar = t_sexp_grammar;
exports.empty = empty;
exports.create = create;
exports.init_some = init_some;
exports.init = init;
exports.length = length;
exports.get = get;
exports.get_some_exn = get_some_exn;
exports.is_none = is_none$1;
exports.is_some = is_some$1;
exports.unsafe_get = unsafe_get;
exports.unsafe_get_some_exn = unsafe_get_some_exn;
exports.unsafe_get_some_assuming_some = unsafe_get_some_assuming_some;
exports.unsafe_is_some = unsafe_is_some;
exports.set = set;
exports.set_some = set_some;
exports.set_none = set_none;
exports.swap = swap;
exports.clear = clear;
exports.unsafe_set = unsafe_set;
exports.unsafe_set_some = unsafe_set_some;
exports.unsafe_set_none = unsafe_set_none;
exports.blit = blit;
exports.blito = blito;
exports.unsafe_blit = unsafe_blit;
exports.sub = sub;
exports.subo = subo;
exports.copy = copy;
exports.For_testing = For_testing;
/* include Not a pure module */
