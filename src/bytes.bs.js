// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Blit$negBase = require("./blit.bs.js");
var Char$negBase = require("./char.bs.js");
var List$negBase = require("./list.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Array0$negBase = require("./array0.bs.js");
var Bytes0$negBase = require("./bytes0.bs.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Staged$negBase = require("./staged.bs.js");
var Bytes_tr$negBase = require("./bytes_tr.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Comparator$negBase = require("./comparator.bs.js");
var Pretty_printer$negBase = require("./pretty_printer.bs.js");
var Ordered_collection_common$negBase = require("./ordered_collection_common.bs.js");

function pp(fmt, t) {
  return Curry._1(Format.fprintf(fmt)(/* Format */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: /* No_padding */0,
                    _1: /* End_of_format */0
                  },
                  _1: "%S"
                }), Bytes0$negBase.to_string(t));
}

var create = Bytes0$negBase.create;

var To_bytes = Blit$negBase.Make({
      length: (function (prim) {
          return prim.length;
        }),
      create: create,
      unsafe_blit: Bytes0$negBase.unsafe_blit
    });

var include = Comparator$negBase.Make({
      compare: Bytes0$negBase.compare,
      sexp_of_t: Import$negBase.sexp_of_bytes
    });

var include$1 = Pretty_printer$negBase.Register_pp({
      pp: pp,
      module_name: "Base.Bytes"
    });

var partial_arg = {};

var partial_arg$1 = Blit$negBase.Make_to_string;

var To_string = (function (param) {
      return partial_arg$1(partial_arg, param);
    })(To_bytes);

function length(prim) {
  return prim.length;
}

var partial_arg$2 = {
  length: length
};

var partial_arg$3 = Blit$negBase.Make_distinct;

var create$1 = Bytes0$negBase.create;

function length$1(prim) {
  return prim.length;
}

var unsafe_blit = Caml_bytes.caml_blit_string;

var From_string = (function (param) {
      return partial_arg$3(partial_arg$2, param);
    })({
      length: length$1,
      create: create$1,
      unsafe_blit: unsafe_blit
    });

function invariant(param) {
  
}

function init(n, f) {
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, n, 0)) {
    Curry._2(Printf$negBase.invalid_argf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Bytes.init ",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: /* End_of_format */0
                }
              },
              _1: "Bytes.init %d"
            }), n, undefined);
  }
  var t = Bytes0$negBase.create(n);
  for(var i = 0 ,i_finish = Import$negBase.$neg(n, 1); i <= i_finish; ++i){
    t[i] = Curry._1(f, i);
  }
  return t;
}

function of_char_list(l) {
  var t = Bytes0$negBase.create(List$negBase.length(l));
  List$negBase.iteri(l, (function (i, c) {
          return Caml_bytes.set(t, i, c);
        }));
  return t;
}

function to_list(t) {
  var _i = Import$negBase.$neg(t.length, 1);
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var i = _i;
    if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, i, 0)) {
      return acc;
    }
    _acc = {
      hd: t[i],
      tl: acc
    };
    _i = Import$negBase.$neg(i, 1);
    continue ;
  };
}

function to_array(t) {
  return Array0$negBase.init(t.length, (function (i) {
                return t[i];
              }));
}

function map(t, f) {
  return Bytes0$negBase.map(f, t);
}

function mapi(t, f) {
  return Bytes0$negBase.mapi(f, t);
}

function fold(t, init, f) {
  var len = t.length;
  var _pos = 0;
  var _acc = init;
  while(true) {
    var acc = _acc;
    var pos = _pos;
    if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.equal, pos, len)) {
      return acc;
    }
    _acc = Curry._2(f, acc, t[pos]);
    _pos = Import$negBase.$plus(pos, 1);
    continue ;
  };
}

function foldi(t, init, f) {
  var len = t.length;
  var _pos = 0;
  var _acc = init;
  while(true) {
    var acc = _acc;
    var pos = _pos;
    if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.equal, pos, len)) {
      return acc;
    }
    _acc = Curry._3(f, pos, acc, t[pos]);
    _pos = Import$negBase.$plus(pos, 1);
    continue ;
  };
}

function tr(target, replacement, s) {
  for(var i = 0 ,i_finish = Import$negBase.$neg(s.length, 1); i <= i_finish; ++i){
    if (Curry._2(Char$negBase.equal, s[i], target)) {
      s[i] = replacement;
    }
    
  }
  
}

function tr_multi(target, replacement) {
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$eq, target.length, 0)) {
    return Staged$negBase.stage(function (prim) {
                
              });
  }
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$eq, replacement.length, 0)) {
    return Import$negBase.invalid_arg("tr_multi: replacement is the empty string");
  }
  var tr_map = Bytes_tr$negBase.tr_create_map(target, replacement);
  if (tr_map !== undefined) {
    return Staged$negBase.stage(function (s) {
                for(var i = 0 ,i_finish = Import$negBase.$neg(s.length, 1); i <= i_finish; ++i){
                  s[i] = tr_map.charCodeAt(Char$negBase.to_int(s[i]));
                }
                
              });
  } else {
    return Staged$negBase.stage(function (prim) {
                
              });
  }
}

function between(t, low, high) {
  if (Curry._2(Import$negBase.Bytes_replace_polymorphic_compare.$less$eq, low, t)) {
    return Curry._2(Import$negBase.Bytes_replace_polymorphic_compare.$less$eq, t, high);
  } else {
    return false;
  }
}

function clamp_unchecked(t, min, max) {
  if (Curry._2(Import$negBase.Bytes_replace_polymorphic_compare.$less, t, min)) {
    return min;
  } else if (Curry._2(Import$negBase.Bytes_replace_polymorphic_compare.$less$eq, t, max)) {
    return t;
  } else {
    return max;
  }
}

function clamp_exn(t, min, max) {
  if (!Curry._2(Import$negBase.Bytes_replace_polymorphic_compare.$less$eq, min, max)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "bytes.ml",
            128,
            2
          ],
          Error: new Error()
        };
  }
  return clamp_unchecked(t, min, max);
}

function clamp(t, min, max) {
  if (Curry._2(Import$negBase.Bytes_replace_polymorphic_compare.$great, min, max)) {
    return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                    hd: [
                      "min",
                      Import$negBase.sexp_of_bytes(min)
                    ],
                    tl: {
                      hd: [
                        "max",
                        Import$negBase.sexp_of_bytes(max)
                      ],
                      tl: /* [] */0
                    }
                  }));
  } else {
    return {
            TAG: /* Ok */0,
            _0: clamp_unchecked(t, min, max)
          };
  }
}

function contains(pos, len, t, $$char) {
  var match = Ordered_collection_common$negBase.get_pos_len_exn(pos, len, undefined, t.length);
  var pos$1 = match[0];
  var last = Import$negBase.$plus(pos$1, match[1]);
  var _i = pos$1;
  while(true) {
    var i = _i;
    if (!Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, i, last)) {
      return false;
    }
    if (Curry._2(Char$negBase.equal, Caml_bytes.get(t, i), $$char)) {
      return true;
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

var t_of_sexp = Import$negBase.bytes_of_sexp;

var sexp_of_t = Import$negBase.sexp_of_bytes;

var t_sexp_grammar = Import$negBase.bytes_sexp_grammar;

var blit = To_bytes.blit;

var blito = To_bytes.blito;

var unsafe_blit$1 = To_bytes.unsafe_blit;

var sub = To_bytes.sub;

var subo = To_bytes.subo;

var $great$eq = Import$negBase.Bytes_replace_polymorphic_compare.$great$eq;

var $less$eq = Import$negBase.Bytes_replace_polymorphic_compare.$less$eq;

var $eq = Import$negBase.Bytes_replace_polymorphic_compare.$eq;

var $great = Import$negBase.Bytes_replace_polymorphic_compare.$great;

var $less = Import$negBase.Bytes_replace_polymorphic_compare.$less;

var $less$great = Import$negBase.Bytes_replace_polymorphic_compare.$less$great;

var equal = Import$negBase.Bytes_replace_polymorphic_compare.equal;

var compare = Import$negBase.Bytes_replace_polymorphic_compare.compare;

var min = Import$negBase.Bytes_replace_polymorphic_compare.min;

var max = Import$negBase.Bytes_replace_polymorphic_compare.max;

var ascending = Import$negBase.Bytes_replace_polymorphic_compare.ascending;

var descending = Import$negBase.Bytes_replace_polymorphic_compare.descending;

var comparator = include.comparator;

var of_string = Bytes0$negBase.of_string;

var to_string = Bytes0$negBase.to_string;

var pp$1 = include$1.pp;

var create$2 = Bytes0$negBase.create;

var make = Bytes0$negBase.make;

var copy = Bytes0$negBase.copy;

function length$2(prim) {
  return prim.length;
}

var get = Caml_bytes.get;

var set = Caml_bytes.set;

var fill = Bytes0$negBase.fill;

var max_length = Bytes0$negBase.max_length;

var unsafe_to_string = Bytes0$negBase.unsafe_to_string;

var unsafe_of_string_promise_no_mutation = Bytes0$negBase.unsafe_of_string_promise_no_mutation;

exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.blit = blit;
exports.blito = blito;
exports.unsafe_blit = unsafe_blit$1;
exports.sub = sub;
exports.subo = subo;
exports.$great$eq = $great$eq;
exports.$less$eq = $less$eq;
exports.$eq = $eq;
exports.$great = $great;
exports.$less = $less;
exports.$less$great = $less$great;
exports.equal = equal;
exports.compare = compare;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.of_string = of_string;
exports.to_string = to_string;
exports.pp = pp$1;
exports.invariant = invariant;
exports.To_string = To_string;
exports.From_string = From_string;
exports.create = create$2;
exports.make = make;
exports.map = map;
exports.mapi = mapi;
exports.copy = copy;
exports.init = init;
exports.of_char_list = of_char_list;
exports.length = length$2;
exports.get = get;
exports.set = set;
exports.fill = fill;
exports.tr = tr;
exports.tr_multi = tr_multi;
exports.to_list = to_list;
exports.to_array = to_array;
exports.fold = fold;
exports.foldi = foldi;
exports.contains = contains;
exports.max_length = max_length;
exports.unsafe_to_string = unsafe_to_string;
exports.unsafe_of_string_promise_no_mutation = unsafe_of_string_promise_no_mutation;
/* To_bytes Not a pure module */
