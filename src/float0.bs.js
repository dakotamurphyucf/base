// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_float = require("bs-platform/lib/js/caml_float.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Caml_external_polyfill = require("bs-platform/lib/js/caml_external_polyfill.js");

function ceil(prim) {
  return Caml_external_polyfill.resolve("caml_ceil_float")(prim);
}

function floor(prim) {
  return Caml_external_polyfill.resolve("caml_floor_float")(prim);
}

function mod_float(prim, prim$1) {
  return prim % prim$1;
}

var modf = Caml_float.caml_modf_float;

var float_of_string = Caml_format.caml_float_of_string;

var nan = Import$negBase.Caml.nan;

var infinity = Import$negBase.Caml.infinity;

var neg_infinity = Import$negBase.Caml.neg_infinity;

var max_finite_value = Import$negBase.Caml.max_float;

var epsilon_float = Import$negBase.Caml.epsilon_float;

function classify_float(prim) {
  return Caml_external_polyfill.resolve("caml_classify_float")(prim);
}

function abs_float(f) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, f, 0)) {
    return Import$negBase.$star$dot(f, -1);
  } else {
    return f;
  }
}

function $star$star(prim, prim$1) {
  return Caml_external_polyfill.resolve("caml_power_float")(prim, prim$1);
}

var frexp = Caml_float.caml_frexp_float;

var ldexp = Caml_float.caml_ldexp_float;

function is_nan(x) {
  return Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$great, x, x);
}

function to_int64_preserve_order(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$great, t, t)) {
    return ;
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, 0)) {
    return Caml_int64.zero;
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0)) {
    return Caml_int64.bits_of_float(t);
  } else {
    return Caml_int64.neg(Caml_int64.bits_of_float(Import$negBase.$tilde$neg$dot(t)));
  }
}

function to_int64_preserve_order_exn(x) {
  return Option$negBase.value_exn(undefined, undefined, undefined, to_int64_preserve_order(x));
}

function of_int64_preserve_order(x) {
  if (Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$great$eq, x, Caml_int64.zero)) {
    return Caml_int64.float_of_bits(x);
  } else {
    return Import$negBase.$tilde$neg$dot(Caml_int64.float_of_bits(Caml_int64.neg(x)));
  }
}

function one_ulp(dir, t) {
  var x = to_int64_preserve_order(t);
  if (x !== undefined) {
    return of_int64_preserve_order(Caml_int64.add(x, dir === "Down" ? Caml_int64.neg_one : Caml_int64.one));
  } else {
    return Import$negBase.Caml.nan;
  }
}

function upper_bound_for_int(num_bits) {
  var exp = Import$negBase.$neg(num_bits, 1);
  return one_ulp("Down", Caml_external_polyfill.resolve("caml_power_float")(2, exp));
}

function is_x_minus_one_exact(x) {
  return !Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$eq, Caml_int64.bits_of_float(x), Caml_int64.bits_of_float(Import$negBase.$neg$dot(x, 1)));
}

function lower_bound_for_int(num_bits) {
  var exp = Import$negBase.$neg(num_bits, 1);
  var min_int_as_float = Import$negBase.$tilde$neg$dot(Caml_external_polyfill.resolve("caml_power_float")(2, exp));
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, Import$negBase.$neg(num_bits, 1), 53)) {
    if (!is_x_minus_one_exact(min_int_as_float)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "float0.ml",
              161,
              4
            ],
            Error: new Error()
          };
    }
    return one_ulp("Up", Import$negBase.$neg$dot(min_int_as_float, 1));
  }
  if (is_x_minus_one_exact(min_int_as_float)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "float0.ml",
            165,
            4
          ],
          Error: new Error()
        };
  }
  return min_int_as_float;
}

function clamp_unchecked(t, min, max) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, min)) {
    return min;
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, max, t)) {
    return max;
  } else {
    return t;
  }
}

function box(f) {
  return Import$negBase.$plus$dot(f, 0);
}

var $less = Import$negBase.Float_replace_polymorphic_compare.$less;

var $less$eq = Import$negBase.Float_replace_polymorphic_compare.$less$eq;

var $less$great = Import$negBase.Float_replace_polymorphic_compare.$less$great;

var $eq = Import$negBase.Float_replace_polymorphic_compare.$eq;

var $great = Import$negBase.Float_replace_polymorphic_compare.$great;

var $great$eq = Import$negBase.Float_replace_polymorphic_compare.$great$eq;

var ascending = Import$negBase.Float_replace_polymorphic_compare.ascending;

var descending = Import$negBase.Float_replace_polymorphic_compare.descending;

var compare = Import$negBase.Float_replace_polymorphic_compare.compare;

var equal = Import$negBase.Float_replace_polymorphic_compare.equal;

var max = Import$negBase.Float_replace_polymorphic_compare.max;

var min = Import$negBase.Float_replace_polymorphic_compare.min;

exports.ceil = ceil;
exports.floor = floor;
exports.mod_float = mod_float;
exports.modf = modf;
exports.float_of_string = float_of_string;
exports.nan = nan;
exports.infinity = infinity;
exports.neg_infinity = neg_infinity;
exports.max_finite_value = max_finite_value;
exports.epsilon_float = epsilon_float;
exports.classify_float = classify_float;
exports.abs_float = abs_float;
exports.$star$star = $star$star;
exports.frexp = frexp;
exports.ldexp = ldexp;
exports.is_nan = is_nan;
exports.to_int64_preserve_order = to_int64_preserve_order;
exports.to_int64_preserve_order_exn = to_int64_preserve_order_exn;
exports.of_int64_preserve_order = of_int64_preserve_order;
exports.one_ulp = one_ulp;
exports.upper_bound_for_int = upper_bound_for_int;
exports.is_x_minus_one_exact = is_x_minus_one_exact;
exports.lower_bound_for_int = lower_bound_for_int;
exports.clamp_unchecked = clamp_unchecked;
exports.box = box;
exports.$less = $less;
exports.$less$eq = $less$eq;
exports.$less$great = $less$great;
exports.$eq = $eq;
exports.$great = $great;
exports.$great$eq = $great$eq;
exports.ascending = ascending;
exports.descending = descending;
exports.compare = compare;
exports.equal = equal;
exports.max = max;
exports.min = min;
/* Import-Base Not a pure module */
