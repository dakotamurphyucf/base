// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Import$negBase = require("./import.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function Of_sexpable(Sexpable, M) {
  var t_of_sexp = function (sexp) {
    var s = Curry._1(Sexpable.t_of_sexp, sexp);
    try {
      return Curry._1(M.of_sexpable, s);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      return Import$negBase.of_sexp_error_exn(exn, sexp);
    }
  };
  var sexp_of_t = function (t) {
    return Curry._1(Sexpable.sexp_of_t, Curry._1(M.to_sexpable, t));
  };
  return {
          t_of_sexp: t_of_sexp,
          sexp_of_t: sexp_of_t
        };
}

function Of_sexpable1(Sexpable, M) {
  var t_of_sexp = function (a_of_sexp, sexp) {
    var s = Curry._2(Sexpable.t_of_sexp, a_of_sexp, sexp);
    try {
      return Curry._1(M.of_sexpable, s);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      return Import$negBase.of_sexp_error_exn(exn, sexp);
    }
  };
  var sexp_of_t = function (sexp_of_a, t) {
    return Curry._2(Sexpable.sexp_of_t, sexp_of_a, Curry._1(M.to_sexpable, t));
  };
  return {
          t_of_sexp: t_of_sexp,
          sexp_of_t: sexp_of_t
        };
}

function Of_sexpable2(Sexpable, M) {
  var t_of_sexp = function (a_of_sexp, b_of_sexp, sexp) {
    var s = Curry._3(Sexpable.t_of_sexp, a_of_sexp, b_of_sexp, sexp);
    try {
      return Curry._1(M.of_sexpable, s);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      return Import$negBase.of_sexp_error_exn(exn, sexp);
    }
  };
  var sexp_of_t = function (sexp_of_a, sexp_of_b, t) {
    return Curry._3(Sexpable.sexp_of_t, sexp_of_a, sexp_of_b, Curry._1(M.to_sexpable, t));
  };
  return {
          t_of_sexp: t_of_sexp,
          sexp_of_t: sexp_of_t
        };
}

function Of_sexpable3(Sexpable, M) {
  var t_of_sexp = function (a_of_sexp, b_of_sexp, c_of_sexp, sexp) {
    var s = Curry._4(Sexpable.t_of_sexp, a_of_sexp, b_of_sexp, c_of_sexp, sexp);
    try {
      return Curry._1(M.of_sexpable, s);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      return Import$negBase.of_sexp_error_exn(exn, sexp);
    }
  };
  var sexp_of_t = function (sexp_of_a, sexp_of_b, sexp_of_c, t) {
    return Curry._4(Sexpable.sexp_of_t, sexp_of_a, sexp_of_b, sexp_of_c, Curry._1(M.to_sexpable, t));
  };
  return {
          t_of_sexp: t_of_sexp,
          sexp_of_t: sexp_of_t
        };
}

function Of_stringable(M) {
  var t_of_sexp = function (sexp) {
    if (sexp.TAG !== /* Atom */0) {
      return Import$negBase.of_sexp_error("Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list", sexp);
    }
    try {
      return Curry._1(M.of_string, sexp._0);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      return Import$negBase.of_sexp_error_exn(exn, sexp);
    }
  };
  var sexp_of_t = function (t) {
    return {
            TAG: /* Atom */0,
            _0: Curry._1(M.to_string, t)
          };
  };
  return {
          t_of_sexp: t_of_sexp,
          sexp_of_t: sexp_of_t
        };
}

exports.Of_sexpable = Of_sexpable;
exports.Of_sexpable1 = Of_sexpable1;
exports.Of_sexpable2 = Of_sexpable2;
exports.Of_sexpable3 = Of_sexpable3;
exports.Of_stringable = Of_stringable;
/* Import-Base Not a pure module */
