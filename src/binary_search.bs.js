// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Fn$negBase = require("./fn.bs.js");
var Import$negBase = require("./import.bs.js");
var Ordered_collection_common$negBase = require("./ordered_collection_common.bs.js");

function find_range_near_first_satisfying(t, get, _lo, _hi, pred) {
  while(true) {
    var hi = _hi;
    var lo = _lo;
    if (Import$negBase.$less$eq(Import$negBase.$neg(hi, lo), 8)) {
      return [
              lo,
              hi
            ];
    }
    var mid = Import$negBase.$plus(lo, Import$negBase.$slash(Import$negBase.$neg(hi, lo), 2));
    if (Curry._1(pred, Curry._2(get, t, mid))) {
      _hi = mid;
      continue ;
    }
    _lo = Import$negBase.$plus(mid, 1);
    continue ;
  };
}

function find_first_satisfying(pos, len, t, get, length, pred) {
  var match = Ordered_collection_common$negBase.get_pos_len_exn(pos, len, undefined, Curry._1(length, t));
  var pos$1 = match[0];
  var hi = Import$negBase.$neg(Import$negBase.$plus(pos$1, match[1]), 1);
  var match$1 = find_range_near_first_satisfying(t, get, pos$1, hi, pred);
  var _lo = match$1[0];
  var hi$1 = match$1[1];
  while(true) {
    var lo = _lo;
    if (Import$negBase.$great(lo, hi$1)) {
      return ;
    }
    if (Curry._1(pred, Curry._2(get, t, lo))) {
      return lo;
    }
    _lo = Import$negBase.$plus(lo, 1);
    continue ;
  };
}

function find_last_satisfying(pos, len, t, pred, get, length) {
  var match = Ordered_collection_common$negBase.get_pos_len_exn(pos, len, undefined, Curry._1(length, t));
  var len$1 = match[1];
  if (len$1 === 0) {
    return ;
  }
  var pos$1 = match[0];
  var i = find_first_satisfying(pos$1, len$1, t, get, length, (function (param) {
          return Fn$negBase.non(pred, param);
        }));
  if (i !== undefined) {
    if (i === pos$1) {
      return ;
    } else {
      return Import$negBase.$neg(i, 1);
    }
  } else {
    return Import$negBase.$neg(Import$negBase.$plus(pos$1, len$1), 1);
  }
}

function binary_search(pos, len, t, length, get, compare, how, v) {
  if (how === "Last_equal_to") {
    var x = find_last_satisfying(pos, len, t, (function (x) {
            return Import$negBase.$less$eq(Curry._2(compare, x, v), 0);
          }), get, length);
    if (x !== undefined && Curry._2(compare, Curry._2(get, t, x), v) === 0) {
      return x;
    } else {
      return ;
    }
  }
  if (how === "First_strictly_greater_than") {
    return find_first_satisfying(pos, len, t, get, length, (function (x) {
                  return Import$negBase.$great(Curry._2(compare, x, v), 0);
                }));
  }
  if (how === "Last_less_than_or_equal_to") {
    return find_last_satisfying(pos, len, t, (function (x) {
                  return Import$negBase.$less$eq(Curry._2(compare, x, v), 0);
                }), get, length);
  }
  if (how === "Last_strictly_less_than") {
    return find_last_satisfying(pos, len, t, (function (x) {
                  return Import$negBase.$less(Curry._2(compare, x, v), 0);
                }), get, length);
  }
  if (how === "First_greater_than_or_equal_to") {
    return find_first_satisfying(pos, len, t, get, length, (function (x) {
                  return Import$negBase.$great$eq(Curry._2(compare, x, v), 0);
                }));
  }
  var x$1 = find_first_satisfying(pos, len, t, get, length, (function (x) {
          return Import$negBase.$great$eq(Curry._2(compare, x, v), 0);
        }));
  if (x$1 !== undefined && Curry._2(compare, Curry._2(get, t, x$1), v) === 0) {
    return x$1;
  }
  
}

function binary_search_segmented(pos, len, t, length, get, segment_of, how) {
  var is_left = function (x) {
    var match = Curry._1(segment_of, x);
    return match === "Left";
  };
  var is_right = function (x) {
    return !is_left(x);
  };
  if (how === "Last_on_left") {
    return find_last_satisfying(pos, len, t, is_left, get, length);
  } else {
    return find_first_satisfying(pos, len, t, get, length, is_right);
  }
}

exports.binary_search = binary_search;
exports.binary_search_segmented = binary_search_segmented;
/* Fn-Base Not a pure module */
