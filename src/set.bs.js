// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Fn$negBase = require("./fn.bs.js");
var Hash$negBase = require("./hash.bs.js");
var List$negBase = require("./list.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Sequence$negBase = require("./sequence.bs.js");
var Set_intf$negBase = require("./set_intf.bs.js");
var Container$negBase = require("./container.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Comparator$negBase = require("./comparator.bs.js");
var With_return$negBase = require("./with_return.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Sexp_conv$negSexplib0 = require("sexplib0/./sexp_conv.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");

function height(param) {
  if (typeof param === "number") {
    return 0;
  } else if (param.TAG === /* Leaf */0) {
    return 1;
  } else {
    return param._3;
  }
}

function length(param) {
  if (typeof param === "number") {
    return 0;
  } else if (param.TAG === /* Leaf */0) {
    return 1;
  } else {
    return param._4;
  }
}

function in_range(lower, upper, compare_elt, v) {
  if (lower !== undefined ? Import$negBase.$less(Curry._2(compare_elt, Caml_option.valFromOption(lower), v), 0) : true) {
    if (upper !== undefined) {
      return Import$negBase.$less(Curry._2(compare_elt, v, Caml_option.valFromOption(upper)), 0);
    } else {
      return true;
    }
  } else {
    return false;
  }
}

function loop(_lower, upper, compare_elt, _t) {
  while(true) {
    var t = _t;
    var lower = _lower;
    if (typeof t === "number") {
      return true;
    }
    if (t.TAG === /* Leaf */0) {
      return in_range(lower, upper, compare_elt, t._0);
    }
    var r = t._2;
    var v = t._1;
    var l = t._0;
    var hl = height(l);
    var hr = height(r);
    if (!Import$negBase.$less$eq(Import$negBase.abs(Import$negBase.$neg(hl, hr)), 2)) {
      return false;
    }
    if (t._3 !== Import$negBase.$plus(Import$negBase.max(hl, hr), 1)) {
      return false;
    }
    if (t._4 !== Import$negBase.$plus(Import$negBase.$plus(length(l), length(r)), 1)) {
      return false;
    }
    if (!in_range(lower, upper, compare_elt, v)) {
      return false;
    }
    if (!loop(lower, Caml_option.some(v), compare_elt, l)) {
      return false;
    }
    _t = r;
    _lower = Caml_option.some(v);
    continue ;
  };
}

function invariants(t, compare_elt) {
  return loop(undefined, undefined, compare_elt, t);
}

function is_empty(param) {
  if (typeof param === "number") {
    return true;
  } else {
    return false;
  }
}

function create(l, v, r) {
  var hl;
  hl = typeof l === "number" ? 0 : (
      l.TAG === /* Leaf */0 ? 1 : l._3
    );
  var hr;
  hr = typeof r === "number" ? 0 : (
      r.TAG === /* Leaf */0 ? 1 : r._3
    );
  var h = Import$negBase.$great$eq(hl, hr) ? Import$negBase.$plus(hl, 1) : Import$negBase.$plus(hr, 1);
  if (h === 1) {
    return {
            TAG: /* Leaf */0,
            _0: v
          };
  }
  var sl;
  sl = typeof l === "number" ? 0 : (
      l.TAG === /* Leaf */0 ? 1 : l._4
    );
  var sr;
  sr = typeof r === "number" ? 0 : (
      r.TAG === /* Leaf */0 ? 1 : r._4
    );
  return {
          TAG: /* Node */1,
          _0: l,
          _1: v,
          _2: r,
          _3: h,
          _4: Import$negBase.$plus(Import$negBase.$plus(sl, sr), 1)
        };
}

function of_increasing_iterator_unchecked(len, f) {
  var loop = function (n, f, i) {
    switch (n) {
      case 0 :
          return /* Empty */0;
      case 1 :
          var k = Curry._1(f, i);
          return {
                  TAG: /* Leaf */0,
                  _0: k
                };
      case 2 :
          var kl = Curry._1(f, i);
          var k$1 = Curry._1(f, Import$negBase.$plus(i, 1));
          return create({
                      TAG: /* Leaf */0,
                      _0: kl
                    }, k$1, /* Empty */0);
      case 3 :
          var kl$1 = Curry._1(f, i);
          var k$2 = Curry._1(f, Import$negBase.$plus(i, 1));
          var kr = Curry._1(f, Import$negBase.$plus(i, 2));
          return create({
                      TAG: /* Leaf */0,
                      _0: kl$1
                    }, k$2, {
                      TAG: /* Leaf */0,
                      _0: kr
                    });
      default:
        var left_length = Import$negBase.lsr(n, 1);
        var right_length = Import$negBase.$neg(Import$negBase.$neg(n, left_length), 1);
        var left = loop(left_length, f, i);
        var k$3 = Curry._1(f, Import$negBase.$plus(i, left_length));
        var right = loop(right_length, f, Import$negBase.$plus(Import$negBase.$plus(i, left_length), 1));
        return create(left, k$3, right);
    }
  };
  return loop(len, f, 0);
}

function of_sorted_array_unchecked(array, compare_elt) {
  var array_length = array.length;
  var next = Import$negBase.$less(array_length, 2) || Import$negBase.$less(Curry._2(compare_elt, Caml_array.get(array, 0), Caml_array.get(array, 1)), 0) ? (function (i) {
        return Caml_array.get(array, i);
      }) : (function (i) {
        return Caml_array.get(array, Import$negBase.$neg(Import$negBase.$neg(array_length, 1), i));
      });
  return of_increasing_iterator_unchecked(array_length, next);
}

function of_sorted_array(array, compare_elt) {
  var len = array.length;
  if (len !== 1 && len) {
    return With_return$negBase.with_return(function (r) {
                var i = Curry._2(compare_elt, Caml_array.get(array, 0), Caml_array.get(array, 1));
                var increasing = i !== 0 ? Import$negBase.$less(i, 0) : Curry._1(r, Or_error$negBase.error_string("of_sorted_array: duplicated elements"));
                for(var i$1 = 1 ,i_finish = Import$negBase.$neg(array.length, 2); i$1 <= i_finish; ++i$1){
                  var i$2 = Curry._2(compare_elt, Caml_array.get(array, i$1), Caml_array.get(array, Import$negBase.$plus(i$1, 1)));
                  if (i$2 !== 0) {
                    if (Import$negBase.$less(i$2, 0) !== increasing) {
                      Curry._1(r, Or_error$negBase.error_string("of_sorted_array: elements are not ordered"));
                    }
                    
                  } else {
                    Curry._1(r, Or_error$negBase.error_string("of_sorted_array: duplicated elements"));
                  }
                }
                return {
                        TAG: /* Ok */0,
                        _0: of_sorted_array_unchecked(array, compare_elt)
                      };
              });
  } else {
    return {
            TAG: /* Ok */0,
            _0: of_sorted_array_unchecked(array, compare_elt)
          };
  }
}

function bal(l, v, r) {
  var hl;
  hl = typeof l === "number" ? 0 : (
      l.TAG === /* Leaf */0 ? 1 : l._3
    );
  var hr;
  hr = typeof r === "number" ? 0 : (
      r.TAG === /* Leaf */0 ? 1 : r._3
    );
  if (Import$negBase.$great(hl, Import$negBase.$plus(hr, 2))) {
    if (typeof l === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "set.ml",
              200,
              17
            ],
            Error: new Error()
          };
    }
    if (l.TAG === /* Leaf */0) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "set.ml",
              201,
              18
            ],
            Error: new Error()
          };
    }
    var lr = l._2;
    var lv = l._1;
    var ll = l._0;
    if (Import$negBase.$great$eq(height(ll), height(lr))) {
      return create(ll, lv, create(lr, v, r));
    }
    if (typeof lr === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "set.ml",
              207,
              21
            ],
            Error: new Error()
          };
    }
    if (lr.TAG !== /* Leaf */0) {
      return create(create(ll, lv, lr._0), lr._1, create(lr._2, v, r));
    }
    if (!is_empty(ll)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "set.ml",
              209,
              12
            ],
            Error: new Error()
          };
    }
    return create(create(ll, lv, /* Empty */0), lr._0, create(/* Empty */0, v, r));
  } else if (Import$negBase.$great(hr, Import$negBase.$plus(hl, 2))) {
    if (typeof r === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "set.ml",
              215,
              17
            ],
            Error: new Error()
          };
    }
    if (r.TAG === /* Leaf */0) {
      return create(create(l, v, /* Empty */0), r._0, /* Empty */0);
    }
    var rr = r._2;
    var rv = r._1;
    var rl = r._0;
    if (Import$negBase.$great$eq(height(rr), height(rl))) {
      return create(create(l, v, rl), rv, rr);
    }
    if (typeof rl === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "set.ml",
              222,
              21
            ],
            Error: new Error()
          };
    }
    if (rl.TAG !== /* Leaf */0) {
      return create(create(l, v, rl._0), rl._1, create(rl._2, rv, rr));
    }
    if (!is_empty(rr)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "set.ml",
              224,
              12
            ],
            Error: new Error()
          };
    }
    return create(create(l, v, /* Empty */0), rl._0, create(/* Empty */0, rv, rr));
  } else {
    var h = Import$negBase.$great$eq(hl, hr) ? Import$negBase.$plus(hl, 1) : Import$negBase.$plus(hr, 1);
    var sl;
    sl = typeof l === "number" ? 0 : (
        l.TAG === /* Leaf */0 ? 1 : l._4
      );
    var sr;
    sr = typeof r === "number" ? 0 : (
        r.TAG === /* Leaf */0 ? 1 : r._4
      );
    if (h === 1) {
      return {
              TAG: /* Leaf */0,
              _0: v
            };
    } else {
      return {
              TAG: /* Node */1,
              _0: l,
              _1: v,
              _2: r,
              _3: h,
              _4: Import$negBase.$plus(Import$negBase.$plus(sl, sr), 1)
            };
    }
  }
}

var Same = /* @__PURE__ */Caml_exceptions.create("Set-Base.Tree0.Same");

function add(t, x, compare_elt) {
  var aux = function (v) {
    if (typeof v === "number") {
      return {
              TAG: /* Leaf */0,
              _0: x
            };
    }
    if (v.TAG === /* Leaf */0) {
      var v$1 = v._0;
      var c = Curry._2(compare_elt, x, v$1);
      if (c === 0) {
        throw {
              RE_EXN_ID: Same,
              Error: new Error()
            };
      }
      if (Import$negBase.$less(c, 0)) {
        return bal({
                    TAG: /* Leaf */0,
                    _0: x
                  }, v$1, /* Empty */0);
      } else {
        return bal(/* Empty */0, v$1, {
                    TAG: /* Leaf */0,
                    _0: x
                  });
      }
    }
    var r = v._2;
    var v$2 = v._1;
    var l = v._0;
    var c$1 = Curry._2(compare_elt, x, v$2);
    if (c$1 === 0) {
      throw {
            RE_EXN_ID: Same,
            Error: new Error()
          };
    }
    if (Import$negBase.$less(c$1, 0)) {
      return bal(aux(l), v$2, r);
    } else {
      return bal(l, v$2, aux(r));
    }
  };
  try {
    return aux(t);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Same) {
      return t;
    }
    throw exn;
  }
}

function join(l, v, r, compare_elt) {
  if (typeof l === "number") {
    return add(r, v, compare_elt);
  }
  if (l.TAG !== /* Leaf */0) {
    var lh = l._3;
    if (typeof r !== "number") {
      if (r.TAG === /* Leaf */0) {
        return add(add(l, v, compare_elt), r._0, compare_elt);
      }
      var rh = r._3;
      if (Import$negBase.$great(lh, Import$negBase.$plus(rh, 2))) {
        return bal(l._0, l._1, join(l._2, v, r, compare_elt));
      } else if (Import$negBase.$great(rh, Import$negBase.$plus(lh, 2))) {
        return bal(join(l, v, r._0, compare_elt), r._1, r._2);
      } else {
        return create(l, v, r);
      }
    }
    
  }
  if (typeof r === "number") {
    return add(l, v, compare_elt);
  } else {
    return add(add(r, v, compare_elt), l._0, compare_elt);
  }
}

function min_elt(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG === /* Leaf */0) {
      return Caml_option.some(param._0);
    }
    var l = param._0;
    if (typeof l === "number") {
      return Caml_option.some(param._1);
    }
    _param = l;
    continue ;
  };
}

var Set_min_elt_exn_of_empty_set = /* @__PURE__ */Caml_exceptions.create("Set-Base.Tree0.Set_min_elt_exn_of_empty_set");

Sexp_conv$negSexplib0.Exn_converter.add(undefined, undefined, Set_min_elt_exn_of_empty_set, (function (param) {
        if (param.RE_EXN_ID === Set_min_elt_exn_of_empty_set) {
          return {
                  TAG: /* Atom */0,
                  _0: "set.ml.Tree0.Set_min_elt_exn_of_empty_set"
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "set.ml",
                297,
                15
              ],
              Error: new Error()
            };
      }));

var Set_max_elt_exn_of_empty_set = /* @__PURE__ */Caml_exceptions.create("Set-Base.Tree0.Set_max_elt_exn_of_empty_set");

Sexp_conv$negSexplib0.Exn_converter.add(undefined, undefined, Set_max_elt_exn_of_empty_set, (function (param) {
        if (param.RE_EXN_ID === Set_max_elt_exn_of_empty_set) {
          return {
                  TAG: /* Atom */0,
                  _0: "set.ml.Tree0.Set_max_elt_exn_of_empty_set"
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "set.ml",
                310,
                15
              ],
              Error: new Error()
            };
      }));

function min_elt_exn(t) {
  var v = min_elt(t);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw {
        RE_EXN_ID: Set_min_elt_exn_of_empty_set,
        Error: new Error()
      };
}

function fold_until(t, init, f, finish) {
  var fold_until_helper = function (f, _t, _acc) {
    while(true) {
      var acc = _acc;
      var t = _t;
      if (typeof t === "number") {
        return {
                TAG: /* Continue */0,
                _0: acc
              };
      }
      if (t.TAG === /* Leaf */0) {
        return Curry._2(f, acc, t._0);
      }
      var x = fold_until_helper(f, t._0, acc);
      if (x.TAG !== /* Continue */0) {
        return x;
      }
      var x$1 = Curry._2(f, x._0, t._1);
      if (x$1.TAG !== /* Continue */0) {
        return x$1;
      }
      _acc = x$1._0;
      _t = t._2;
      continue ;
    };
  };
  var x = fold_until_helper(f, t, init);
  if (x.TAG === /* Continue */0) {
    return Curry._1(finish, x._0);
  } else {
    return x._0;
  }
}

function max_elt(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG === /* Leaf */0) {
      return Caml_option.some(param._0);
    }
    if (typeof param._2 === "number") {
      return Caml_option.some(param._1);
    }
    _param = param._2;
    continue ;
  };
}

function max_elt_exn(t) {
  var v = max_elt(t);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw {
        RE_EXN_ID: Set_max_elt_exn_of_empty_set,
        Error: new Error()
      };
}

function remove_min_elt(param) {
  if (typeof param === "number") {
    return Import$negBase.invalid_arg("Set.remove_min_elt");
  }
  if (param.TAG === /* Leaf */0) {
    return /* Empty */0;
  }
  var l = param._0;
  if (typeof l === "number") {
    return param._2;
  } else {
    return bal(remove_min_elt(l), param._1, param._2);
  }
}

function merge(t1, t2) {
  if (typeof t1 === "number") {
    return t2;
  } else if (typeof t2 === "number") {
    return t1;
  } else {
    return bal(t1, min_elt_exn(t2), remove_min_elt(t2));
  }
}

function concat(t1, t2, compare_elt) {
  if (typeof t1 === "number") {
    return t2;
  } else if (typeof t2 === "number") {
    return t1;
  } else {
    return join(t1, min_elt_exn(t2), remove_min_elt(t2), compare_elt);
  }
}

function split(t, x, compare_elt) {
  var split$1 = function (t) {
    if (typeof t === "number") {
      return [
              /* Empty */0,
              undefined,
              /* Empty */0
            ];
    }
    if (t.TAG === /* Leaf */0) {
      var v = t._0;
      var c = Curry._2(compare_elt, x, v);
      if (c === 0) {
        return [
                /* Empty */0,
                Caml_option.some(v),
                /* Empty */0
              ];
      } else if (Import$negBase.$less(c, 0)) {
        return [
                /* Empty */0,
                undefined,
                {
                  TAG: /* Leaf */0,
                  _0: v
                }
              ];
      } else {
        return [
                {
                  TAG: /* Leaf */0,
                  _0: v
                },
                undefined,
                /* Empty */0
              ];
      }
    }
    var r = t._2;
    var v$1 = t._1;
    var l = t._0;
    var c$1 = Curry._2(compare_elt, x, v$1);
    if (c$1 === 0) {
      return [
              l,
              Caml_option.some(v$1),
              r
            ];
    }
    if (Import$negBase.$less(c$1, 0)) {
      var match = split$1(l);
      return [
              match[0],
              match[1],
              join(match[2], v$1, r, compare_elt)
            ];
    }
    var match$1 = split$1(r);
    return [
            join(l, v$1, match$1[0], compare_elt),
            match$1[1],
            match$1[2]
          ];
  };
  return split$1(t);
}

function mem(_t, x, compare_elt) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return false;
    }
    if (t.TAG === /* Leaf */0) {
      var c = Curry._2(compare_elt, x, t._0);
      return c === 0;
    }
    var c$1 = Curry._2(compare_elt, x, t._1);
    if (c$1 === 0) {
      return true;
    }
    _t = Import$negBase.$less(c$1, 0) ? t._0 : t._2;
    continue ;
  };
}

function remove(t, x, compare_elt) {
  var aux = function (t) {
    if (typeof t === "number") {
      throw {
            RE_EXN_ID: Same,
            Error: new Error()
          };
    }
    if (t.TAG === /* Leaf */0) {
      if (Curry._2(compare_elt, x, t._0) === 0) {
        return /* Empty */0;
      }
      throw {
            RE_EXN_ID: Same,
            Error: new Error()
          };
    }
    var r = t._2;
    var v = t._1;
    var l = t._0;
    var c = Curry._2(compare_elt, x, v);
    if (c === 0) {
      return merge(l, r);
    } else if (Import$negBase.$less(c, 0)) {
      return bal(aux(l), v, r);
    } else {
      return bal(l, v, aux(r));
    }
  };
  try {
    return aux(t);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Same) {
      return t;
    }
    throw exn;
  }
}

function remove_index(t, i, param) {
  var aux = function (t, i) {
    if (typeof t === "number") {
      throw {
            RE_EXN_ID: Same,
            Error: new Error()
          };
    }
    if (t.TAG === /* Leaf */0) {
      if (i === 0) {
        return /* Empty */0;
      }
      throw {
            RE_EXN_ID: Same,
            Error: new Error()
          };
    }
    var r = t._2;
    var v = t._1;
    var l = t._0;
    var l_size = length(l);
    var c = Caml.caml_int_compare(i, l_size);
    if (c === 0) {
      return merge(l, r);
    } else if (Import$negBase.$less(c, 0)) {
      return bal(aux(l, i), v, r);
    } else {
      return bal(l, v, aux(r, Import$negBase.$neg(Import$negBase.$neg(i, l_size), 1)));
    }
  };
  try {
    return aux(t, i);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Same) {
      return t;
    }
    throw exn;
  }
}

function union(s1, s2, compare_elt) {
  var union$1 = function (_s1, _s2) {
    while(true) {
      var s2 = _s2;
      var s1 = _s1;
      if (Import$negBase.phys_equal(s1, s2)) {
        return s1;
      }
      if (typeof s1 === "number") {
        return s2;
      }
      if (s1.TAG !== /* Leaf */0) {
        var h1 = s1._3;
        var v1 = s1._1;
        if (typeof s2 !== "number") {
          if (s2.TAG === /* Leaf */0) {
            _s2 = {
              TAG: /* Node */1,
              _0: /* Empty */0,
              _1: s2._0,
              _2: /* Empty */0,
              _3: 1,
              _4: 1
            };
            continue ;
          }
          var h2 = s2._3;
          var v2 = s2._1;
          if (Import$negBase.$great$eq(h1, h2)) {
            if (h2 === 1) {
              return add(s1, v2, compare_elt);
            }
            var match = split(s2, v1, compare_elt);
            return join(union$1(s1._0, match[0]), v1, union$1(s1._2, match[2]), compare_elt);
          }
          if (h1 === 1) {
            return add(s2, v1, compare_elt);
          }
          var match$1 = split(s1, v2, compare_elt);
          return join(union$1(match$1[0], s2._0), v2, union$1(match$1[2], s2._2), compare_elt);
        }
        
      }
      if (typeof s2 === "number") {
        return s1;
      }
      _s1 = {
        TAG: /* Node */1,
        _0: /* Empty */0,
        _1: s1._0,
        _2: /* Empty */0,
        _3: 1,
        _4: 1
      };
      continue ;
    };
  };
  return union$1(s1, s2);
}

function union_list(comparator, to_tree, xs) {
  var compare_elt = comparator.compare;
  return List$negBase.fold(xs, /* Empty */0, (function (ac, x) {
                return union(ac, Curry._1(to_tree, x), compare_elt);
              }));
}

function inter(s1, s2, compare_elt) {
  var inter$1 = function (s1, s2) {
    if (Import$negBase.phys_equal(s1, s2)) {
      return s1;
    }
    var elt;
    var singleton;
    var other_set;
    if (typeof s1 === "number") {
      return /* Empty */0;
    }
    if (typeof s2 === "number") {
      return /* Empty */0;
    }
    if (typeof s1 !== "number") {
      if (s1.TAG === /* Leaf */0) {
        elt = s1._0;
        singleton = s1;
        other_set = s2;
      } else if (typeof s2 !== "number") {
        if (s2.TAG === /* Leaf */0) {
          elt = s2._0;
          singleton = s2;
          other_set = s1;
        } else {
          var r1 = s1._2;
          var l1 = s1._0;
          var match = split(s2, s1._1, compare_elt);
          var v1 = match[1];
          var l2 = match[0];
          if (v1 !== undefined) {
            return join(inter$1(l1, l2), Caml_option.valFromOption(v1), inter$1(r1, match[2]), compare_elt);
          } else {
            return concat(inter$1(l1, l2), inter$1(r1, match[2]), compare_elt);
          }
        }
      }
      
    }
    if (mem(other_set, elt, compare_elt)) {
      return singleton;
    } else {
      return /* Empty */0;
    }
  };
  return inter$1(s1, s2);
}

function diff(s1, s2, compare_elt) {
  var diff$1 = function (_s1, s2) {
    while(true) {
      var s1 = _s1;
      if (Import$negBase.phys_equal(s1, s2)) {
        return /* Empty */0;
      }
      if (typeof s1 === "number") {
        return /* Empty */0;
      }
      if (typeof s2 === "number") {
        return s1;
      }
      if (typeof s1 !== "number") {
        if (s1.TAG === /* Leaf */0) {
          _s1 = {
            TAG: /* Node */1,
            _0: /* Empty */0,
            _1: s1._0,
            _2: /* Empty */0,
            _3: 1,
            _4: 1
          };
          continue ;
        }
        var r1 = s1._2;
        var v1 = s1._1;
        var l1 = s1._0;
        var match = split(s2, v1, compare_elt);
        var l2 = match[0];
        if (match[1] !== undefined) {
          return concat(diff$1(l1, l2), diff$1(r1, match[2]), compare_elt);
        } else {
          return join(diff$1(l1, l2), v1, diff$1(r1, match[2]), compare_elt);
        }
      }
      
    };
  };
  return diff$1(s1, s2);
}

function cons(_s, _e) {
  while(true) {
    var e = _e;
    var s = _s;
    if (typeof s === "number") {
      return e;
    }
    if (s.TAG === /* Leaf */0) {
      return /* More */{
              _0: s._0,
              _1: /* Empty */0,
              _2: e
            };
    }
    _e = /* More */{
      _0: s._1,
      _1: s._2,
      _2: e
    };
    _s = s._0;
    continue ;
  };
}

function cons_right(_s, _e) {
  while(true) {
    var e = _e;
    var s = _s;
    if (typeof s === "number") {
      return e;
    }
    if (s.TAG === /* Leaf */0) {
      return /* More */{
              _0: s._0,
              _1: /* Empty */0,
              _2: e
            };
    }
    _e = /* More */{
      _0: s._1,
      _1: s._0,
      _2: e
    };
    _s = s._2;
    continue ;
  };
}

function starting_at_increasing(t, key, compare) {
  var _t = t;
  var _e = /* End */0;
  while(true) {
    var e = _e;
    var t$1 = _t;
    if (typeof t$1 === "number") {
      return e;
    }
    if (t$1.TAG === /* Leaf */0) {
      _t = {
        TAG: /* Node */1,
        _0: /* Empty */0,
        _1: t$1._0,
        _2: /* Empty */0,
        _3: 1,
        _4: 1
      };
      continue ;
    }
    if (Import$negBase.$less(Curry._2(compare, t$1._1, key), 0)) {
      _t = t$1._2;
      continue ;
    }
    _e = /* More */{
      _0: t$1._1,
      _1: t$1._2,
      _2: e
    };
    _t = t$1._0;
    continue ;
  };
}

function starting_at_decreasing(t, key, compare) {
  var _t = t;
  var _e = /* End */0;
  while(true) {
    var e = _e;
    var t$1 = _t;
    if (typeof t$1 === "number") {
      return e;
    }
    if (t$1.TAG === /* Leaf */0) {
      _t = {
        TAG: /* Node */1,
        _0: /* Empty */0,
        _1: t$1._0,
        _2: /* Empty */0,
        _3: 1,
        _4: 1
      };
      continue ;
    }
    var l = t$1._0;
    if (Import$negBase.$great(Curry._2(compare, t$1._1, key), 0)) {
      _t = l;
      continue ;
    }
    _e = /* More */{
      _0: t$1._1,
      _1: l,
      _2: e
    };
    _t = t$1._2;
    continue ;
  };
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    Curry._1(f, param._0);
    _param = cons(param._1, param._2);
    continue ;
  };
}

function symmetric_diff(t1, t2, compare_elt) {
  var step = function (state) {
    var left = state[0];
    if (left) {
      var right = state[1];
      var $$enum = left._2;
      var tree = left._1;
      var elt = left._0;
      if (!right) {
        return {
                TAG: /* Yield */1,
                _0: {
                  TAG: /* First */0,
                  _0: elt
                },
                _1: [
                  cons(tree, $$enum),
                  /* End */0
                ]
              };
      }
      var enum2 = right._2;
      var tree2 = right._1;
      var a2 = right._0;
      var compare_result = Curry._2(compare_elt, elt, a2);
      if (compare_result !== 0) {
        if (Import$negBase.$less(compare_result, 0)) {
          return {
                  TAG: /* Yield */1,
                  _0: {
                    TAG: /* First */0,
                    _0: elt
                  },
                  _1: [
                    cons(tree, $$enum),
                    right
                  ]
                };
        } else {
          return {
                  TAG: /* Yield */1,
                  _0: {
                    TAG: /* Second */1,
                    _0: a2
                  },
                  _1: [
                    left,
                    cons(tree2, enum2)
                  ]
                };
        }
      }
      var next_state = Import$negBase.phys_equal(tree, tree2) ? [
          $$enum,
          enum2
        ] : [
          cons(tree, $$enum),
          cons(tree2, enum2)
        ];
      return {
              TAG: /* Skip */0,
              _0: next_state
            };
    }
    var match = state[1];
    if (match) {
      return {
              TAG: /* Yield */1,
              _0: {
                TAG: /* Second */1,
                _0: match._0
              },
              _1: [
                /* End */0,
                cons(match._1, match._2)
              ]
            };
    } else {
      return /* Done */0;
    }
  };
  return Sequence$negBase.unfold_step([
              cons(t1, /* End */0),
              cons(t2, /* End */0)
            ], step);
}

function to_sequence(comparator, orderOpt, greater_or_equal_to, less_or_equal_to, t) {
  var order = orderOpt !== undefined ? orderOpt : "Increasing";
  var inclusive_bound = function (side, t, bound) {
    var compare_elt = comparator.compare;
    var match = split(t, bound, compare_elt);
    var maybe = match[1];
    var t$1 = Curry._1(side, [
          match[0],
          match[2]
        ]);
    if (maybe !== undefined) {
      return add(t$1, Caml_option.valFromOption(maybe), compare_elt);
    } else {
      return t$1;
    }
  };
  if (order === "Increasing") {
    var t$1 = Option$negBase.fold(less_or_equal_to, t, (function (param, param$1) {
            return inclusive_bound(Import$negBase.fst, param, param$1);
          }));
    var next = function ($$enum) {
      if ($$enum) {
        return {
                TAG: /* Yield */1,
                _0: $$enum._0,
                _1: cons($$enum._1, $$enum._2)
              };
      } else {
        return /* Done */0;
      }
    };
    var init = greater_or_equal_to !== undefined ? starting_at_increasing(t$1, Caml_option.valFromOption(greater_or_equal_to), comparator.compare) : cons(t$1, /* End */0);
    return Sequence$negBase.unfold_step(init, next);
  }
  var t$2 = Option$negBase.fold(greater_or_equal_to, t, (function (param, param$1) {
          return inclusive_bound(Import$negBase.snd, param, param$1);
        }));
  var next$1 = function ($$enum) {
    if ($$enum) {
      return {
              TAG: /* Yield */1,
              _0: $$enum._0,
              _1: cons_right($$enum._1, $$enum._2)
            };
    } else {
      return /* Done */0;
    }
  };
  var init$1 = less_or_equal_to !== undefined ? starting_at_decreasing(t$2, Caml_option.valFromOption(less_or_equal_to), comparator.compare) : cons_right(t$2, /* End */0);
  return Sequence$negBase.unfold_step(init$1, next$1);
}

function find_first_satisfying(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      var v = t._0;
      if (Curry._1(f, v)) {
        return Caml_option.some(v);
      } else {
        return ;
      }
    }
    var v$1 = t._1;
    if (Curry._1(f, v$1)) {
      var x = find_first_satisfying(t._0, f);
      if (x !== undefined) {
        return x;
      } else {
        return Caml_option.some(v$1);
      }
    }
    _t = t._2;
    continue ;
  };
}

function find_last_satisfying(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      var v = t._0;
      if (Curry._1(f, v)) {
        return Caml_option.some(v);
      } else {
        return ;
      }
    }
    var v$1 = t._1;
    if (Curry._1(f, v$1)) {
      var x = find_last_satisfying(t._2, f);
      if (x !== undefined) {
        return x;
      } else {
        return Caml_option.some(v$1);
      }
    }
    _t = t._0;
    continue ;
  };
}

function binary_search(t, compare, how, v) {
  if (how === "Last_equal_to") {
    var elt = find_last_satisfying(t, (function (x) {
            return Import$negBase.$less$eq(Curry._2(compare, x, v), 0);
          }));
    if (elt !== undefined && Curry._2(compare, Caml_option.valFromOption(elt), v) === 0) {
      return elt;
    } else {
      return ;
    }
  }
  if (how === "First_strictly_greater_than") {
    return find_first_satisfying(t, (function (x) {
                  return Import$negBase.$great(Curry._2(compare, x, v), 0);
                }));
  }
  if (how === "Last_less_than_or_equal_to") {
    return find_last_satisfying(t, (function (x) {
                  return Import$negBase.$less$eq(Curry._2(compare, x, v), 0);
                }));
  }
  if (how === "Last_strictly_less_than") {
    return find_last_satisfying(t, (function (x) {
                  return Import$negBase.$less(Curry._2(compare, x, v), 0);
                }));
  }
  if (how === "First_greater_than_or_equal_to") {
    return find_first_satisfying(t, (function (x) {
                  return Import$negBase.$great$eq(Curry._2(compare, x, v), 0);
                }));
  }
  var elt$1 = find_first_satisfying(t, (function (x) {
          return Import$negBase.$great$eq(Curry._2(compare, x, v), 0);
        }));
  if (elt$1 !== undefined && Curry._2(compare, Caml_option.valFromOption(elt$1), v) === 0) {
    return elt$1;
  }
  
}

function binary_search_segmented(t, segment_of, how) {
  var is_left = function (x) {
    var match = Curry._1(segment_of, x);
    return match === "Left";
  };
  var is_right = function (x) {
    return !is_left(x);
  };
  if (how === "Last_on_left") {
    return find_last_satisfying(t, is_left);
  } else {
    return find_first_satisfying(t, is_right);
  }
}

function merge_to_sequence(comparator, orderOpt, greater_or_equal_to, less_or_equal_to, t, t$p) {
  var order = orderOpt !== undefined ? orderOpt : "Increasing";
  var tmp;
  if (order === "Increasing") {
    tmp = comparator.compare;
  } else {
    var partial_arg = comparator.compare;
    tmp = (function (param, param$1) {
        return Fn$negBase.flip(partial_arg, param, param$1);
      });
  }
  return Sequence$negBase.merge_with_duplicates(to_sequence(comparator, order, greater_or_equal_to, less_or_equal_to, t), to_sequence(comparator, order, greater_or_equal_to, less_or_equal_to, t$p), tmp);
}

function compare(compare_elt, s1, s2) {
  var e1 = cons(s1, /* End */0);
  var e2 = cons(s2, /* End */0);
  var _e1 = e1;
  var _e2 = e2;
  while(true) {
    var e2$1 = _e2;
    var e1$1 = _e1;
    if (!e1$1) {
      if (e2$1) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!e2$1) {
      return 1;
    }
    var e2$2 = e2$1._2;
    var r2 = e2$1._1;
    var e1$2 = e1$1._2;
    var r1 = e1$1._1;
    var c = Curry._2(compare_elt, e1$1._0, e2$1._0);
    if (Import$negBase.$less$great(c, 0)) {
      return c;
    }
    if (Import$negBase.phys_equal(r1, r2)) {
      _e2 = e2$2;
      _e1 = e1$2;
      continue ;
    }
    _e2 = cons(r2, e2$2);
    _e1 = cons(r1, e1$2);
    continue ;
  };
}

function iter2(s1, s2, compare_elt) {
  var partial_arg = cons(s2, /* End */0);
  var partial_arg$1 = cons(s1, /* End */0);
  return function (param) {
    var _t1 = partial_arg$1;
    var _t2 = partial_arg;
    while(true) {
      var t2 = _t2;
      var t1 = _t1;
      if (!t1) {
        if (t2) {
          return iter((function (a) {
                        return Curry._1(param, {
                                    NAME: "Right",
                                    VAL: a
                                  });
                      }), t2);
        } else {
          return ;
        }
      }
      if (!t2) {
        return iter((function (a) {
                      return Curry._1(param, {
                                  NAME: "Left",
                                  VAL: a
                                });
                    }), t1);
      }
      var enum2 = t2._2;
      var tree2 = t2._1;
      var a2 = t2._0;
      var enum1 = t1._2;
      var tree1 = t1._1;
      var a1 = t1._0;
      var compare_result = Curry._2(compare_elt, a1, a2);
      if (compare_result === 0) {
        Curry._1(param, {
              NAME: "Both",
              VAL: [
                a1,
                a2
              ]
            });
        _t2 = cons(tree2, enum2);
        _t1 = cons(tree1, enum1);
        continue ;
      }
      if (Import$negBase.$less(compare_result, 0)) {
        Curry._1(param, {
              NAME: "Left",
              VAL: a1
            });
        _t1 = cons(tree1, enum1);
        continue ;
      }
      Curry._1(param, {
            NAME: "Right",
            VAL: a2
          });
      _t2 = cons(tree2, enum2);
      continue ;
    };
  };
}

function equal(s1, s2, compare_elt) {
  return compare(compare_elt, s1, s2) === 0;
}

function is_subset(s1, s2, compare_elt) {
  var is_subset$1 = function (_s1, _s2) {
    while(true) {
      var s2 = _s2;
      var s1 = _s1;
      if (typeof s1 === "number") {
        return true;
      }
      if (s1.TAG !== /* Leaf */0) {
        var r1 = s1._2;
        var v1 = s1._1;
        var l1 = s1._0;
        if (typeof s2 !== "number") {
          if (s2.TAG === /* Leaf */0) {
            if (typeof l1 === "number" && typeof r1 === "number") {
              return Curry._2(compare_elt, v1, s2._0) === 0;
            } else {
              return false;
            }
          }
          var r2 = s2._2;
          var l2 = s2._0;
          var c = Curry._2(compare_elt, v1, s2._1);
          if (c === 0) {
            if (Import$negBase.phys_equal(s1, s2)) {
              return true;
            }
            if (!is_subset$1(l1, l2)) {
              return false;
            }
            _s2 = r2;
            _s1 = r1;
            continue ;
          }
          if (Import$negBase.$less(c, 0)) {
            if (!is_subset$1({
                    TAG: /* Node */1,
                    _0: l1,
                    _1: v1,
                    _2: /* Empty */0,
                    _3: 0,
                    _4: 0
                  }, l2)) {
              return false;
            }
            _s1 = r1;
            continue ;
          }
          if (!is_subset$1({
                  TAG: /* Node */1,
                  _0: /* Empty */0,
                  _1: v1,
                  _2: r1,
                  _3: 0,
                  _4: 0
                }, r2)) {
            return false;
          }
          _s1 = l1;
          continue ;
        }
        
      }
      if (typeof s2 === "number") {
        return false;
      } else {
        return mem(s2, s1._0, compare_elt);
      }
    };
  };
  return is_subset$1(s1, s2);
}

function are_disjoint(_s1, _s2, compare_elt) {
  while(true) {
    var s2 = _s2;
    var s1 = _s1;
    if (typeof s1 === "number") {
      return true;
    }
    if (typeof s2 === "number") {
      return true;
    }
    if (typeof s1 !== "number") {
      if (s1.TAG === /* Leaf */0) {
        return !mem(s2, s1._0, compare_elt);
      }
      if (typeof s2 !== "number") {
        if (s2.TAG === /* Leaf */0) {
          return !mem(s1, s2._0, compare_elt);
        }
        if (Import$negBase.phys_equal(s1, s2)) {
          return false;
        }
        var match = split(s2, s1._1, compare_elt);
        if (match[1] !== undefined) {
          return false;
        }
        if (!are_disjoint(s1._0, match[0], compare_elt)) {
          return false;
        }
        _s2 = match[2];
        _s1 = s1._2;
        continue ;
      }
      
    }
    
  };
}

function iter$1(t, f) {
  var iter$2 = function (_v) {
    while(true) {
      var v = _v;
      if (typeof v === "number") {
        return ;
      }
      if (v.TAG === /* Leaf */0) {
        return Curry._1(f, v._0);
      }
      iter$2(v._0);
      Curry._1(f, v._1);
      _v = v._2;
      continue ;
    };
  };
  return iter$2(t);
}

function fold(_s, _accu, f) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (typeof s === "number") {
      return accu;
    }
    if (s.TAG === /* Leaf */0) {
      return Curry._2(f, accu, s._0);
    }
    _accu = Curry._2(f, fold(s._0, accu, f), s._1);
    _s = s._2;
    continue ;
  };
}

function sum(m, t, f) {
  return Container$negBase.sum(fold, m, t, f);
}

function fold_right(_s, _accu, f) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (typeof s === "number") {
      return accu;
    }
    if (s.TAG === /* Leaf */0) {
      return Curry._2(f, s._0, accu);
    }
    _accu = Curry._2(f, s._1, fold_right(s._2, accu, f));
    _s = s._0;
    continue ;
  };
}

function for_all(_t, p) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return true;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._1(p, t._0);
    }
    if (!Curry._1(p, t._1)) {
      return false;
    }
    if (!for_all(t._0, p)) {
      return false;
    }
    _t = t._2;
    continue ;
  };
}

function exists(_t, p) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return false;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._1(p, t._0);
    }
    if (Curry._1(p, t._1)) {
      return true;
    }
    if (exists(t._0, p)) {
      return true;
    }
    _t = t._2;
    continue ;
  };
}

function filter(s, p, compare_elt) {
  var filt = function (_accu, _v) {
    while(true) {
      var v = _v;
      var accu = _accu;
      if (typeof v === "number") {
        return accu;
      }
      if (v.TAG === /* Leaf */0) {
        var v$1 = v._0;
        if (Curry._1(p, v$1)) {
          return add(accu, v$1, compare_elt);
        } else {
          return accu;
        }
      }
      var v$2 = v._1;
      _v = v._2;
      _accu = filt(Curry._1(p, v$2) ? add(accu, v$2, compare_elt) : accu, v._0);
      continue ;
    };
  };
  return filt(/* Empty */0, s);
}

function filter_map(s, p, compare_elt) {
  var filt = function (_accu, _v) {
    while(true) {
      var v = _v;
      var accu = _accu;
      if (typeof v === "number") {
        return accu;
      }
      if (v.TAG === /* Leaf */0) {
        var v$1 = Curry._1(p, v._0);
        if (v$1 !== undefined) {
          return add(accu, Caml_option.valFromOption(v$1), compare_elt);
        } else {
          return accu;
        }
      }
      var v$2 = Curry._1(p, v._1);
      _v = v._2;
      _accu = filt(v$2 !== undefined ? add(accu, Caml_option.valFromOption(v$2), compare_elt) : accu, v._0);
      continue ;
    };
  };
  return filt(/* Empty */0, s);
}

function partition_tf(s, p, compare_elt) {
  var part = function (_accu, _v) {
    while(true) {
      var v = _v;
      var accu = _accu;
      var f = accu[1];
      var t = accu[0];
      if (typeof v === "number") {
        return accu;
      }
      if (v.TAG === /* Leaf */0) {
        var v$1 = v._0;
        if (Curry._1(p, v$1)) {
          return [
                  add(t, v$1, compare_elt),
                  f
                ];
        } else {
          return [
                  t,
                  add(f, v$1, compare_elt)
                ];
        }
      }
      var v$2 = v._1;
      _v = v._2;
      _accu = part(Curry._1(p, v$2) ? [
              add(t, v$2, compare_elt),
              f
            ] : [
              t,
              add(f, v$2, compare_elt)
            ], v._0);
      continue ;
    };
  };
  return part([
              /* Empty */0,
              /* Empty */0
            ], s);
}

function elements_aux(_accu, _v) {
  while(true) {
    var v = _v;
    var accu = _accu;
    if (typeof v === "number") {
      return accu;
    }
    if (v.TAG === /* Leaf */0) {
      return {
              hd: v._0,
              tl: accu
            };
    }
    _v = v._0;
    _accu = {
      hd: v._1,
      tl: elements_aux(accu, v._2)
    };
    continue ;
  };
}

function choose(t) {
  if (typeof t === "number") {
    return ;
  } else if (t.TAG === /* Leaf */0) {
    return Caml_option.some(t._0);
  } else {
    return Caml_option.some(t._1);
  }
}

var not_found_1 = {
  TAG: /* Atom */0,
  _0: "Set.choose_exn: empty set"
};

var not_found = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1
};

function choose_exn(t) {
  var v = choose(t);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw not_found;
}

function of_list(lst, compare_elt) {
  return List$negBase.fold(lst, /* Empty */0, (function (t, x) {
                return add(t, x, compare_elt);
              }));
}

function of_sequence(sequence, compare_elt) {
  return Sequence$negBase.fold(sequence, /* Empty */0, (function (t, x) {
                return add(t, x, compare_elt);
              }));
}

function of_array(a, compare_elt) {
  return Array0$negBase.fold(a, /* Empty */0, (function (t, x) {
                return add(t, x, compare_elt);
              }));
}

function to_array(v) {
  if (typeof v === "number") {
    return [];
  }
  if (v.TAG === /* Leaf */0) {
    return [v._0];
  }
  var res = Array0$negBase.create(v._4, v._1);
  var pos_ref = {
    contents: 0
  };
  var loop = function (_v) {
    while(true) {
      var v = _v;
      if (typeof v === "number") {
        return ;
      }
      if (v.TAG === /* Leaf */0) {
        Caml_array.set(res, pos_ref[0], v._0);
        return Import$negBase.incr(pos_ref);
      }
      loop(v._0);
      Caml_array.set(res, pos_ref[0], v._1);
      Import$negBase.incr(pos_ref);
      _v = v._2;
      continue ;
    };
  };
  loop(v._0);
  Import$negBase.incr(pos_ref);
  loop(v._2);
  return res;
}

function map(t, f, compare_elt) {
  return fold(t, /* Empty */0, (function (t, x) {
                return add(t, Curry._1(f, x), compare_elt);
              }));
}

function group_by(set, equiv, compare_elt) {
  var _set = set;
  var _equiv_classes = /* [] */0;
  while(true) {
    var equiv_classes = _equiv_classes;
    var set$1 = _set;
    if (is_empty(set$1)) {
      return equiv_classes;
    }
    var x = choose_exn(set$1);
    var match = partition_tf(set$1, (function(x){
        return function (elt) {
          if (Import$negBase.phys_equal(x, elt)) {
            return true;
          } else {
            return Curry._2(equiv, x, elt);
          }
        }
        }(x)), compare_elt);
    _equiv_classes = {
      hd: match[0],
      tl: equiv_classes
    };
    _set = match[1];
    continue ;
  };
}

function find(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      var v = t._0;
      if (Curry._1(f, v)) {
        return Caml_option.some(v);
      } else {
        return ;
      }
    }
    var v$1 = t._1;
    if (Curry._1(f, v$1)) {
      return Caml_option.some(v$1);
    }
    var r = find(t._0, f);
    if (r !== undefined) {
      return r;
    }
    _t = t._2;
    continue ;
  };
}

function find_map(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._1(f, t._0);
    }
    var r = Curry._1(f, t._1);
    if (r !== undefined) {
      return r;
    }
    var r$1 = find_map(t._0, f);
    if (r$1 !== undefined) {
      return r$1;
    }
    _t = t._2;
    continue ;
  };
}

function find_exn(t, f) {
  var e = find(t, f);
  if (e !== undefined) {
    return Caml_option.valFromOption(e);
  } else {
    return Import$negBase.failwith("Set.find_exn failed to find a matching element");
  }
}

function nth(_t, _i) {
  while(true) {
    var i = _i;
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      if (i === 0) {
        return Caml_option.some(t._0);
      } else {
        return ;
      }
    }
    var l = t._0;
    if (Import$negBase.$great$eq(i, t._4)) {
      return ;
    }
    var l_size = length(l);
    var c = Caml.caml_int_compare(i, l_size);
    if (Import$negBase.$less(c, 0)) {
      _t = l;
      continue ;
    }
    if (c === 0) {
      return Caml_option.some(t._1);
    }
    _i = Import$negBase.$neg(Import$negBase.$neg(i, l_size), 1);
    _t = t._2;
    continue ;
  };
}

function stable_dedup_list(xs, compare_elt) {
  var _xs = xs;
  var _leftovers = /* [] */0;
  var _already_seen = /* Empty */0;
  while(true) {
    var already_seen = _already_seen;
    var leftovers = _leftovers;
    var xs$1 = _xs;
    if (!xs$1) {
      return List$negBase.rev(leftovers);
    }
    var tl = xs$1.tl;
    var hd = xs$1.hd;
    if (mem(already_seen, hd, compare_elt)) {
      _xs = tl;
      continue ;
    }
    _already_seen = add(already_seen, hd, compare_elt);
    _leftovers = {
      hd: hd,
      tl: leftovers
    };
    _xs = tl;
    continue ;
  };
}

function t_of_sexp_direct(a_of_sexp, sexp, compare_elt) {
  if (sexp.TAG === /* Atom */0) {
    return Import$negBase.of_sexp_error("Set.t_of_sexp: list needed", sexp);
  }
  var lst = sexp._0;
  var elt_lst = List$negBase.map(lst, a_of_sexp);
  var set = of_list(elt_lst, compare_elt);
  if (length(set) === List$negBase.length(lst)) {
    return set;
  }
  var set$1 = {
    contents: /* Empty */0
  };
  List$negBase.iter2_exn(lst, elt_lst, (function (el_sexp, el) {
          if (mem(set$1[0], el, compare_elt)) {
            return Import$negBase.of_sexp_error("Set.t_of_sexp: duplicate element in set", el_sexp);
          } else {
            set$1[0] = add(set$1[0], el, compare_elt);
            return ;
          }
        }));
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "set.ml",
          1048,
          8
        ],
        Error: new Error()
      };
}

function sexp_of_t(sexp_of_a, t) {
  return {
          TAG: /* List */1,
          _0: fold_right(t, /* [] */0, (function (el, acc) {
                  return {
                          hd: Curry._1(sexp_of_a, el),
                          tl: acc
                        };
                }))
        };
}

function is_subset$1(subset, superset, sexp_of_elt, compare_elt) {
  var invalid_elements = diff(subset.tree, superset.tree, compare_elt);
  if (is_empty(invalid_elements)) {
    return {
            TAG: /* Ok */0,
            _0: undefined
          };
  }
  var invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements);
  return Or_error$negBase.error_s(Sexp$negBase.message(Import$negBase.$caret(subset.name, Import$negBase.$caret(" is not a subset of ", superset.name)), {
                  hd: [
                    "invalid_elements",
                    invalid_elements_sexp
                  ],
                  tl: /* [] */0
                }));
}

function like(param, tree) {
  return {
          comparator: param.comparator,
          tree: tree
        };
}

function comparator(t) {
  return t.comparator;
}

function invariants$1(t) {
  return invariants(t.tree, t.comparator.compare);
}

function length$1(t) {
  return length(t.tree);
}

function is_empty$1(t) {
  return is_empty(t.tree);
}

function elements(t) {
  return elements_aux(/* [] */0, t.tree);
}

function min_elt$1(t) {
  return min_elt(t.tree);
}

function min_elt_exn$1(t) {
  return min_elt_exn(t.tree);
}

function max_elt$1(t) {
  return max_elt(t.tree);
}

function max_elt_exn$1(t) {
  return max_elt_exn(t.tree);
}

function choose$1(t) {
  return choose(t.tree);
}

function choose_exn$1(t) {
  return choose_exn(t.tree);
}

function to_list(t) {
  return elements_aux(/* [] */0, t.tree);
}

function to_array$1(t) {
  return to_array(t.tree);
}

function fold$1(t, init, f) {
  return fold(t.tree, init, f);
}

function fold_until$1(t, init, f) {
  var partial_arg = t.tree;
  return function (param) {
    return fold_until(partial_arg, init, f, param);
  };
}

function fold_right$1(t, init, f) {
  return fold_right(t.tree, init, f);
}

function fold_result(t, init, f) {
  return Container$negBase.fold_result(fold$1, init, f, t);
}

function iter$2(t, f) {
  return iter$1(t.tree, f);
}

function iter2$1(a, b, f) {
  return iter2(a.tree, b.tree, a.comparator.compare)(f);
}

function exists$1(t, f) {
  return exists(t.tree, f);
}

function for_all$1(t, f) {
  return for_all(t.tree, f);
}

function count(t, f) {
  return Container$negBase.count(fold, t.tree, f);
}

function sum$1(m, t, f) {
  return sum(m, t.tree, f);
}

function find$1(t, f) {
  return find(t.tree, f);
}

function find_exn$1(t, f) {
  return find_exn(t.tree, f);
}

function find_map$1(t, f) {
  return find_map(t.tree, f);
}

function mem$1(t, a) {
  return mem(t.tree, a, t.comparator.compare);
}

function filter$1(t, f) {
  return like(t, filter(t.tree, f, t.comparator.compare));
}

function add$1(t, a) {
  return like(t, add(t.tree, a, t.comparator.compare));
}

function remove$1(t, a) {
  return like(t, remove(t.tree, a, t.comparator.compare));
}

function union$1(t1, t2) {
  return like(t1, union(t1.tree, t2.tree, t1.comparator.compare));
}

function inter$1(t1, t2) {
  return like(t1, inter(t1.tree, t2.tree, t1.comparator.compare));
}

function diff$1(t1, t2) {
  return like(t1, diff(t1.tree, t2.tree, t1.comparator.compare));
}

function symmetric_diff$1(t1, t2) {
  return symmetric_diff(t1.tree, t2.tree, t1.comparator.compare);
}

function compare_direct(t1, t2) {
  return compare(t1.comparator.compare, t1.tree, t2.tree);
}

function equal$1(t1, t2) {
  return equal(t1.tree, t2.tree, t1.comparator.compare);
}

function is_subset$2(t, of_) {
  return is_subset(t.tree, of_.tree, t.comparator.compare);
}

function are_disjoint$1(t1, t2) {
  return are_disjoint(t1.tree, t2.tree, t1.comparator.compare);
}

function to_named_tree(param) {
  return {
          tree: param.set.tree,
          name: param.name
        };
}

function is_subset$3(subset, superset) {
  return is_subset$1(to_named_tree(subset), to_named_tree(superset), subset.set.comparator.sexp_of_t, subset.set.comparator.compare);
}

function equal$2(t1, t2) {
  return Or_error$negBase.combine_errors_unit({
              hd: is_subset$3(t1, t2),
              tl: {
                hd: is_subset$3(t2, t1),
                tl: /* [] */0
              }
            });
}

function partition_tf$1(t, f) {
  var match = partition_tf(t.tree, f, t.comparator.compare);
  return [
          like(t, match[0]),
          like(t, match[1])
        ];
}

function split$1(t, a) {
  var match = split(t.tree, a, t.comparator.compare);
  return [
          like(t, match[0]),
          match[1],
          like(t, match[2])
        ];
}

function group_by$1(t, equiv) {
  return List$negBase.map(group_by(t.tree, equiv, t.comparator.compare), (function (param) {
                return like(t, param);
              }));
}

function nth$1(t, i) {
  return nth(t.tree, i);
}

function remove_index$1(t, i) {
  return like(t, remove_index(t.tree, i, t.comparator.compare));
}

function sexp_of_t$1(sexp_of_a, param, t) {
  return sexp_of_t(sexp_of_a, t.tree);
}

function to_sequence$1(order, greater_or_equal_to, less_or_equal_to, t) {
  return to_sequence(t.comparator, order, greater_or_equal_to, less_or_equal_to, t.tree);
}

function binary_search$1(t, compare, how, v) {
  return binary_search(t.tree, compare, how, v);
}

function binary_search_segmented$1(t, segment_of, how) {
  return binary_search_segmented(t.tree, segment_of, how);
}

function merge_to_sequence$1(order, greater_or_equal_to, less_or_equal_to, t, t$p) {
  return merge_to_sequence(t.comparator, order, greater_or_equal_to, less_or_equal_to, t.tree, t$p.tree);
}

function hash_fold_direct(hash_fold_key, state, t) {
  var t$1 = t.tree;
  return fold(t$1, Import$negBase.hash_fold_int(state, length(t$1)), hash_fold_key);
}

function compare$1(param, param$1, t1, t2) {
  return compare_direct(t1, t2);
}

function t_of_sexp_direct$1(comparator, a_of_sexp, sexp) {
  return t_of_sexp_direct(a_of_sexp, sexp, comparator.compare);
}

function empty(param) {
  return /* Empty */0;
}

function singleton(param, e) {
  return {
          TAG: /* Leaf */0,
          _0: e
        };
}

var length$2 = length;

function invariants$2(comparator, t) {
  return invariants(t, comparator.compare);
}

var is_empty$2 = is_empty;

function elements$1(t) {
  return elements_aux(/* [] */0, t);
}

var min_elt$2 = min_elt;

var min_elt_exn$2 = min_elt_exn;

var max_elt$2 = max_elt;

var max_elt_exn$2 = max_elt_exn;

var choose$2 = choose;

var choose_exn$2 = choose_exn;

function to_list$1(t) {
  return elements_aux(/* [] */0, t);
}

var to_array$2 = to_array;

var iter$3 = iter$1;

var exists$2 = exists;

var for_all$2 = for_all;

function count$1(t, f) {
  return Container$negBase.count(fold, t, f);
}

var sum$2 = sum;

var find$2 = find;

var find_exn$2 = find_exn;

var find_map$2 = find_map;

var fold$2 = fold;

function fold_until$2(t, init, f) {
  return function (param) {
    return fold_until(t, init, f, param);
  };
}

var fold_right$2 = fold_right;

function map$1(comparator, t, f) {
  return map(t, f, comparator.compare);
}

function filter$2(comparator, t, f) {
  return filter(t, f, comparator.compare);
}

function filter_map$1(comparator, t, f) {
  return filter_map(t, f, comparator.compare);
}

function partition_tf$2(comparator, t, f) {
  return partition_tf(t, f, comparator.compare);
}

function iter2$2(comparator, a, b, f) {
  return iter2(a, b, comparator.compare)(f);
}

function mem$2(comparator, t, a) {
  return mem(t, a, comparator.compare);
}

function add$2(comparator, t, a) {
  return add(t, a, comparator.compare);
}

function remove$2(comparator, t, a) {
  return remove(t, a, comparator.compare);
}

function union$2(comparator, t1, t2) {
  return union(t1, t2, comparator.compare);
}

function inter$2(comparator, t1, t2) {
  return inter(t1, t2, comparator.compare);
}

function diff$2(comparator, t1, t2) {
  return diff(t1, t2, comparator.compare);
}

function symmetric_diff$2(comparator, t1, t2) {
  return symmetric_diff(t1, t2, comparator.compare);
}

function compare_direct$1(comparator, t1, t2) {
  return compare(comparator.compare, t1, t2);
}

function equal$3(comparator, t1, t2) {
  return equal(t1, t2, comparator.compare);
}

function is_subset$4(comparator, t, of_) {
  return is_subset(t, of_, comparator.compare);
}

function are_disjoint$2(comparator, t1, t2) {
  return are_disjoint(t1, t2, comparator.compare);
}

function of_list$1(comparator, l) {
  return of_list(l, comparator.compare);
}

function of_sequence$1(comparator, s) {
  return of_sequence(s, comparator.compare);
}

function of_array$1(comparator, a) {
  return of_array(a, comparator.compare);
}

function of_sorted_array_unchecked$1(comparator, a) {
  return of_sorted_array_unchecked(a, comparator.compare);
}

function of_increasing_iterator_unchecked$1(param, len, f) {
  return of_increasing_iterator_unchecked(len, f);
}

function of_sorted_array$1(comparator, a) {
  return of_sorted_array(a, comparator.compare);
}

function union_list$1(comparator, l) {
  return union_list(comparator, (function (prim) {
                return prim;
              }), l);
}

function stable_dedup_list$1(comparator, xs) {
  return stable_dedup_list(xs, comparator.compare);
}

function group_by$2(comparator, t, equiv) {
  return group_by(t, equiv, comparator.compare);
}

function split$2(comparator, t, a) {
  return split(t, a, comparator.compare);
}

var nth$2 = nth;

function remove_index$2(comparator, t, i) {
  return remove_index(t, i, comparator.compare);
}

function sexp_of_t$2(sexp_of_a, param, t) {
  return sexp_of_t(sexp_of_a, t);
}

function to_tree(t) {
  return t;
}

function of_tree(param, t) {
  return t;
}

var to_sequence$2 = to_sequence;

function binary_search$2(param, t, compare, how, v) {
  return binary_search(t, compare, how, v);
}

function binary_search_segmented$2(param, t, segment_of, how) {
  return binary_search_segmented(t, segment_of, how);
}

var merge_to_sequence$2 = merge_to_sequence;

function fold_result$1(t, init, f) {
  return Container$negBase.fold_result(fold$2, init, f, t);
}

function is_subset$5(comparator, t1, t2) {
  return is_subset$1(t1, t2, comparator.sexp_of_t, comparator.compare);
}

function equal$4(comparator, t1, t2) {
  var sexp_of_elt = comparator.sexp_of_t;
  var compare_elt = comparator.compare;
  return Or_error$negBase.combine_errors_unit({
              hd: is_subset$1(t1, t2, sexp_of_elt, compare_elt),
              tl: {
                hd: is_subset$1(t2, t1, sexp_of_elt, compare_elt),
                tl: /* [] */0
              }
            });
}

var Named = {
  is_subset: is_subset$5,
  equal: equal$4
};

function to_tree$1(t) {
  return t.tree;
}

function of_tree$1(comparator, tree) {
  return {
          comparator: comparator,
          tree: tree
        };
}

function t_of_sexp_direct$2(comparator, a_of_sexp, sexp) {
  return {
          comparator: comparator,
          tree: t_of_sexp_direct(a_of_sexp, sexp, comparator.compare)
        };
}

function empty$1(comparator) {
  return {
          comparator: comparator,
          tree: /* Empty */0
        };
}

function Empty_without_value_restriction(Elt) {
  var empty_comparator = Elt.comparator;
  var empty = {
    comparator: empty_comparator,
    tree: /* Empty */0
  };
  return {
          empty: empty
        };
}

function singleton$1(comparator, e) {
  return {
          comparator: comparator,
          tree: {
            TAG: /* Leaf */0,
            _0: e
          }
        };
}

function union_list$2(comparator, l) {
  return {
          comparator: comparator,
          tree: union_list(comparator, to_tree$1, l)
        };
}

function of_sorted_array_unchecked$2(comparator, array) {
  var tree = of_sorted_array_unchecked(array, comparator.compare);
  return {
          comparator: comparator,
          tree: tree
        };
}

function of_increasing_iterator_unchecked$2(comparator, len, f) {
  return {
          comparator: comparator,
          tree: of_increasing_iterator_unchecked(len, f)
        };
}

function of_sorted_array$2(comparator, array) {
  return Curry._2(Or_error$negBase.Monad_infix.$great$great$pipe, of_sorted_array(array, comparator.compare), (function (tree) {
                return {
                        comparator: comparator,
                        tree: tree
                      };
              }));
}

function of_list$2(comparator, l) {
  return {
          comparator: comparator,
          tree: of_list(l, comparator.compare)
        };
}

function of_sequence$2(comparator, s) {
  return {
          comparator: comparator,
          tree: of_sequence(s, comparator.compare)
        };
}

function of_array$2(comparator, a) {
  return {
          comparator: comparator,
          tree: of_array(a, comparator.compare)
        };
}

function stable_dedup_list$2(comparator, xs) {
  return stable_dedup_list(xs, comparator.compare);
}

function map$2(comparator, t, f) {
  return {
          comparator: comparator,
          tree: map(t.tree, f, comparator.compare)
        };
}

function filter_map$2(comparator, t, f) {
  return {
          comparator: comparator,
          tree: filter_map(t.tree, f, comparator.compare)
        };
}

function comparator_s(t) {
  var comparator = t.comparator;
  return {
          comparator: comparator
        };
}

function empty$2(m) {
  return {
          comparator: m.comparator,
          tree: /* Empty */0
        };
}

function singleton$2(m, a) {
  return {
          comparator: m.comparator,
          tree: {
            TAG: /* Leaf */0,
            _0: a
          }
        };
}

function union_list$3(m, a) {
  return union_list$2(m.comparator, a);
}

function of_sorted_array_unchecked$3(m, a) {
  return of_sorted_array_unchecked$2(m.comparator, a);
}

function of_increasing_iterator_unchecked$3(m, len, f) {
  return of_increasing_iterator_unchecked$2(m.comparator, len, f);
}

function of_sorted_array$3(m, a) {
  return of_sorted_array$2(m.comparator, a);
}

function of_list$3(m, a) {
  return of_list$2(m.comparator, a);
}

function of_sequence$3(m, a) {
  return of_sequence$2(m.comparator, a);
}

function of_array$3(m, a) {
  return of_array$2(m.comparator, a);
}

function stable_dedup_list$3(m, a) {
  return stable_dedup_list(a, m.comparator.compare);
}

function map$3(m, a, f) {
  return map$2(m.comparator, a, f);
}

function filter_map$3(m, a, f) {
  return filter_map$2(m.comparator, a, f);
}

function M(Elt) {
  return {};
}

function sexp_of_m__t(Elt, t) {
  return sexp_of_t(Elt.sexp_of_t, t.tree);
}

function m__t_of_sexp(Elt, sexp) {
  return t_of_sexp_direct$2(Elt.comparator, Elt.t_of_sexp, sexp);
}

function m__t_sexp_grammar(Elt) {
  return Sexp_grammar$negSexplib0.coerce(Import$negBase.list_sexp_grammar(Elt.t_sexp_grammar));
}

function compare_m__t(Elt, t1, t2) {
  return compare_direct(t1, t2);
}

function equal_m__t(Elt, t1, t2) {
  return equal$1(t1, t2);
}

function hash_fold_m__t(Elt, state) {
  return function (param) {
    return hash_fold_direct(Elt.hash_fold_t, state, param);
  };
}

function hash_m__t(folder, t) {
  return Hash$negBase.get_hash_value(hash_fold_m__t(folder, Hash$negBase.create(undefined, undefined))(t));
}

var comparator$1 = Comparator$negBase.Poly.comparator;

var empty_comparator = Comparator$negBase.Poly.comparator;

var empty$3 = {
  comparator: empty_comparator,
  tree: /* Empty */0
};

function singleton$3(a) {
  return {
          comparator: comparator$1,
          tree: {
            TAG: /* Leaf */0,
            _0: a
          }
        };
}

function union_list$4(a) {
  return union_list$2(comparator$1, a);
}

function of_sorted_array_unchecked$4(a) {
  return of_sorted_array_unchecked$2(comparator$1, a);
}

function of_increasing_iterator_unchecked$4(len, f) {
  return of_increasing_iterator_unchecked$2(comparator$1, len, f);
}

function of_sorted_array$4(a) {
  return of_sorted_array$2(comparator$1, a);
}

function of_list$4(a) {
  return of_list$2(comparator$1, a);
}

function of_sequence$4(a) {
  return of_sequence$2(comparator$1, a);
}

function of_array$4(a) {
  return of_array$2(comparator$1, a);
}

function stable_dedup_list$4(a) {
  return stable_dedup_list(a, comparator$1.compare);
}

function map$4(a, f) {
  return map$2(comparator$1, a, f);
}

function filter_map$4(a, f) {
  return filter_map$2(comparator$1, a, f);
}

function of_tree$2(tree) {
  return {
          comparator: comparator$1,
          tree: tree
        };
}

function to_tree$2(t) {
  return t.tree;
}

var Named$1 = {
  is_subset: is_subset$3,
  equal: equal$2
};

var Merge_to_sequence_element_compare = Sequence$negBase.Merge_with_duplicates_element.compare;

var Merge_to_sequence_element_t_of_sexp = Sequence$negBase.Merge_with_duplicates_element.t_of_sexp;

var Merge_to_sequence_element_sexp_of_t = Sequence$negBase.Merge_with_duplicates_element.sexp_of_t;

var Merge_to_sequence_element = {
  compare: Merge_to_sequence_element_compare,
  t_of_sexp: Merge_to_sequence_element_t_of_sexp,
  sexp_of_t: Merge_to_sequence_element_sexp_of_t
};

var Poly_Named = {
  is_subset: is_subset$3,
  equal: equal$2
};

var Poly = {
  length: length$1,
  is_empty: is_empty$1,
  iter: iter$2,
  fold: fold$1,
  fold_result: fold_result,
  exists: exists$1,
  for_all: for_all$1,
  count: count,
  sum: sum$1,
  find: find$1,
  find_map: find_map$1,
  to_list: to_list,
  to_array: to_array$1,
  invariants: invariants$1,
  mem: mem$1,
  add: add$1,
  remove: remove$1,
  union: union$1,
  inter: inter$1,
  diff: diff$1,
  symmetric_diff: symmetric_diff$1,
  compare_direct: compare_direct,
  equal: equal$1,
  is_subset: is_subset$2,
  are_disjoint: are_disjoint$1,
  Named: Poly_Named,
  fold_until: fold_until$1,
  fold_right: fold_right$1,
  iter2: iter2$1,
  filter: filter$1,
  partition_tf: partition_tf$1,
  elements: elements,
  min_elt: min_elt$1,
  min_elt_exn: min_elt_exn$1,
  max_elt: max_elt$1,
  max_elt_exn: max_elt_exn$1,
  choose: choose$1,
  choose_exn: choose_exn$1,
  split: split$1,
  group_by: group_by$1,
  find_exn: find_exn$1,
  nth: nth$1,
  remove_index: remove_index$1,
  to_tree: to_tree$2,
  to_sequence: to_sequence$1,
  binary_search: binary_search$1,
  binary_search_segmented: binary_search_segmented$1,
  merge_to_sequence: merge_to_sequence$1,
  empty: empty$3,
  singleton: singleton$3,
  union_list: union_list$4,
  of_list: of_list$4,
  of_sequence: of_sequence$4,
  of_array: of_array$4,
  of_sorted_array: of_sorted_array$4,
  of_sorted_array_unchecked: of_sorted_array_unchecked$4,
  of_increasing_iterator_unchecked: of_increasing_iterator_unchecked$4,
  stable_dedup_list: stable_dedup_list$4,
  map: map$4,
  filter_map: filter_map$4,
  of_tree: of_tree$2
};

var Using_comparator_Tree = {
  sexp_of_t: sexp_of_t$2,
  t_of_sexp_direct: t_of_sexp_direct$1,
  Named: Named,
  length: length$2,
  is_empty: is_empty$2,
  iter: iter$3,
  fold: fold$2,
  fold_result: fold_result$1,
  exists: exists$2,
  for_all: for_all$2,
  count: count$1,
  sum: sum$2,
  find: find$2,
  find_map: find_map$2,
  to_list: to_list$1,
  to_array: to_array$2,
  invariants: invariants$2,
  mem: mem$2,
  add: add$2,
  remove: remove$2,
  union: union$2,
  inter: inter$2,
  diff: diff$2,
  symmetric_diff: symmetric_diff$2,
  compare_direct: compare_direct$1,
  equal: equal$3,
  is_subset: is_subset$4,
  are_disjoint: are_disjoint$2,
  fold_until: fold_until$2,
  fold_right: fold_right$2,
  iter2: iter2$2,
  filter: filter$2,
  partition_tf: partition_tf$2,
  elements: elements$1,
  min_elt: min_elt$2,
  min_elt_exn: min_elt_exn$2,
  max_elt: max_elt$2,
  max_elt_exn: max_elt_exn$2,
  choose: choose$2,
  choose_exn: choose_exn$2,
  split: split$2,
  group_by: group_by$2,
  find_exn: find_exn$2,
  nth: nth$2,
  remove_index: remove_index$2,
  to_tree: to_tree,
  to_sequence: to_sequence$2,
  binary_search: binary_search$2,
  binary_search_segmented: binary_search_segmented$2,
  merge_to_sequence: merge_to_sequence$2,
  empty: empty,
  singleton: singleton,
  union_list: union_list$1,
  of_list: of_list$1,
  of_sequence: of_sequence$1,
  of_array: of_array$1,
  of_sorted_array: of_sorted_array$1,
  of_sorted_array_unchecked: of_sorted_array_unchecked$1,
  of_increasing_iterator_unchecked: of_increasing_iterator_unchecked$1,
  stable_dedup_list: stable_dedup_list$1,
  map: map$1,
  filter_map: filter_map$1,
  of_tree: of_tree,
  empty_without_value_restriction: /* Empty */0
};

var Using_comparator_Named = {
  is_subset: is_subset$3,
  equal: equal$2
};

var Using_comparator = {
  sexp_of_t: sexp_of_t$1,
  t_of_sexp_direct: t_of_sexp_direct$2,
  Tree: Using_comparator_Tree,
  length: length$1,
  is_empty: is_empty$1,
  iter: iter$2,
  fold: fold$1,
  fold_result: fold_result,
  exists: exists$1,
  for_all: for_all$1,
  count: count,
  sum: sum$1,
  find: find$1,
  find_map: find_map$1,
  to_list: to_list,
  to_array: to_array$1,
  invariants: invariants$1,
  mem: mem$1,
  add: add$1,
  remove: remove$1,
  union: union$1,
  inter: inter$1,
  diff: diff$1,
  symmetric_diff: symmetric_diff$1,
  compare_direct: compare_direct,
  equal: equal$1,
  is_subset: is_subset$2,
  are_disjoint: are_disjoint$1,
  Named: Using_comparator_Named,
  fold_until: fold_until$1,
  fold_right: fold_right$1,
  iter2: iter2$1,
  filter: filter$1,
  partition_tf: partition_tf$1,
  elements: elements,
  min_elt: min_elt$1,
  min_elt_exn: min_elt_exn$1,
  max_elt: max_elt$1,
  max_elt_exn: max_elt_exn$1,
  choose: choose$1,
  choose_exn: choose_exn$1,
  split: split$1,
  group_by: group_by$1,
  find_exn: find_exn$1,
  nth: nth$1,
  remove_index: remove_index$1,
  to_tree: to_tree$1,
  to_sequence: to_sequence$1,
  binary_search: binary_search$1,
  binary_search_segmented: binary_search_segmented$1,
  merge_to_sequence: merge_to_sequence$1,
  empty: empty$1,
  singleton: singleton$1,
  union_list: union_list$2,
  of_list: of_list$2,
  of_sequence: of_sequence$2,
  of_array: of_array$2,
  of_sorted_array: of_sorted_array$2,
  of_sorted_array_unchecked: of_sorted_array_unchecked$2,
  of_increasing_iterator_unchecked: of_increasing_iterator_unchecked$2,
  stable_dedup_list: stable_dedup_list$2,
  map: map$2,
  filter_map: filter_map$2,
  of_tree: of_tree$1,
  comparator: comparator,
  hash_fold_direct: hash_fold_direct,
  Empty_without_value_restriction: Empty_without_value_restriction
};

exports.compare = compare$1;
exports.invariants = invariants$1;
exports.comparator_s = comparator_s;
exports.comparator = comparator;
exports.empty = empty$2;
exports.singleton = singleton$2;
exports.length = length$1;
exports.is_empty = is_empty$1;
exports.mem = mem$1;
exports.add = add$1;
exports.remove = remove$1;
exports.union = union$1;
exports.union_list = union_list$3;
exports.inter = inter$1;
exports.diff = diff$1;
exports.symmetric_diff = symmetric_diff$1;
exports.compare_direct = compare_direct;
exports.hash_fold_direct = hash_fold_direct;
exports.equal = equal$1;
exports.exists = exists$1;
exports.for_all = for_all$1;
exports.count = count;
exports.sum = sum$1;
exports.find = find$1;
exports.find_map = find_map$1;
exports.find_exn = find_exn$1;
exports.nth = nth$1;
exports.remove_index = remove_index$1;
exports.is_subset = is_subset$2;
exports.are_disjoint = are_disjoint$1;
exports.Named = Named$1;
exports.of_list = of_list$3;
exports.of_sequence = of_sequence$3;
exports.of_array = of_array$3;
exports.to_list = to_list;
exports.to_array = to_array$1;
exports.of_sorted_array = of_sorted_array$3;
exports.of_sorted_array_unchecked = of_sorted_array_unchecked$3;
exports.of_increasing_iterator_unchecked = of_increasing_iterator_unchecked$3;
exports.stable_dedup_list = stable_dedup_list$3;
exports.map = map$3;
exports.filter_map = filter_map$3;
exports.filter = filter$1;
exports.fold = fold$1;
exports.fold_result = fold_result;
exports.fold_until = fold_until$1;
exports.fold_right = fold_right$1;
exports.iter = iter$2;
exports.iter2 = iter2$1;
exports.partition_tf = partition_tf$1;
exports.elements = elements;
exports.min_elt = min_elt$1;
exports.min_elt_exn = min_elt_exn$1;
exports.max_elt = max_elt$1;
exports.max_elt_exn = max_elt_exn$1;
exports.choose = choose$1;
exports.choose_exn = choose_exn$1;
exports.split = split$1;
exports.group_by = group_by$1;
exports.to_sequence = to_sequence$1;
exports.binary_search = binary_search$1;
exports.binary_search_segmented = binary_search_segmented$1;
exports.Merge_to_sequence_element = Merge_to_sequence_element;
exports.merge_to_sequence = merge_to_sequence$1;
exports.M = M;
exports.sexp_of_m__t = sexp_of_m__t;
exports.m__t_of_sexp = m__t_of_sexp;
exports.m__t_sexp_grammar = m__t_sexp_grammar;
exports.compare_m__t = compare_m__t;
exports.equal_m__t = equal_m__t;
exports.hash_fold_m__t = hash_fold_m__t;
exports.hash_m__t = hash_m__t;
exports.Poly = Poly;
exports.Using_comparator = Using_comparator;
/*  Not a pure module */
