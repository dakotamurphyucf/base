// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Exn$negBase = require("./exn.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Array$negBase = require("./array.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Error$negBase = require("./error.bs.js");
var List0$negBase = require("./list0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Result$negBase = require("./result.bs.js");
var Map_intf$negBase = require("./map_intf.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Sequence$negBase = require("./sequence.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Comparator$negBase = require("./comparator.bs.js");
var Maybe_bound$negBase = require("./maybe_bound.bs.js");
var With_return$negBase = require("./with_return.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Sexp_conv$negSexplib0 = require("sexplib0/./sexp_conv.bs.js");
var Uniform_array$negBase = require("./uniform_array.bs.js");

function of_continue_or_stop(prim) {
  return prim;
}

function to_continue_or_stop(prim) {
  return prim;
}

var Finished_or_unfinished_compare = Map_intf$negBase.Finished_or_unfinished.compare;

var Finished_or_unfinished_all = Map_intf$negBase.Finished_or_unfinished.all;

var Finished_or_unfinished_equal = Map_intf$negBase.Finished_or_unfinished.equal;

var Finished_or_unfinished_sexp_of_t = Map_intf$negBase.Finished_or_unfinished.sexp_of_t;

var Finished_or_unfinished = {
  compare: Finished_or_unfinished_compare,
  all: Finished_or_unfinished_all,
  equal: Finished_or_unfinished_equal,
  sexp_of_t: Finished_or_unfinished_sexp_of_t,
  of_continue_or_stop: of_continue_or_stop,
  to_continue_or_stop: to_continue_or_stop
};

var Duplicate = /* @__PURE__ */Caml_exceptions.create("Map-Base.Duplicate");

Sexp_conv$negSexplib0.Exn_converter.add(undefined, undefined, Duplicate, (function (param) {
        if (param.RE_EXN_ID === Duplicate) {
          return {
                  TAG: /* Atom */0,
                  _0: "map.ml.Duplicate"
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "map.ml",
                34,
                11
              ],
              Error: new Error()
            };
      }));

function height(param) {
  if (typeof param === "number") {
    return 0;
  } else if (param.TAG === /* Leaf */0) {
    return 1;
  } else {
    return param._4;
  }
}

function in_range(lower, upper, compare_key, k) {
  if (lower !== undefined ? Import$negBase.$less(Curry._2(compare_key, Caml_option.valFromOption(lower), k), 0) : true) {
    if (upper !== undefined) {
      return Import$negBase.$less(Curry._2(compare_key, k, Caml_option.valFromOption(upper)), 0);
    } else {
      return true;
    }
  } else {
    return false;
  }
}

function loop(_lower, upper, compare_key, _t) {
  while(true) {
    var t = _t;
    var lower = _lower;
    if (typeof t === "number") {
      return true;
    }
    if (t.TAG === /* Leaf */0) {
      return in_range(lower, upper, compare_key, t._0);
    }
    var r = t._3;
    var k = t._1;
    var l = t._0;
    var hl = height(l);
    var hr = height(r);
    if (!Import$negBase.$less$eq(Import$negBase.abs(Import$negBase.$neg(hl, hr)), 2)) {
      return false;
    }
    if (t._4 !== Import$negBase.$plus(Import$negBase.max(hl, hr), 1)) {
      return false;
    }
    if (!in_range(lower, upper, compare_key, k)) {
      return false;
    }
    if (!loop(lower, Caml_option.some(k), compare_key, l)) {
      return false;
    }
    _t = r;
    _lower = Caml_option.some(k);
    continue ;
  };
}

function invariants(t, compare_key) {
  return loop(undefined, undefined, compare_key, t);
}

function create(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  if (hl === 0 && hr === 0) {
    return {
            TAG: /* Leaf */0,
            _0: x,
            _1: d
          };
  } else {
    return {
            TAG: /* Node */1,
            _0: l,
            _1: x,
            _2: d,
            _3: r,
            _4: Import$negBase.$great$eq(hl, hr) ? Import$negBase.$plus(hl, 1) : Import$negBase.$plus(hr, 1)
          };
  }
}

function of_increasing_iterator_unchecked(len, f) {
  var loop = function (n, f, i) {
    switch (n) {
      case 0 :
          return /* Empty */0;
      case 1 :
          var match = Curry._1(f, i);
          return {
                  TAG: /* Leaf */0,
                  _0: match[0],
                  _1: match[1]
                };
      case 2 :
          var match$1 = Curry._1(f, i);
          var match$2 = Curry._1(f, Import$negBase.$plus(i, 1));
          return {
                  TAG: /* Node */1,
                  _0: {
                    TAG: /* Leaf */0,
                    _0: match$1[0],
                    _1: match$1[1]
                  },
                  _1: match$2[0],
                  _2: match$2[1],
                  _3: /* Empty */0,
                  _4: 2
                };
      case 3 :
          var match$3 = Curry._1(f, i);
          var match$4 = Curry._1(f, Import$negBase.$plus(i, 1));
          var match$5 = Curry._1(f, Import$negBase.$plus(i, 2));
          return {
                  TAG: /* Node */1,
                  _0: {
                    TAG: /* Leaf */0,
                    _0: match$3[0],
                    _1: match$3[1]
                  },
                  _1: match$4[0],
                  _2: match$4[1],
                  _3: {
                    TAG: /* Leaf */0,
                    _0: match$5[0],
                    _1: match$5[1]
                  },
                  _4: 2
                };
      default:
        var left_length = Import$negBase.lsr(n, 1);
        var right_length = Import$negBase.$neg(Import$negBase.$neg(n, left_length), 1);
        var left = loop(left_length, f, i);
        var match$6 = Curry._1(f, Import$negBase.$plus(i, left_length));
        var right = loop(right_length, f, Import$negBase.$plus(Import$negBase.$plus(i, left_length), 1));
        return create(left, match$6[0], match$6[1], right);
    }
  };
  return loop(len, f, 0);
}

function of_sorted_array_unchecked(array, compare_key) {
  var array_length = Array$negBase.length(array);
  var tmp = true;
  if (!Import$negBase.$less(array_length, 2)) {
    var match = Caml_array.get(array, 0);
    var match$1 = Caml_array.get(array, 1);
    tmp = Import$negBase.$less(Curry._2(compare_key, match[0], match$1[0]), 0);
  }
  var next = tmp ? (function (i) {
        return Caml_array.get(array, i);
      }) : (function (i) {
        return Caml_array.get(array, Import$negBase.$neg(Import$negBase.$neg(array_length, 1), i));
      });
  return [
          of_increasing_iterator_unchecked(array_length, next),
          array_length
        ];
}

function of_sorted_array(array, compare_key) {
  var len = array.length;
  if (len !== 1 && len) {
    return With_return$negBase.with_return(function (r) {
                var i = Curry._2(compare_key, Import$negBase.fst(Caml_array.get(array, 0)), Import$negBase.fst(Caml_array.get(array, 1)));
                var increasing = i !== 0 ? Import$negBase.$less(i, 0) : Curry._1(r, Or_error$negBase.error_string("of_sorted_array: duplicated elements"));
                for(var i$1 = 1 ,i_finish = Import$negBase.$neg(Array$negBase.length(array), 2); i$1 <= i_finish; ++i$1){
                  var i$2 = Curry._2(compare_key, Import$negBase.fst(Caml_array.get(array, i$1)), Import$negBase.fst(Caml_array.get(array, Import$negBase.$plus(i$1, 1))));
                  if (i$2 !== 0) {
                    if (Import$negBase.$less(i$2, 0) !== increasing) {
                      Curry._1(r, Or_error$negBase.error_string("of_sorted_array: elements are not ordered"));
                    }
                    
                  } else {
                    Curry._1(r, Or_error$negBase.error_string("of_sorted_array: duplicated elements"));
                  }
                }
                return {
                        TAG: /* Ok */0,
                        _0: of_sorted_array_unchecked(array, compare_key)
                      };
              });
  } else {
    return {
            TAG: /* Ok */0,
            _0: of_sorted_array_unchecked(array, compare_key)
          };
  }
}

function bal(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  if (Import$negBase.$great(hl, Import$negBase.$plus(hr, 2))) {
    if (typeof l === "number") {
      return Import$negBase.invalid_arg("Map.bal");
    }
    if (l.TAG === /* Leaf */0) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "map.ml",
              164,
              18
            ],
            Error: new Error()
          };
    }
    var lr = l._3;
    var ld = l._2;
    var lv = l._1;
    var ll = l._0;
    if (Import$negBase.$great$eq(height(ll), height(lr))) {
      return create(ll, lv, ld, create(lr, x, d, r));
    } else if (typeof lr === "number") {
      return Import$negBase.invalid_arg("Map.bal");
    } else if (lr.TAG === /* Leaf */0) {
      return create(create(ll, lv, ld, /* Empty */0), lr._0, lr._1, create(/* Empty */0, x, d, r));
    } else {
      return create(create(ll, lv, ld, lr._0), lr._1, lr._2, create(lr._3, x, d, r));
    }
  } else {
    if (!Import$negBase.$great(hr, Import$negBase.$plus(hl, 2))) {
      return create(l, x, d, r);
    }
    if (typeof r === "number") {
      return Import$negBase.invalid_arg("Map.bal");
    }
    if (r.TAG === /* Leaf */0) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "map.ml",
              178,
              18
            ],
            Error: new Error()
          };
    }
    var rr = r._3;
    var rd = r._2;
    var rv = r._1;
    var rl = r._0;
    if (Import$negBase.$great$eq(height(rr), height(rl))) {
      return create(create(l, x, d, rl), rv, rd, rr);
    } else if (typeof rl === "number") {
      return Import$negBase.invalid_arg("Map.bal");
    } else if (rl.TAG === /* Leaf */0) {
      return create(create(l, x, d, /* Empty */0), rl._0, rl._1, create(/* Empty */0, rv, rd, rr));
    } else {
      return create(create(l, x, d, rl._0), rl._1, rl._2, create(rl._3, rv, rd, rr));
    }
  }
}

function is_empty(param) {
  if (typeof param === "number") {
    return true;
  } else {
    return false;
  }
}

function raise_key_already_present(key, sexp_of_key) {
  return Error$negBase.raise_s(Sexp$negBase.message("[Map.add_exn] got key already present", {
                  hd: [
                    "key",
                    Curry._1(sexp_of_key, key)
                  ],
                  tl: /* [] */0
                }));
}

function find_and_add_or_set(t, length, x, data, compare_key, sexp_of_key, add_or_set) {
  if (typeof t === "number") {
    return [
            {
              TAG: /* Leaf */0,
              _0: x,
              _1: data
            },
            Import$negBase.$plus(length, 1)
          ];
  }
  if (t.TAG === /* Leaf */0) {
    var d = t._1;
    var v = t._0;
    var c = Curry._2(compare_key, x, v);
    if (c !== 0) {
      if (Import$negBase.$less(c, 0)) {
        return [
                {
                  TAG: /* Node */1,
                  _0: {
                    TAG: /* Leaf */0,
                    _0: x,
                    _1: data
                  },
                  _1: v,
                  _2: d,
                  _3: /* Empty */0,
                  _4: 2
                },
                Import$negBase.$plus(length, 1)
              ];
      } else {
        return [
                {
                  TAG: /* Node */1,
                  _0: /* Empty */0,
                  _1: v,
                  _2: d,
                  _3: {
                    TAG: /* Leaf */0,
                    _0: x,
                    _1: data
                  },
                  _4: 2
                },
                Import$negBase.$plus(length, 1)
              ];
      }
    }
    switch (add_or_set) {
      case /* Add_exn_internal */0 :
          return Exn$negBase.raise_without_backtrace({
                      RE_EXN_ID: Duplicate
                    });
      case /* Add_exn */1 :
          return raise_key_already_present(x, sexp_of_key);
      case /* Set */2 :
          return [
                  {
                    TAG: /* Leaf */0,
                    _0: x,
                    _1: data
                  },
                  length
                ];
      
    }
  } else {
    var r = t._3;
    var d$1 = t._2;
    var v$1 = t._1;
    var l = t._0;
    var c$1 = Curry._2(compare_key, x, v$1);
    if (c$1 === 0) {
      switch (add_or_set) {
        case /* Add_exn_internal */0 :
            return Exn$negBase.raise_without_backtrace({
                        RE_EXN_ID: Duplicate
                      });
        case /* Add_exn */1 :
            return raise_key_already_present(x, sexp_of_key);
        case /* Set */2 :
            return [
                    {
                      TAG: /* Node */1,
                      _0: l,
                      _1: x,
                      _2: data,
                      _3: r,
                      _4: t._4
                    },
                    length
                  ];
        
      }
    } else {
      if (Import$negBase.$less(c$1, 0)) {
        var match = find_and_add_or_set(l, length, x, data, compare_key, sexp_of_key, add_or_set);
        return [
                bal(match[0], v$1, d$1, r),
                match[1]
              ];
      }
      var match$1 = find_and_add_or_set(r, length, x, data, compare_key, sexp_of_key, add_or_set);
      return [
              bal(l, v$1, d$1, match$1[0]),
              match$1[1]
            ];
    }
  }
}

function add_exn(t, length, key, data, compare_key, sexp_of_key) {
  return find_and_add_or_set(t, length, key, data, compare_key, sexp_of_key, /* Add_exn */1);
}

function add_exn_internal(t, length, key, data, compare_key, sexp_of_key) {
  return find_and_add_or_set(t, length, key, data, compare_key, sexp_of_key, /* Add_exn_internal */0);
}

function set(t, length, key, data, compare_key) {
  return find_and_add_or_set(t, length, key, data, compare_key, (function (param) {
                return {
                        TAG: /* List */1,
                        _0: /* [] */0
                      };
              }), /* Set */2);
}

function set$p(t, key, data, compare_key) {
  return Import$negBase.fst(set(t, 0, key, data, compare_key));
}

function singleton_to_tree_exn(param) {
  if (typeof param.left_subtree === "number") {
    return {
            TAG: /* Leaf */0,
            _0: param.key,
            _1: param.data
          };
  } else {
    return Import$negBase.failwith("Map.singleton_to_tree_exn: not a singleton");
  }
}

function collapse(l, r) {
  return create(l.left_subtree, l.key, l.data, r);
}

function join(l, r) {
  return {
          left_subtree: collapse(l, r.left_subtree),
          key: r.key,
          data: r.data
        };
}

function go(t, x) {
  switch (t.TAG | 0) {
    case /* Zero */0 :
        return {
                TAG: /* One */1,
                _0: t,
                _1: x
              };
    case /* One */1 :
        return {
                TAG: /* Two */2,
                _0: t._0,
                _1: t._1,
                _2: x
              };
    case /* Two */2 :
        return {
                TAG: /* One */1,
                _0: go(t._0, join(t._1, t._2)),
                _1: x
              };
    
  }
}

function add_unchecked(t, key, data) {
  return go(t, {
              left_subtree: /* Empty */0,
              key: key,
              data: data
            });
}

function go$1(_t, _r) {
  while(true) {
    var r = _r;
    var t = _t;
    switch (t.TAG | 0) {
      case /* Zero */0 :
          return r;
      case /* One */1 :
          _r = collapse(t._1, r);
          _t = t._0;
          continue ;
      case /* Two */2 :
          _r = collapse(join(t._1, t._2), r);
          _t = t._0;
          continue ;
      
    }
  };
}

function to_tree(param) {
  switch (param.TAG | 0) {
    case /* Zero */0 :
        return /* Empty */0;
    case /* One */1 :
        return go$1(param._0, singleton_to_tree_exn(param._1));
    case /* Two */2 :
        return go$1({
                    TAG: /* One */1,
                    _0: param._0,
                    _1: param._1
                  }, singleton_to_tree_exn(param._2));
    
  }
}

function max_key(param) {
  switch (param.TAG | 0) {
    case /* Zero */0 :
        return ;
    case /* One */1 :
        return Caml_option.some(param._1.key);
    case /* Two */2 :
        return Caml_option.some(param._2.key);
    
  }
}

function of_increasing_sequence(seq, compare_key) {
  return With_return$negBase.with_return(function (param) {
              var match = Sequence$negBase.fold(seq, [
                    {
                      TAG: /* Zero */0,
                      _0: undefined
                    },
                    0
                  ], (function (param$1, param$2) {
                      var key = param$2[0];
                      var builder = param$1[0];
                      var prev_key = max_key(builder);
                      if (prev_key !== undefined && Import$negBase.$great$eq(Curry._2(compare_key, Caml_option.valFromOption(prev_key), key), 0)) {
                        return Curry._1(param, Or_error$negBase.error_string("of_increasing_sequence: non-increasing key"));
                      }
                      return [
                              add_unchecked(builder, key, param$2[1]),
                              Import$negBase.$plus(param$1[1], 1)
                            ];
                    }));
              return {
                      TAG: /* Ok */0,
                      _0: [
                        to_tree(match[0]),
                        match[1]
                      ]
                    };
            });
}

function join$1(l, k, d, r, compare_key) {
  if (typeof l === "number") {
    return set$p(r, k, d, compare_key);
  }
  if (l.TAG !== /* Leaf */0) {
    var lh = l._4;
    if (typeof r !== "number") {
      if (r.TAG === /* Leaf */0) {
        return set$p(set$p(l, k, d, compare_key), r._0, r._1, compare_key);
      }
      var rh = r._4;
      if (Import$negBase.$great(lh, Import$negBase.$plus(rh, 3))) {
        return bal(l._0, l._1, l._2, join$1(l._3, k, d, r, compare_key));
      } else if (Import$negBase.$great(rh, Import$negBase.$plus(lh, 3))) {
        return bal(join$1(l, k, d, r._0, compare_key), r._1, r._2, r._3);
      } else {
        return bal(l, k, d, r);
      }
    }
    
  }
  if (typeof r === "number") {
    return set$p(l, k, d, compare_key);
  } else {
    return set$p(set$p(r, k, d, compare_key), l._0, l._1, compare_key);
  }
}

function split(t, x, compare_key) {
  if (typeof t === "number") {
    return [
            /* Empty */0,
            undefined,
            /* Empty */0
          ];
  }
  if (t.TAG === /* Leaf */0) {
    var k = t._0;
    var cmp = Curry._2(compare_key, x, k);
    if (cmp === 0) {
      return [
              /* Empty */0,
              [
                k,
                t._1
              ],
              /* Empty */0
            ];
    } else if (Import$negBase.$less(cmp, 0)) {
      return [
              /* Empty */0,
              undefined,
              t
            ];
    } else {
      return [
              t,
              undefined,
              /* Empty */0
            ];
    }
  }
  var r = t._3;
  var d = t._2;
  var k$1 = t._1;
  var l = t._0;
  var cmp$1 = Curry._2(compare_key, x, k$1);
  if (cmp$1 === 0) {
    return [
            l,
            [
              k$1,
              d
            ],
            r
          ];
  }
  if (Import$negBase.$less(cmp$1, 0)) {
    var match = split(l, x, compare_key);
    return [
            match[0],
            match[1],
            join$1(match[2], k$1, d, r, compare_key)
          ];
  }
  var match$1 = split(r, x, compare_key);
  return [
          join$1(l, k$1, d, match$1[0], compare_key),
          match$1[1],
          match$1[2]
        ];
}

function split_and_reinsert_boundary(t, into, x, compare_key) {
  var match = split(t, x, compare_key);
  var right = match[2];
  var boundary_opt = match[1];
  var left = match[0];
  if (boundary_opt === undefined) {
    return [
            left,
            right
          ];
  }
  var data = boundary_opt[1];
  var key = boundary_opt[0];
  var insert_into = function (tree) {
    return Import$negBase.fst(set(tree, 0, key, data, compare_key));
  };
  if (into === "Left") {
    return [
            insert_into(left),
            right
          ];
  } else {
    return [
            left,
            insert_into(right)
          ];
  }
}

function split_range(t, lower_bound, upper_bound, compare_key) {
  if (Maybe_bound$negBase.bounds_crossed(lower_bound, upper_bound, compare_key)) {
    return [
            /* Empty */0,
            /* Empty */0,
            /* Empty */0
          ];
  }
  var match;
  match = typeof lower_bound === "number" ? [
      /* Empty */0,
      t
    ] : (
      lower_bound.TAG === /* Incl */0 ? split_and_reinsert_boundary(t, "Right", lower_bound._0, compare_key) : split_and_reinsert_boundary(t, "Left", lower_bound._0, compare_key)
    );
  var mid_and_right = match[1];
  var match$1;
  match$1 = typeof upper_bound === "number" ? [
      mid_and_right,
      /* Empty */0
    ] : (
      upper_bound.TAG === /* Incl */0 ? split_and_reinsert_boundary(mid_and_right, "Left", upper_bound._0, compare_key) : split_and_reinsert_boundary(mid_and_right, "Right", upper_bound._0, compare_key)
    );
  return [
          match[0],
          match$1[0],
          match$1[1]
        ];
}

function find(_t, x, compare_key) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      if (Curry._2(compare_key, x, t._0) === 0) {
        return Caml_option.some(t._1);
      } else {
        return ;
      }
    }
    var c = Curry._2(compare_key, x, t._1);
    if (c === 0) {
      return Caml_option.some(t._2);
    }
    _t = Import$negBase.$less(c, 0) ? t._0 : t._3;
    continue ;
  };
}

function add_multi(t, length, key, data, compare_key) {
  var data_1 = Option$negBase.value(find(t, key, compare_key), /* [] */0);
  var data$1 = {
    hd: data,
    tl: data_1
  };
  return set(t, length, key, data$1, compare_key);
}

function find_multi(t, x, compare_key) {
  var l = find(t, x, compare_key);
  if (l !== undefined) {
    return l;
  } else {
    return /* [] */0;
  }
}

function if_not_found(key, sexp_of_key) {
  throw {
        RE_EXN_ID: Import$negBase.Not_found_s,
        _1: {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* Atom */0,
              _0: "Map.find_exn: not found"
            },
            tl: {
              hd: Curry._1(sexp_of_key, key),
              tl: /* [] */0
            }
          }
        },
        Error: new Error()
      };
}

function find_exn(_t, x, compare_key, sexp_of_key) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return if_not_found(x, sexp_of_key);
    }
    if (t.TAG === /* Leaf */0) {
      if (Curry._2(compare_key, x, t._0) === 0) {
        return t._1;
      } else {
        return if_not_found(x, sexp_of_key);
      }
    }
    var c = Curry._2(compare_key, x, t._1);
    if (c === 0) {
      return t._2;
    }
    _t = Import$negBase.$less(c, 0) ? t._0 : t._3;
    continue ;
  };
}

function mem(t, x, compare_key) {
  return Option$negBase.is_some(find(t, x, compare_key));
}

function min_elt(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG === /* Leaf */0) {
      return [
              param._0,
              param._1
            ];
    }
    var l = param._0;
    if (typeof l === "number") {
      return [
              param._1,
              param._2
            ];
    }
    _param = l;
    continue ;
  };
}

var Map_min_elt_exn_of_empty_map = /* @__PURE__ */Caml_exceptions.create("Map-Base.Tree0.Map_min_elt_exn_of_empty_map");

Sexp_conv$negSexplib0.Exn_converter.add(undefined, undefined, Map_min_elt_exn_of_empty_map, (function (param) {
        if (param.RE_EXN_ID === Map_min_elt_exn_of_empty_map) {
          return {
                  TAG: /* Atom */0,
                  _0: "map.ml.Tree0.Map_min_elt_exn_of_empty_map"
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "map.ml",
                504,
                15
              ],
              Error: new Error()
            };
      }));

var Map_max_elt_exn_of_empty_map = /* @__PURE__ */Caml_exceptions.create("Map-Base.Tree0.Map_max_elt_exn_of_empty_map");

Sexp_conv$negSexplib0.Exn_converter.add(undefined, undefined, Map_max_elt_exn_of_empty_map, (function (param) {
        if (param.RE_EXN_ID === Map_max_elt_exn_of_empty_map) {
          return {
                  TAG: /* Atom */0,
                  _0: "map.ml.Tree0.Map_max_elt_exn_of_empty_map"
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "map.ml",
                517,
                15
              ],
              Error: new Error()
            };
      }));

function min_elt_exn(t) {
  var v = min_elt(t);
  if (v !== undefined) {
    return v;
  }
  throw {
        RE_EXN_ID: Map_min_elt_exn_of_empty_map,
        Error: new Error()
      };
}

function max_elt(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG === /* Leaf */0) {
      return [
              param._0,
              param._1
            ];
    }
    if (typeof param._3 === "number") {
      return [
              param._1,
              param._2
            ];
    }
    _param = param._3;
    continue ;
  };
}

function max_elt_exn(t) {
  var v = max_elt(t);
  if (v !== undefined) {
    return v;
  }
  throw {
        RE_EXN_ID: Map_max_elt_exn_of_empty_map,
        Error: new Error()
      };
}

function remove_min_elt(t) {
  if (typeof t === "number") {
    return Import$negBase.invalid_arg("Map.remove_min_elt");
  }
  if (t.TAG === /* Leaf */0) {
    return /* Empty */0;
  }
  var l = t._0;
  if (typeof l === "number") {
    return t._3;
  } else {
    return bal(remove_min_elt(l), t._1, t._2, t._3);
  }
}

function append(lower_part, upper_part, compare_key) {
  var match = max_elt(lower_part);
  var match$1 = min_elt(upper_part);
  if (match === undefined) {
    return {
            NAME: "Ok",
            VAL: upper_part
          };
  }
  if (match$1 === undefined) {
    return {
            NAME: "Ok",
            VAL: lower_part
          };
  }
  var min_upper = match$1[0];
  if (!Import$negBase.$less(Curry._2(compare_key, match[0], min_upper), 0)) {
    return "Overlapping_key_ranges";
  }
  var upper_part_without_min = remove_min_elt(upper_part);
  return {
          NAME: "Ok",
          VAL: join$1(lower_part, min_upper, match$1[1], upper_part_without_min, compare_key)
        };
}

function go$2(_t, min, max, _init, f, compare_key) {
  while(true) {
    var init = _init;
    var t = _t;
    if (typeof t === "number") {
      return init;
    }
    if (t.TAG === /* Leaf */0) {
      var k = t._0;
      if (Import$negBase.$less(Curry._2(compare_key, k, min), 0) || Import$negBase.$great(Curry._2(compare_key, k, max), 0)) {
        return init;
      } else {
        return Curry._3(f, k, t._1, init);
      }
    }
    var r = t._3;
    var d = t._2;
    var k$1 = t._1;
    var c_min = Curry._2(compare_key, k$1, min);
    if (Import$negBase.$less(c_min, 0)) {
      _t = r;
      continue ;
    }
    if (c_min === 0) {
      _init = Curry._3(f, k$1, d, init);
      _t = r;
      continue ;
    }
    var z = go$2(t._0, min, max, init, f, compare_key);
    var c_max = Curry._2(compare_key, k$1, max);
    if (Import$negBase.$great(c_max, 0)) {
      return z;
    }
    var z$1 = Curry._3(f, k$1, d, z);
    if (c_max === 0) {
      return z$1;
    }
    _init = z$1;
    _t = r;
    continue ;
  };
}

function fold_range_inclusive(t, min, max, init, f, compare_key) {
  if (Import$negBase.$less$eq(Curry._2(compare_key, min, max), 0)) {
    return go$2(t, min, max, init, f, compare_key);
  } else {
    return init;
  }
}

function range_to_alist(t, min, max, compare_key) {
  return List0$negBase.rev(fold_range_inclusive(t, min, max, /* [] */0, (function (key, data, l) {
                    return {
                            hd: [
                              key,
                              data
                            ],
                            tl: l
                          };
                  }), compare_key));
}

function concat_unchecked(t1, t2) {
  if (typeof t1 === "number") {
    return t2;
  }
  if (typeof t2 === "number") {
    return t1;
  }
  var match = min_elt_exn(t2);
  return bal(t1, match[0], match[1], remove_min_elt(t2));
}

var Remove_no_op = /* @__PURE__ */Caml_exceptions.create("Map-Base.Tree0.Remove_no_op");

function remove(t, x, length, compare_key) {
  var remove_loop = function (t, x, length, compare_key) {
    if (typeof t === "number") {
      return Exn$negBase.raise_without_backtrace({
                  RE_EXN_ID: Remove_no_op
                });
    }
    if (t.TAG === /* Leaf */0) {
      if (Curry._2(compare_key, x, t._0) === 0) {
        return [
                /* Empty */0,
                Import$negBase.$neg(length, 1)
              ];
      } else {
        return Exn$negBase.raise_without_backtrace({
                    RE_EXN_ID: Remove_no_op
                  });
      }
    }
    var r = t._3;
    var d = t._2;
    var v = t._1;
    var l = t._0;
    var c = Curry._2(compare_key, x, v);
    if (c === 0) {
      return [
              concat_unchecked(l, r),
              Import$negBase.$neg(length, 1)
            ];
    }
    if (Import$negBase.$less(c, 0)) {
      var match = remove_loop(l, x, length, compare_key);
      return [
              bal(match[0], v, d, r),
              match[1]
            ];
    }
    var match$1 = remove_loop(r, x, length, compare_key);
    return [
            bal(l, v, d, match$1[0]),
            match$1[1]
          ];
  };
  try {
    return remove_loop(t, x, length, compare_key);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Remove_no_op) {
      return [
              t,
              length
            ];
    }
    throw exn;
  }
}

var Change_no_op = /* @__PURE__ */Caml_exceptions.create("Map-Base.Tree0.Change_no_op");

function change(t, key, f, length, compare_key) {
  var change_core = function (t, key, f) {
    if (typeof t === "number") {
      var data = Curry._1(f, undefined);
      if (data !== undefined) {
        return [
                {
                  TAG: /* Leaf */0,
                  _0: key,
                  _1: Caml_option.valFromOption(data)
                },
                Import$negBase.$plus(length, 1)
              ];
      }
      throw {
            RE_EXN_ID: Change_no_op,
            Error: new Error()
          };
    }
    if (t.TAG === /* Leaf */0) {
      var d = t._1;
      var v = t._0;
      var c = Curry._2(compare_key, key, v);
      if (c === 0) {
        var d$p = Curry._1(f, Caml_option.some(d));
        if (d$p !== undefined) {
          return [
                  {
                    TAG: /* Leaf */0,
                    _0: v,
                    _1: Caml_option.valFromOption(d$p)
                  },
                  length
                ];
        } else {
          return [
                  /* Empty */0,
                  Import$negBase.$neg(length, 1)
                ];
        }
      }
      if (Import$negBase.$less(c, 0)) {
        var match = change_core(/* Empty */0, key, f);
        return [
                bal(match[0], v, d, /* Empty */0),
                match[1]
              ];
      }
      var match$1 = change_core(/* Empty */0, key, f);
      return [
              bal(/* Empty */0, v, d, match$1[0]),
              match$1[1]
            ];
    }
    var r = t._3;
    var d$1 = t._2;
    var v$1 = t._1;
    var l = t._0;
    var c$1 = Curry._2(compare_key, key, v$1);
    if (c$1 === 0) {
      var data$1 = Curry._1(f, Caml_option.some(d$1));
      if (data$1 !== undefined) {
        return [
                {
                  TAG: /* Node */1,
                  _0: l,
                  _1: key,
                  _2: Caml_option.valFromOption(data$1),
                  _3: r,
                  _4: t._4
                },
                length
              ];
      } else {
        return [
                concat_unchecked(l, r),
                Import$negBase.$neg(length, 1)
              ];
      }
    }
    if (Import$negBase.$less(c$1, 0)) {
      var match$2 = change_core(l, key, f);
      return [
              bal(match$2[0], v$1, d$1, r),
              match$2[1]
            ];
    }
    var match$3 = change_core(r, key, f);
    return [
            bal(l, v$1, d$1, match$3[0]),
            match$3[1]
          ];
  };
  try {
    return change_core(t, key, f);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Change_no_op) {
      return [
              t,
              length
            ];
    }
    throw exn;
  }
}

function update(t, key, f, length, compare_key) {
  var update_core = function (t, key, f) {
    if (typeof t === "number") {
      var data = Curry._1(f, undefined);
      return [
              {
                TAG: /* Leaf */0,
                _0: key,
                _1: data
              },
              Import$negBase.$plus(length, 1)
            ];
    }
    if (t.TAG === /* Leaf */0) {
      var d = t._1;
      var v = t._0;
      var c = Curry._2(compare_key, key, v);
      if (c === 0) {
        var d$p = Curry._1(f, Caml_option.some(d));
        return [
                {
                  TAG: /* Leaf */0,
                  _0: v,
                  _1: d$p
                },
                length
              ];
      }
      if (Import$negBase.$less(c, 0)) {
        var match = update_core(/* Empty */0, key, f);
        return [
                bal(match[0], v, d, /* Empty */0),
                match[1]
              ];
      }
      var match$1 = update_core(/* Empty */0, key, f);
      return [
              bal(/* Empty */0, v, d, match$1[0]),
              match$1[1]
            ];
    }
    var r = t._3;
    var d$1 = t._2;
    var v$1 = t._1;
    var l = t._0;
    var c$1 = Curry._2(compare_key, key, v$1);
    if (c$1 === 0) {
      var data$1 = Curry._1(f, Caml_option.some(d$1));
      return [
              {
                TAG: /* Node */1,
                _0: l,
                _1: key,
                _2: data$1,
                _3: r,
                _4: t._4
              },
              length
            ];
    }
    if (Import$negBase.$less(c$1, 0)) {
      var match$2 = update_core(l, key, f);
      return [
              bal(match$2[0], v$1, d$1, r),
              match$2[1]
            ];
    }
    var match$3 = update_core(r, key, f);
    return [
            bal(l, v$1, d$1, match$3[0]),
            match$3[1]
          ];
  };
  return update_core(t, key, f);
}

function remove_multi(t, key, length, compare_key) {
  return change(t, key, (function (param) {
                if (param === undefined) {
                  return ;
                }
                if (!param) {
                  return ;
                }
                var non_empty_tail = param.tl;
                if (non_empty_tail) {
                  return non_empty_tail;
                }
                
              }), length, compare_key);
}

function iter_keys(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._1(f, t._0);
    }
    iter_keys(t._0, f);
    Curry._1(f, t._1);
    _t = t._3;
    continue ;
  };
}

function iter(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._1(f, t._1);
    }
    iter(t._0, f);
    Curry._1(f, t._2);
    _t = t._3;
    continue ;
  };
}

function iteri(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._2(f, t._0, t._1);
    }
    iteri(t._0, f);
    Curry._2(f, t._1, t._2);
    _t = t._3;
    continue ;
  };
}

function iteri_until_loop(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return /* Continue */0;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._2(f, t._0, t._1);
    }
    var match = iteri_until_loop(t._0, f);
    if (match) {
      return /* Stop */1;
    }
    var match$1 = Curry._2(f, t._1, t._2);
    if (match$1) {
      return /* Stop */1;
    }
    _t = t._3;
    continue ;
  };
}

function map(t, f) {
  if (typeof t === "number") {
    return /* Empty */0;
  }
  if (t.TAG === /* Leaf */0) {
    return {
            TAG: /* Leaf */0,
            _0: t._0,
            _1: Curry._1(f, t._1)
          };
  }
  var l$p = map(t._0, f);
  var d$p = Curry._1(f, t._2);
  var r$p = map(t._3, f);
  return {
          TAG: /* Node */1,
          _0: l$p,
          _1: t._1,
          _2: d$p,
          _3: r$p,
          _4: t._4
        };
}

function mapi(t, f) {
  if (typeof t === "number") {
    return /* Empty */0;
  }
  if (t.TAG === /* Leaf */0) {
    var v = t._0;
    return {
            TAG: /* Leaf */0,
            _0: v,
            _1: Curry._2(f, v, t._1)
          };
  }
  var v$1 = t._1;
  var l$p = mapi(t._0, f);
  var d$p = Curry._2(f, v$1, t._2);
  var r$p = mapi(t._3, f);
  return {
          TAG: /* Node */1,
          _0: l$p,
          _1: v$1,
          _2: d$p,
          _3: r$p,
          _4: t._4
        };
}

function fold(_t, _accu, f) {
  while(true) {
    var accu = _accu;
    var t = _t;
    if (typeof t === "number") {
      return accu;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._3(f, t._0, t._1, accu);
    }
    _accu = Curry._3(f, t._1, t._2, fold(t._0, accu, f));
    _t = t._3;
    continue ;
  };
}

function fold_right(_t, _accu, f) {
  while(true) {
    var accu = _accu;
    var t = _t;
    if (typeof t === "number") {
      return accu;
    }
    if (t.TAG === /* Leaf */0) {
      return Curry._3(f, t._0, t._1, accu);
    }
    _accu = Curry._3(f, t._1, t._2, fold_right(t._3, accu, f));
    _t = t._0;
    continue ;
  };
}

function filter_keys(t, f, compare_key) {
  return fold(t, [
              /* Empty */0,
              0
            ], (function (key, data, param) {
                var length = param[1];
                var accu = param[0];
                if (Curry._1(f, key)) {
                  return set(accu, length, key, data, compare_key);
                } else {
                  return [
                          accu,
                          length
                        ];
                }
              }));
}

function filter(t, f, compare_key) {
  return fold(t, [
              /* Empty */0,
              0
            ], (function (key, data, param) {
                var length = param[1];
                var accu = param[0];
                if (Curry._1(f, data)) {
                  return set(accu, length, key, data, compare_key);
                } else {
                  return [
                          accu,
                          length
                        ];
                }
              }));
}

function filteri(t, f, compare_key) {
  return fold(t, [
              /* Empty */0,
              0
            ], (function (key, data, param) {
                var length = param[1];
                var accu = param[0];
                if (Curry._2(f, key, data)) {
                  return set(accu, length, key, data, compare_key);
                } else {
                  return [
                          accu,
                          length
                        ];
                }
              }));
}

function filter_map(t, f, compare_key) {
  return fold(t, [
              /* Empty */0,
              0
            ], (function (key, data, param) {
                var length = param[1];
                var accu = param[0];
                var b = Curry._1(f, data);
                if (b !== undefined) {
                  return set(accu, length, key, Caml_option.valFromOption(b), compare_key);
                } else {
                  return [
                          accu,
                          length
                        ];
                }
              }));
}

function filter_mapi(t, f, compare_key) {
  return fold(t, [
              /* Empty */0,
              0
            ], (function (key, data, param) {
                var length = param[1];
                var accu = param[0];
                var b = Curry._2(f, key, data);
                if (b !== undefined) {
                  return set(accu, length, key, Caml_option.valFromOption(b), compare_key);
                } else {
                  return [
                          accu,
                          length
                        ];
                }
              }));
}

function partition_mapi(t, f, compare_key) {
  return fold(t, [
              [
                /* Empty */0,
                0
              ],
              [
                /* Empty */0,
                0
              ]
            ], (function (key, data, param) {
                var pair2 = param[1];
                var pair1 = param[0];
                var x = Curry._2(f, key, data);
                if (x.TAG === /* First */0) {
                  return [
                          set(pair1[0], pair1[1], key, x._0, compare_key),
                          pair2
                        ];
                } else {
                  return [
                          pair1,
                          set(pair2[0], pair2[1], key, x._0, compare_key)
                        ];
                }
              }));
}

function partition_map(t, f, compare_key) {
  return partition_mapi(t, (function (param, data) {
                return Curry._1(f, data);
              }), compare_key);
}

function partitioni_tf(t, f, compare_key) {
  return partition_mapi(t, (function (key, data) {
                if (Curry._2(f, key, data)) {
                  return {
                          TAG: /* First */0,
                          _0: data
                        };
                } else {
                  return {
                          TAG: /* Second */1,
                          _0: data
                        };
                }
              }), compare_key);
}

function partition_tf(t, f, compare_key) {
  return partition_mapi(t, (function (param, data) {
                if (Curry._1(f, data)) {
                  return {
                          TAG: /* First */0,
                          _0: data
                        };
                } else {
                  return {
                          TAG: /* Second */1,
                          _0: data
                        };
                }
              }), compare_key);
}

function cons(_t, _e) {
  while(true) {
    var e = _e;
    var t = _t;
    if (typeof t === "number") {
      return e;
    }
    if (t.TAG === /* Leaf */0) {
      return /* More */{
              _0: t._0,
              _1: t._1,
              _2: /* Empty */0,
              _3: e
            };
    }
    _e = /* More */{
      _0: t._1,
      _1: t._2,
      _2: t._3,
      _3: e
    };
    _t = t._0;
    continue ;
  };
}

function cons_right(_t, _e) {
  while(true) {
    var e = _e;
    var t = _t;
    if (typeof t === "number") {
      return e;
    }
    if (t.TAG === /* Leaf */0) {
      return /* More */{
              _0: t._0,
              _1: t._1,
              _2: /* Empty */0,
              _3: e
            };
    }
    _e = /* More */{
      _0: t._1,
      _1: t._2,
      _2: t._0,
      _3: e
    };
    _t = t._3;
    continue ;
  };
}

function starting_at_increasing(t, key, compare) {
  var _t = t;
  var _e = /* End */0;
  while(true) {
    var e = _e;
    var t$1 = _t;
    if (typeof t$1 === "number") {
      return e;
    }
    if (t$1.TAG === /* Leaf */0) {
      _t = {
        TAG: /* Node */1,
        _0: /* Empty */0,
        _1: t$1._0,
        _2: t$1._1,
        _3: /* Empty */0,
        _4: 1
      };
      continue ;
    }
    if (Import$negBase.$less(Curry._2(compare, t$1._1, key), 0)) {
      _t = t$1._3;
      continue ;
    }
    _e = /* More */{
      _0: t$1._1,
      _1: t$1._2,
      _2: t$1._3,
      _3: e
    };
    _t = t$1._0;
    continue ;
  };
}

function starting_at_decreasing(t, key, compare) {
  var _t = t;
  var _e = /* End */0;
  while(true) {
    var e = _e;
    var t$1 = _t;
    if (typeof t$1 === "number") {
      return e;
    }
    if (t$1.TAG === /* Leaf */0) {
      _t = {
        TAG: /* Node */1,
        _0: /* Empty */0,
        _1: t$1._0,
        _2: t$1._1,
        _3: /* Empty */0,
        _4: 1
      };
      continue ;
    }
    var l = t$1._0;
    if (Import$negBase.$great(Curry._2(compare, t$1._1, key), 0)) {
      _t = l;
      continue ;
    }
    _e = /* More */{
      _0: t$1._1,
      _1: t$1._2,
      _2: l,
      _3: e
    };
    _t = t$1._3;
    continue ;
  };
}

function fold$1(_init, f, _param) {
  while(true) {
    var param = _param;
    var init = _init;
    if (!param) {
      return init;
    }
    var next = Curry._3(f, param._0, param._1, init);
    _param = cons(param._2, param._3);
    _init = next;
    continue ;
  };
}

function fold2(compare_key, t1, t2, init, f) {
  var _t1 = t1;
  var _t2 = t2;
  var _curr = init;
  while(true) {
    var curr = _curr;
    var t2$1 = _t2;
    var t1$1 = _t1;
    if (!t1$1) {
      if (t2$1) {
        return fold$1(curr, (function (key, data, acc) {
                      return Curry._3(f, key, {
                                  NAME: "Right",
                                  VAL: data
                                }, acc);
                    }), t2$1);
      } else {
        return curr;
      }
    }
    if (!t2$1) {
      return fold$1(curr, (function (key, data, acc) {
                    return Curry._3(f, key, {
                                NAME: "Left",
                                VAL: data
                              }, acc);
                  }), t1$1);
    }
    var enum2 = t2$1._3;
    var tree2 = t2$1._2;
    var v2 = t2$1._1;
    var k2 = t2$1._0;
    var enum1 = t1$1._3;
    var tree1 = t1$1._2;
    var v1 = t1$1._1;
    var k1 = t1$1._0;
    var compare_result = Curry._2(compare_key, k1, k2);
    if (compare_result === 0) {
      var next = Curry._3(f, k1, {
            NAME: "Both",
            VAL: [
              v1,
              v2
            ]
          }, curr);
      _curr = next;
      _t2 = cons(tree2, enum2);
      _t1 = cons(tree1, enum1);
      continue ;
    }
    if (Import$negBase.$less(compare_result, 0)) {
      var next$1 = Curry._3(f, k1, {
            NAME: "Left",
            VAL: v1
          }, curr);
      _curr = next$1;
      _t1 = cons(tree1, enum1);
      continue ;
    }
    var next$2 = Curry._3(f, k2, {
          NAME: "Right",
          VAL: v2
        }, curr);
    _curr = next$2;
    _t2 = cons(tree2, enum2);
    continue ;
  };
}

function symmetric_diff(t1, t2, compare_key, data_equal) {
  var step = function (state) {
    var left = state[0];
    if (left) {
      var right = state[1];
      var $$enum = left._3;
      var tree = left._2;
      var data = left._1;
      var key = left._0;
      if (!right) {
        return {
                TAG: /* Yield */1,
                _0: [
                  key,
                  {
                    NAME: "Left",
                    VAL: data
                  }
                ],
                _1: [
                  cons(tree, $$enum),
                  /* End */0
                ]
              };
      }
      var enum2 = right._3;
      var tree2 = right._2;
      var v2 = right._1;
      var k2 = right._0;
      var compare_result = Curry._2(compare_key, key, k2);
      if (compare_result !== 0) {
        if (Import$negBase.$less(compare_result, 0)) {
          return {
                  TAG: /* Yield */1,
                  _0: [
                    key,
                    {
                      NAME: "Left",
                      VAL: data
                    }
                  ],
                  _1: [
                    cons(tree, $$enum),
                    right
                  ]
                };
        } else {
          return {
                  TAG: /* Yield */1,
                  _0: [
                    k2,
                    {
                      NAME: "Right",
                      VAL: v2
                    }
                  ],
                  _1: [
                    left,
                    cons(tree2, enum2)
                  ]
                };
        }
      }
      var next_state = Import$negBase.phys_equal(tree, tree2) ? [
          $$enum,
          enum2
        ] : [
          cons(tree, $$enum),
          cons(tree2, enum2)
        ];
      if (Curry._2(data_equal, data, v2)) {
        return {
                TAG: /* Skip */0,
                _0: next_state
              };
      } else {
        return {
                TAG: /* Yield */1,
                _0: [
                  key,
                  {
                    NAME: "Unequal",
                    VAL: [
                      data,
                      v2
                    ]
                  }
                ],
                _1: next_state
              };
      }
    }
    var match = state[1];
    if (match) {
      return {
              TAG: /* Yield */1,
              _0: [
                match._0,
                {
                  NAME: "Right",
                  VAL: match._1
                }
              ],
              _1: [
                /* End */0,
                cons(match._2, match._3)
              ]
            };
    } else {
      return /* Done */0;
    }
  };
  return Sequence$negBase.unfold_step([
              cons(t1, /* End */0),
              cons(t2, /* End */0)
            ], step);
}

function to_sequence(comparator, orderOpt, keys_greater_or_equal_to, keys_less_or_equal_to, t) {
  var order = orderOpt !== undefined ? orderOpt : "Increasing_key";
  var inclusive_bound = function (side, t, bound) {
    var compare_key = comparator.compare;
    var match = split(t, bound, compare_key);
    var maybe = match[1];
    var t$1 = Curry._1(side, [
          match[0],
          match[2]
        ]);
    if (maybe !== undefined) {
      return set$p(t$1, maybe[0], maybe[1], compare_key);
    } else {
      return t$1;
    }
  };
  if (order === "Decreasing_key") {
    var t$1 = Option$negBase.fold(keys_greater_or_equal_to, t, (function (param, param$1) {
            return inclusive_bound(Import$negBase.snd, param, param$1);
          }));
    var next = function ($$enum) {
      if ($$enum) {
        return {
                TAG: /* Yield */1,
                _0: [
                  $$enum._0,
                  $$enum._1
                ],
                _1: cons_right($$enum._2, $$enum._3)
              };
      } else {
        return /* Done */0;
      }
    };
    var init = keys_less_or_equal_to !== undefined ? starting_at_decreasing(t$1, Caml_option.valFromOption(keys_less_or_equal_to), comparator.compare) : cons_right(t$1, /* End */0);
    return Sequence$negBase.unfold_step(init, next);
  }
  var t$2 = Option$negBase.fold(keys_less_or_equal_to, t, (function (param, param$1) {
          return inclusive_bound(Import$negBase.fst, param, param$1);
        }));
  var next$1 = function ($$enum) {
    if ($$enum) {
      return {
              TAG: /* Yield */1,
              _0: [
                $$enum._0,
                $$enum._1
              ],
              _1: cons($$enum._2, $$enum._3)
            };
    } else {
      return /* Done */0;
    }
  };
  var init$1 = keys_greater_or_equal_to !== undefined ? starting_at_increasing(t$2, Caml_option.valFromOption(keys_greater_or_equal_to), comparator.compare) : cons(t$2, /* End */0);
  return Sequence$negBase.unfold_step(init$1, next$1);
}

function compare(compare_key, compare_data, t1, t2) {
  var t1$1 = cons(t1, /* End */0);
  var t2$1 = cons(t2, /* End */0);
  var _t1 = t1$1;
  var _t2 = t2$1;
  while(true) {
    var t2$2 = _t2;
    var t1$2 = _t1;
    if (!t1$2) {
      if (t2$2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!t2$2) {
      return 1;
    }
    var e2 = t2$2._3;
    var r2 = t2$2._2;
    var e1 = t1$2._3;
    var r1 = t1$2._2;
    var c = Curry._2(compare_key, t1$2._0, t2$2._0);
    if (Import$negBase.$less$great(c, 0)) {
      return c;
    }
    var c$1 = Curry._2(compare_data, t1$2._1, t2$2._1);
    if (Import$negBase.$less$great(c$1, 0)) {
      return c$1;
    }
    if (Import$negBase.phys_equal(r1, r2)) {
      _t2 = e2;
      _t1 = e1;
      continue ;
    }
    _t2 = cons(r2, e2);
    _t1 = cons(r1, e1);
    continue ;
  };
}

function equal(compare_key, compare_data, t1, t2) {
  var t1$1 = cons(t1, /* End */0);
  var t2$1 = cons(t2, /* End */0);
  var _t1 = t1$1;
  var _t2 = t2$1;
  while(true) {
    var t2$2 = _t2;
    var t1$2 = _t1;
    if (!t1$2) {
      if (t2$2) {
        return false;
      } else {
        return true;
      }
    }
    if (!t2$2) {
      return false;
    }
    var e2 = t2$2._3;
    var r2 = t2$2._2;
    var e1 = t1$2._3;
    var r1 = t1$2._2;
    if (Curry._2(compare_key, t1$2._0, t2$2._0) !== 0) {
      return false;
    }
    if (!Curry._2(compare_data, t1$2._1, t2$2._1)) {
      return false;
    }
    if (Import$negBase.phys_equal(r1, r2)) {
      _t2 = e2;
      _t1 = e1;
      continue ;
    }
    _t2 = cons(r2, e2);
    _t1 = cons(r1, e1);
    continue ;
  };
}

function iter2(t1, t2, f, compare_key) {
  return fold2(compare_key, cons(t1, /* End */0), cons(t2, /* End */0), undefined, (function (key, data, param) {
                return Curry._2(f, key, data);
              }));
}

function fold2$1(t1, t2, init, f, compare_key) {
  return fold2(compare_key, cons(t1, /* End */0), cons(t2, /* End */0), init, f);
}

function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f) {
  var slow = function (x, y, init) {
    var add = function (acc, k, v) {
      return Curry._2(f, acc, [
                  k,
                  {
                    NAME: "Right",
                    VAL: v
                  }
                ]);
    };
    var remove = function (acc, k, v) {
      return Curry._2(f, acc, [
                  k,
                  {
                    NAME: "Left",
                    VAL: v
                  }
                ]);
    };
    var _left = cons(x, /* End */0);
    var _right = cons(y, /* End */0);
    var _acc = init;
    while(true) {
      var acc = _acc;
      var right = _right;
      var left = _left;
      if (!left) {
        return fold$1(acc, (function (key, data, acc) {
                      return add(acc, key, data);
                    }), right);
      }
      if (!right) {
        return fold$1(acc, (function (key, data, acc) {
                      return remove(acc, key, data);
                    }), left);
      }
      var enum2 = right._3;
      var tree2 = right._2;
      var v2 = right._1;
      var k2 = right._0;
      var enum1 = left._3;
      var tree1 = left._2;
      var v1 = left._1;
      var k1 = left._0;
      var compare_result = Curry._2(compare_key, k1, k2);
      if (compare_result === 0) {
        var acc$1 = Curry._2(data_equal, v1, v2) ? acc : Curry._2(f, acc, [
                k1,
                {
                  NAME: "Unequal",
                  VAL: [
                    v1,
                    v2
                  ]
                }
              ]);
        if (Import$negBase.phys_equal(tree1, tree2)) {
          _acc = acc$1;
          _right = enum2;
          _left = enum1;
          continue ;
        }
        _acc = acc$1;
        _right = cons(tree2, enum2);
        _left = cons(tree1, enum1);
        continue ;
      }
      if (Import$negBase.$less(compare_result, 0)) {
        var acc$2 = remove(acc, k1, v1);
        _acc = acc$2;
        _left = cons(tree1, enum1);
        continue ;
      }
      var acc$3 = add(acc, k2, v2);
      _acc = acc$3;
      _right = cons(tree2, enum2);
      continue ;
    };
  };
  var add = function (acc, k, v) {
    return Curry._2(f, acc, [
                k,
                {
                  NAME: "Right",
                  VAL: v
                }
              ]);
  };
  var remove = function (acc, k, v) {
    return Curry._2(f, acc, [
                k,
                {
                  NAME: "Left",
                  VAL: v
                }
              ]);
  };
  var delta = function (acc, k, v, v$p) {
    if (Curry._2(data_equal, v, v$p)) {
      return acc;
    } else {
      return Curry._2(f, acc, [
                  k,
                  {
                    NAME: "Unequal",
                    VAL: [
                      v,
                      v$p
                    ]
                  }
                ]);
    }
  };
  var loop = function (_t, _t$p, _acc) {
    while(true) {
      var acc = _acc;
      var t$p = _t$p;
      var t = _t;
      if (Import$negBase.phys_equal(t, t$p)) {
        return acc;
      }
      if (typeof t === "number") {
        return fold(t$p, acc, (function (key, data, acc) {
                      return add(acc, key, data);
                    }));
      }
      if (t.TAG === /* Leaf */0) {
        var v = t._1;
        var k = t._0;
        if (typeof t$p !== "number") {
          if (t$p.TAG !== /* Leaf */0) {
            return slow(t, t$p, acc);
          }
          var v$p = t$p._1;
          var k$p = t$p._0;
          var x = Curry._2(compare_key, k, k$p);
          if (x === 0) {
            return delta(acc, k, v, v$p);
          }
          if (Import$negBase.$less(x, 0)) {
            var acc$1 = remove(acc, k, v);
            return add(acc$1, k$p, v$p);
          }
          var acc$2 = add(acc, k$p, v$p);
          return remove(acc$2, k, v);
        }
        
      } else {
        var k$1 = t._1;
        if (typeof t$p !== "number") {
          if (t$p.TAG === /* Leaf */0) {
            return slow(t, t$p, acc);
          }
          if (Curry._2(compare_key, k$1, t$p._1) !== 0) {
            return slow(t, t$p, acc);
          }
          var acc$3 = loop(t._0, t$p._0, acc);
          var acc$4 = delta(acc$3, k$1, t._2, t$p._2);
          _acc = acc$4;
          _t$p = t$p._3;
          _t = t._3;
          continue ;
        }
        
      }
      return fold(t, acc, (function (key, data, acc) {
                    return remove(acc, key, data);
                  }));
    };
  };
  return loop(t1, t2, init);
}

function length(param) {
  if (typeof param === "number") {
    return 0;
  } else if (param.TAG === /* Leaf */0) {
    return 1;
  } else {
    return Import$negBase.$plus(Import$negBase.$plus(length(param._0), length(param._3)), 1);
  }
}

function keys(t) {
  return fold_right(t, /* [] */0, (function (key, param, list) {
                return {
                        hd: key,
                        tl: list
                      };
              }));
}

function data(t) {
  return fold_right(t, /* [] */0, (function (param, data, list) {
                return {
                        hd: data,
                        tl: list
                      };
              }));
}

var name = "alist";

function of_foldable_fold(foldable, init, f, compare_key) {
  return List0$negBase.fold(foldable, [
              /* Empty */0,
              0
            ], (function (param, param$1) {
                var key = param$1[0];
                var accum = param[0];
                var prev = find(accum, key, compare_key);
                var prev_data = prev !== undefined ? Caml_option.valFromOption(prev) : init;
                var data = Curry._2(f, prev_data, param$1[1]);
                return set(accum, param[1], key, data, compare_key);
              }));
}

function of_foldable_reduce(foldable, f, compare_key) {
  return List0$negBase.fold(foldable, [
              /* Empty */0,
              0
            ], (function (param, param$1) {
                var data = param$1[1];
                var key = param$1[0];
                var accum = param[0];
                var prev = find(accum, key, compare_key);
                var new_data = prev !== undefined ? Curry._2(f, Caml_option.valFromOption(prev), data) : data;
                return set(accum, param[1], key, new_data, compare_key);
              }));
}

function of_foldable(foldable, compare_key) {
  return With_return$negBase.with_return(function (r) {
              var map = List0$negBase.fold(foldable, [
                    /* Empty */0,
                    0
                  ], (function (param, param$1) {
                      var key = param$1[0];
                      var length = param[1];
                      var acc = set(param[0], length, key, param$1[1], compare_key);
                      if (length === acc[1]) {
                        return Curry._1(r, {
                                    NAME: "Duplicate_key",
                                    VAL: key
                                  });
                      } else {
                        return acc;
                      }
                    }));
              return {
                      NAME: "Ok",
                      VAL: map
                    };
            });
}

function of_foldable_or_error(foldable, comparator) {
  var match = of_foldable(foldable, comparator.compare);
  if (match.NAME === "Ok") {
    return {
            TAG: /* Ok */0,
            _0: match.VAL
          };
  } else {
    return Or_error$negBase.error(undefined, undefined, Import$negBase.$caret("Map.of_", Import$negBase.$caret(name, "_or_error: duplicate key")), match.VAL, comparator.sexp_of_t);
  }
}

function of_foldable_exn(foldable, comparator) {
  var match = of_foldable(foldable, comparator.compare);
  if (match.NAME === "Ok") {
    return match.VAL;
  } else {
    return Error$negBase.raise(Error$negBase.create(undefined, undefined, Import$negBase.$caret("Map.of_", Import$negBase.$caret(name, "_exn: duplicate key")), match.VAL, comparator.sexp_of_t));
  }
}

function of_foldable_multi(foldable, fold, compare_key) {
  var alist = Curry._3(fold, foldable, /* [] */0, (function (l, x) {
          return {
                  hd: x,
                  tl: l
                };
        }));
  return of_foldable_fold(alist, /* [] */0, (function (l, x) {
                return {
                        hd: x,
                        tl: l
                      };
              }), compare_key);
}

var name$1 = "sequence";

function of_foldable_fold$1(foldable, init, f, compare_key) {
  return Sequence$negBase.fold(foldable, [
              /* Empty */0,
              0
            ], (function (param, param$1) {
                var key = param$1[0];
                var accum = param[0];
                var prev = find(accum, key, compare_key);
                var prev_data = prev !== undefined ? Caml_option.valFromOption(prev) : init;
                var data = Curry._2(f, prev_data, param$1[1]);
                return set(accum, param[1], key, data, compare_key);
              }));
}

function of_foldable_reduce$1(foldable, f, compare_key) {
  return Sequence$negBase.fold(foldable, [
              /* Empty */0,
              0
            ], (function (param, param$1) {
                var data = param$1[1];
                var key = param$1[0];
                var accum = param[0];
                var prev = find(accum, key, compare_key);
                var new_data = prev !== undefined ? Curry._2(f, Caml_option.valFromOption(prev), data) : data;
                return set(accum, param[1], key, new_data, compare_key);
              }));
}

function of_foldable$1(foldable, compare_key) {
  return With_return$negBase.with_return(function (r) {
              var map = Sequence$negBase.fold(foldable, [
                    /* Empty */0,
                    0
                  ], (function (param, param$1) {
                      var key = param$1[0];
                      var length = param[1];
                      var acc = set(param[0], length, key, param$1[1], compare_key);
                      if (length === acc[1]) {
                        return Curry._1(r, {
                                    NAME: "Duplicate_key",
                                    VAL: key
                                  });
                      } else {
                        return acc;
                      }
                    }));
              return {
                      NAME: "Ok",
                      VAL: map
                    };
            });
}

function of_foldable_or_error$1(foldable, comparator) {
  var match = of_foldable$1(foldable, comparator.compare);
  if (match.NAME === "Ok") {
    return {
            TAG: /* Ok */0,
            _0: match.VAL
          };
  } else {
    return Or_error$negBase.error(undefined, undefined, Import$negBase.$caret("Map.of_", Import$negBase.$caret(name$1, "_or_error: duplicate key")), match.VAL, comparator.sexp_of_t);
  }
}

function of_foldable_exn$1(foldable, comparator) {
  var match = of_foldable$1(foldable, comparator.compare);
  if (match.NAME === "Ok") {
    return match.VAL;
  } else {
    return Error$negBase.raise(Error$negBase.create(undefined, undefined, Import$negBase.$caret("Map.of_", Import$negBase.$caret(name$1, "_exn: duplicate key")), match.VAL, comparator.sexp_of_t));
  }
}

function for_all(t, f) {
  return With_return$negBase.with_return(function (r) {
              iter(t, (function (data) {
                      if (!Curry._1(f, data)) {
                        return Curry._1(r, false);
                      }
                      
                    }));
              return true;
            });
}

function for_alli(t, f) {
  return With_return$negBase.with_return(function (r) {
              iteri(t, (function (key, data) {
                      if (!Curry._2(f, key, data)) {
                        return Curry._1(r, false);
                      }
                      
                    }));
              return true;
            });
}

function exists(t, f) {
  return With_return$negBase.with_return(function (r) {
              iter(t, (function (data) {
                      if (Curry._1(f, data)) {
                        return Curry._1(r, true);
                      }
                      
                    }));
              return false;
            });
}

function existsi(t, f) {
  return With_return$negBase.with_return(function (r) {
              iteri(t, (function (key, data) {
                      if (Curry._2(f, key, data)) {
                        return Curry._1(r, true);
                      }
                      
                    }));
              return false;
            });
}

function count(t, f) {
  return fold(t, 0, (function (param, data, acc) {
                if (Curry._1(f, data)) {
                  return Import$negBase.$plus(acc, 1);
                } else {
                  return acc;
                }
              }));
}

function counti(t, f) {
  return fold(t, 0, (function (key, data, acc) {
                if (Curry._2(f, key, data)) {
                  return Import$negBase.$plus(acc, 1);
                } else {
                  return acc;
                }
              }));
}

function to_alist(key_orderOpt, t) {
  var key_order = key_orderOpt !== undefined ? key_orderOpt : "Increasing";
  if (key_order === "Increasing") {
    return fold_right(t, /* [] */0, (function (key, data, x) {
                  return {
                          hd: [
                            key,
                            data
                          ],
                          tl: x
                        };
                }));
  } else {
    return fold(t, /* [] */0, (function (key, data, x) {
                  return {
                          hd: [
                            key,
                            data
                          ],
                          tl: x
                        };
                }));
  }
}

function merge(t1, t2, f, compare_key) {
  var elts = Uniform_array$negBase.unsafe_create_uninitialized(Import$negBase.$plus(length(t1), length(t2)));
  var i = {
    contents: 0
  };
  iter2(t1, t2, (function (key, values) {
          var value = Curry._2(f, key, values);
          if (value !== undefined) {
            Uniform_array$negBase.set(elts, i[0], [
                  key,
                  Caml_option.valFromOption(value)
                ]);
            return Import$negBase.incr(i);
          }
          
        }), compare_key);
  var len = i[0];
  var get = function (i) {
    return Uniform_array$negBase.get(elts, i);
  };
  var tree = of_increasing_iterator_unchecked(len, get);
  return [
          tree,
          len
        ];
}

function repackage(marker, k, v) {
  if (marker) {
    return [
            k,
            v
          ];
  }
  
}

function closest_key(t, dir, k, compare_key) {
  var _t = t;
  var _found_marker = /* Missing */0;
  var _found_key;
  var _found_value;
  while(true) {
    var found_value = _found_value;
    var found_key = _found_key;
    var found_marker = _found_marker;
    var t$1 = _t;
    if (typeof t$1 === "number") {
      return repackage(found_marker, found_key, found_value);
    }
    if (t$1.TAG === /* Leaf */0) {
      var k$p = t$1._0;
      var c = Curry._2(compare_key, k$p, k);
      if (dir === "Less_than" ? Import$negBase.$less(c, 0) : (
            dir === "Greater_or_equal_to" ? Import$negBase.$great$eq(c, 0) : (
                dir === "Less_or_equal_to" ? Import$negBase.$less$eq(c, 0) : Import$negBase.$great(c, 0)
              )
          )) {
        return [
                k$p,
                t$1._1
              ];
      } else {
        return repackage(found_marker, found_key, found_value);
      }
    }
    var r = t$1._3;
    var v$p = t$1._2;
    var k$p$1 = t$1._1;
    var l = t$1._0;
    var c$1 = Curry._2(compare_key, k$p$1, k);
    if (c$1 === 0) {
      if (dir === "Less_than") {
        if (is_empty(l)) {
          return repackage(found_marker, found_key, found_value);
        } else {
          return max_elt(l);
        }
      } else if (dir === "Less_or_equal_to" || dir === "Greater_or_equal_to") {
        return [
                k$p$1,
                v$p
              ];
      } else if (is_empty(r)) {
        return repackage(found_marker, found_key, found_value);
      } else {
        return min_elt(r);
      }
    }
    if (dir === "Less_or_equal_to" || dir === "Less_than") {
      if (Import$negBase.$less(c$1, 0)) {
        _found_value = v$p;
        _found_key = k$p$1;
        _found_marker = /* Found */1;
        _t = r;
        continue ;
      }
      _t = l;
      continue ;
    }
    if (Import$negBase.$great(c$1, 0)) {
      _found_value = v$p;
      _found_key = k$p$1;
      _found_marker = /* Found */1;
      _t = l;
      continue ;
    }
    _t = r;
    continue ;
  };
}

function rank(_t, k, compare_key) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      if (Curry._2(compare_key, t._0, k) === 0) {
        return 0;
      } else {
        return ;
      }
    }
    var l = t._0;
    var c = Curry._2(compare_key, t._1, k);
    if (c === 0) {
      return length(l);
    }
    if (!Import$negBase.$great(c, 0)) {
      return Curry._2(Option$negBase.map, rank(t._3, k, compare_key), (function(l){
                return function (rank) {
                  return Import$negBase.$plus(Import$negBase.$plus(rank, 1), length(l));
                }
                }(l)));
    }
    _t = l;
    continue ;
  };
}

function nth$p(num_to_search, _param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.TAG === /* Leaf */0) {
      if (num_to_search[0] === 0) {
        return [
                param._0,
                param._1
              ];
      } else {
        Import$negBase.decr(num_to_search);
        return ;
      }
    }
    var some = nth$p(num_to_search, param._0);
    if (some !== undefined) {
      return some;
    }
    if (num_to_search[0] === 0) {
      return [
              param._1,
              param._2
            ];
    }
    Import$negBase.decr(num_to_search);
    _param = param._3;
    continue ;
  };
}

function find_first_satisfying(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      var v = t._1;
      var k = t._0;
      if (Curry._2(f, k, v)) {
        return [
                k,
                v
              ];
      } else {
        return ;
      }
    }
    var v$1 = t._2;
    var k$1 = t._1;
    if (Curry._2(f, k$1, v$1)) {
      var x = find_first_satisfying(t._0, f);
      if (x !== undefined) {
        return x;
      } else {
        return [
                k$1,
                v$1
              ];
      }
    }
    _t = t._3;
    continue ;
  };
}

function find_last_satisfying(_t, f) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return ;
    }
    if (t.TAG === /* Leaf */0) {
      var v = t._1;
      var k = t._0;
      if (Curry._2(f, k, v)) {
        return [
                k,
                v
              ];
      } else {
        return ;
      }
    }
    var v$1 = t._2;
    var k$1 = t._1;
    if (Curry._2(f, k$1, v$1)) {
      var x = find_last_satisfying(t._3, f);
      if (x !== undefined) {
        return x;
      } else {
        return [
                k$1,
                v$1
              ];
      }
    }
    _t = t._0;
    continue ;
  };
}

function binary_search(t, compare, how, v) {
  if (how === "Last_equal_to") {
    var pair = find_last_satisfying(t, (function (key, data) {
            return Import$negBase.$less$eq(Curry._3(compare, key, data, v), 0);
          }));
    if (pair !== undefined && Curry._3(compare, pair[0], pair[1], v) === 0) {
      return pair;
    } else {
      return ;
    }
  }
  if (how === "First_strictly_greater_than") {
    return find_first_satisfying(t, (function (key, data) {
                  return Import$negBase.$great(Curry._3(compare, key, data, v), 0);
                }));
  }
  if (how === "Last_less_than_or_equal_to") {
    return find_last_satisfying(t, (function (key, data) {
                  return Import$negBase.$less$eq(Curry._3(compare, key, data, v), 0);
                }));
  }
  if (how === "Last_strictly_less_than") {
    return find_last_satisfying(t, (function (key, data) {
                  return Import$negBase.$less(Curry._3(compare, key, data, v), 0);
                }));
  }
  if (how === "First_greater_than_or_equal_to") {
    return find_first_satisfying(t, (function (key, data) {
                  return Import$negBase.$great$eq(Curry._3(compare, key, data, v), 0);
                }));
  }
  var pair$1 = find_first_satisfying(t, (function (key, data) {
          return Import$negBase.$great$eq(Curry._3(compare, key, data, v), 0);
        }));
  if (pair$1 !== undefined && Curry._3(compare, pair$1[0], pair$1[1], v) === 0) {
    return pair$1;
  }
  
}

function binary_search_segmented(t, segment_of, how) {
  var is_left = function (key, data) {
    var match = Curry._2(segment_of, key, data);
    return match === "Left";
  };
  var is_right = function (key, data) {
    return !is_left(key, data);
  };
  if (how === "Last_on_left") {
    return find_last_satisfying(t, is_left);
  } else {
    return find_first_satisfying(t, is_right);
  }
}

function binary_search_one_sided_bound(t, maybe_bound, compare, if_exclusive, if_inclusive) {
  var find_bound = function (t, how, bound, compare) {
    var match = binary_search(t, compare, how, bound);
    if (match !== undefined) {
      return {
              TAG: /* Incl */0,
              _0: match[0]
            };
    }
    
  };
  if (typeof maybe_bound === "number") {
    return /* Unbounded */0;
  } else if (maybe_bound.TAG === /* Incl */0) {
    return find_bound(t, if_inclusive, maybe_bound._0, compare);
  } else {
    return find_bound(t, if_exclusive, maybe_bound._0, compare);
  }
}

function binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound) {
  var find_lower_bound = function (t, maybe_bound, compare) {
    return binary_search_one_sided_bound(t, maybe_bound, compare, "First_strictly_greater_than", "First_greater_than_or_equal_to");
  };
  var find_upper_bound = function (t, maybe_bound, compare) {
    return binary_search_one_sided_bound(t, maybe_bound, compare, "Last_strictly_less_than", "Last_less_than_or_equal_to");
  };
  var lower_bound$1 = find_lower_bound(t, lower_bound, compare);
  if (lower_bound$1 === undefined) {
    return ;
  }
  var upper_bound$1 = find_upper_bound(t, upper_bound, compare);
  if (upper_bound$1 !== undefined) {
    return [
            lower_bound$1,
            upper_bound$1
          ];
  }
  
}

function of_iteri(iteri, compare_key) {
  var acc = {
    bad_key: undefined,
    map_length: [
      /* Empty */0,
      0
    ]
  };
  Curry._1(iteri, (function (key, data) {
          var match = acc.map_length;
          var length = match[1];
          var pair = set(match[0], length, key, data, compare_key);
          if (length === pair[1] && Option$negBase.is_none(acc.bad_key)) {
            acc.bad_key = Caml_option.some(key);
          } else {
            acc.map_length = pair;
          }
          
        }));
  var key = acc.bad_key;
  if (key !== undefined) {
    return {
            NAME: "Duplicate_key",
            VAL: Caml_option.valFromOption(key)
          };
  } else {
    return {
            NAME: "Ok",
            VAL: acc.map_length
          };
  }
}

function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator) {
  var alist = Import$negBase.list_of_sexp((function (param) {
          return Import$negBase.pair_of_sexp(key_of_sexp, value_of_sexp, param);
        }), sexp);
  var compare_key = comparator.compare;
  var match = of_foldable(alist, compare_key);
  if (match.NAME === "Ok") {
    return match.VAL;
  }
  var k = match.VAL;
  var alist_sexps = Import$negBase.list_of_sexp((function (param) {
          return Import$negBase.pair_of_sexp((function (prim) {
                        return prim;
                      }), (function (prim) {
                        return prim;
                      }), param);
        }), sexp);
  var found_first_k = {
    contents: false
  };
  List0$negBase.iter2_ok(alist, alist_sexps, (function (param, param$1) {
          if (Curry._2(compare_key, k, param[0]) === 0) {
            if (found_first_k[0]) {
              return Import$negBase.of_sexp_error("Map.t_of_sexp_direct: duplicate key", param$1[0]);
            } else {
              found_first_k[0] = true;
              return ;
            }
          }
          
        }));
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "map.ml",
          1564,
          6
        ],
        Error: new Error()
      };
}

function sexp_of_t(sexp_of_key, sexp_of_value, t) {
  var f = function (key, data, acc) {
    return {
            hd: {
              TAG: /* List */1,
              _0: {
                hd: Curry._1(sexp_of_key, key),
                tl: {
                  hd: Curry._1(sexp_of_value, data),
                  tl: /* [] */0
                }
              }
            },
            tl: acc
          };
  };
  return {
          TAG: /* List */1,
          _0: fold_right(t, /* [] */0, f)
        };
}

function combine_errors(t, compare_key, sexp_of_key) {
  var match = partition_map(t, Result$negBase.to_either, compare_key);
  var error_tree = match[1][0];
  if (is_empty(error_tree)) {
    return {
            TAG: /* Ok */0,
            _0: match[0]
          };
  } else {
    return Or_error$negBase.error_s(sexp_of_t(sexp_of_key, Error$negBase.sexp_of_t, error_tree));
  }
}

function like(param, param$1) {
  return {
          comparator: param.comparator,
          tree: param$1[0],
          length: param$1[1]
        };
}

function like2(x, param) {
  return [
          like(x, param[0]),
          like(x, param[1])
        ];
}

function like_maybe_no_op(old_t, param) {
  var tree = param[0];
  if (Import$negBase.phys_equal(old_t.tree, tree)) {
    return old_t;
  } else {
    return {
            comparator: old_t.comparator,
            tree: tree,
            length: param[1]
          };
  }
}

function with_same_length(param, tree) {
  return {
          comparator: param.comparator,
          tree: tree,
          length: param.length
        };
}

function of_tree(comparator, tree) {
  return {
          comparator: comparator,
          tree: tree,
          length: length(tree)
        };
}

function comparator(t) {
  return t.comparator;
}

function to_tree$1(t) {
  return t.tree;
}

function invariants$1(t) {
  if (invariants(t.tree, t.comparator.compare)) {
    return length(t.tree) === t.length;
  } else {
    return false;
  }
}

function is_empty$1(t) {
  return is_empty(t.tree);
}

function length$1(t) {
  return t.length;
}

function set$1(t, key, data) {
  return like(t, set(t.tree, t.length, key, data, t.comparator.compare));
}

function add_exn$1(t, key, data) {
  return like(t, add_exn(t.tree, t.length, key, data, t.comparator.compare, t.comparator.sexp_of_t));
}

function add_exn_internal$1(t, key, data) {
  return like(t, add_exn_internal(t.tree, t.length, key, data, t.comparator.compare, t.comparator.sexp_of_t));
}

function add(t, key, data) {
  var result;
  try {
    result = add_exn_internal$1(t, key, data);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Duplicate) {
      return "Duplicate";
    }
    throw exn;
  }
  return {
          NAME: "Ok",
          VAL: result
        };
}

function add_multi$1(t, key, data) {
  return like(t, add_multi(t.tree, t.length, key, data, t.comparator.compare));
}

function remove_multi$1(t, key) {
  return like(t, remove_multi(t.tree, key, t.length, t.comparator.compare));
}

function find_multi$1(t, key) {
  return find_multi(t.tree, key, t.comparator.compare);
}

function change$1(t, key, f) {
  return like(t, change(t.tree, key, f, t.length, t.comparator.compare));
}

function update$1(t, key, f) {
  return like(t, update(t.tree, key, f, t.length, t.comparator.compare));
}

function find_exn$1(t, key) {
  return find_exn(t.tree, key, t.comparator.compare, t.comparator.sexp_of_t);
}

function find$1(t, key) {
  return find(t.tree, key, t.comparator.compare);
}

function remove$1(t, key) {
  return like_maybe_no_op(t, remove(t.tree, key, t.length, t.comparator.compare));
}

function mem$1(t, key) {
  return mem(t.tree, key, t.comparator.compare);
}

function iter_keys$1(t, f) {
  return iter_keys(t.tree, f);
}

function iter$1(t, f) {
  return iter(t.tree, f);
}

function iteri$1(t, f) {
  return iteri(t.tree, f);
}

function iteri_until(t, f) {
  return iteri_until_loop(t.tree, f);
}

function iter2$1(t1, t2, f) {
  return iter2(t1.tree, t2.tree, f, t1.comparator.compare);
}

function map$1(t, f) {
  return with_same_length(t, map(t.tree, f));
}

function mapi$1(t, f) {
  return with_same_length(t, mapi(t.tree, f));
}

function fold$2(t, init, f) {
  return fold(t.tree, init, f);
}

function fold_right$1(t, init, f) {
  return fold_right(t.tree, init, f);
}

function fold2$2(t1, t2, init, f) {
  return fold2$1(t1.tree, t2.tree, init, f, t1.comparator.compare);
}

function filter_keys$1(t, f) {
  return like(t, filter_keys(t.tree, f, t.comparator.compare));
}

function filter$1(t, f) {
  return like(t, filter(t.tree, f, t.comparator.compare));
}

function filteri$1(t, f) {
  return like(t, filteri(t.tree, f, t.comparator.compare));
}

function filter_map$1(t, f) {
  return like(t, filter_map(t.tree, f, t.comparator.compare));
}

function filter_mapi$1(t, f) {
  return like(t, filter_mapi(t.tree, f, t.comparator.compare));
}

function partition_mapi$1(t, f) {
  return like2(t, partition_mapi(t.tree, f, t.comparator.compare));
}

function partition_map$1(t, f) {
  return like2(t, partition_map(t.tree, f, t.comparator.compare));
}

function partitioni_tf$1(t, f) {
  return like2(t, partitioni_tf(t.tree, f, t.comparator.compare));
}

function partition_tf$1(t, f) {
  return like2(t, partition_tf(t.tree, f, t.comparator.compare));
}

function combine_errors$1(t) {
  return Curry._2(Or_error$negBase.map, combine_errors(t.tree, t.comparator.compare, t.comparator.sexp_of_t), (function (param) {
                return like(t, param);
              }));
}

function compare_direct(compare_data, t1, t2) {
  return compare(t1.comparator.compare, compare_data, t1.tree, t2.tree);
}

function equal$1(compare_data, t1, t2) {
  return equal(t1.comparator.compare, compare_data, t1.tree, t2.tree);
}

function keys$1(t) {
  return keys(t.tree);
}

function data$1(t) {
  return data(t.tree);
}

function to_alist$1(key_order, t) {
  return to_alist(key_order, t.tree);
}

function symmetric_diff$1(t1, t2, data_equal) {
  return symmetric_diff(t1.tree, t2.tree, t1.comparator.compare, data_equal);
}

function fold_symmetric_diff$1(t1, t2, data_equal, init, f) {
  return fold_symmetric_diff(t1.tree, t2.tree, t1.comparator.compare, data_equal, init, f);
}

function merge$1(t1, t2, f) {
  return like(t1, merge(t1.tree, t2.tree, f, t1.comparator.compare));
}

function min_elt$1(t) {
  return min_elt(t.tree);
}

function min_elt_exn$1(t) {
  return min_elt_exn(t.tree);
}

function max_elt$1(t) {
  return max_elt(t.tree);
}

function max_elt_exn$1(t) {
  return max_elt_exn(t.tree);
}

function for_all$1(t, f) {
  return for_all(t.tree, f);
}

function for_alli$1(t, f) {
  return for_alli(t.tree, f);
}

function exists$1(t, f) {
  return exists(t.tree, f);
}

function existsi$1(t, f) {
  return existsi(t.tree, f);
}

function count$1(t, f) {
  return count(t.tree, f);
}

function counti$1(t, f) {
  return counti(t.tree, f);
}

function split$1(t, k) {
  var match = split(t.tree, k, t.comparator.compare);
  var r = match[2];
  var maybe = match[1];
  var l = match[0];
  var comparator = t.comparator;
  var both_len = Option$negBase.is_some(maybe) ? Import$negBase.$neg(t.length, 1) : t.length;
  if (Import$negBase.$less(height(l), height(r))) {
    var l$1 = of_tree(comparator, l);
    return [
            l$1,
            maybe,
            {
              comparator: comparator,
              tree: r,
              length: Import$negBase.$neg(both_len, l$1.length)
            }
          ];
  }
  var r$1 = of_tree(comparator, r);
  return [
          {
            comparator: comparator,
            tree: l,
            length: Import$negBase.$neg(both_len, r$1.length)
          },
          maybe,
          r$1
        ];
}

function subrange(t, lower_bound, upper_bound) {
  var match = split_range(t.tree, lower_bound, upper_bound, t.comparator.compare);
  var right = match[2];
  var mid = match[1];
  var left = match[0];
  var h_l = height(left);
  var h_r = height(right);
  var outer_joined_height = h_l === h_r ? Import$negBase.$plus(h_l, 1) : Import$negBase.max(h_l, h_r);
  if (!Import$negBase.$less(outer_joined_height, height(mid))) {
    return of_tree(t.comparator, mid);
  }
  var mid_length = Import$negBase.$neg(t.length, Import$negBase.$plus(length(left), length(right)));
  return {
          comparator: t.comparator,
          tree: mid,
          length: mid_length
        };
}

function append$1(lower_part, upper_part) {
  var match = append(lower_part.tree, upper_part.tree, lower_part.comparator.compare);
  if (typeof match === "string") {
    return "Overlapping_key_ranges";
  } else {
    return {
            NAME: "Ok",
            VAL: {
              comparator: lower_part.comparator,
              tree: match.VAL,
              length: Import$negBase.$plus(lower_part.length, upper_part.length)
            }
          };
  }
}

function fold_range_inclusive$1(t, min, max, init, f) {
  return fold_range_inclusive(t.tree, min, max, init, f, t.comparator.compare);
}

function range_to_alist$1(t, min, max) {
  return range_to_alist(t.tree, min, max, t.comparator.compare);
}

function closest_key$1(t, dir, key) {
  return closest_key(t.tree, dir, key, t.comparator.compare);
}

function nth(t, n) {
  return nth$p({
              contents: n
            }, t.tree);
}

function nth_exn(t, n) {
  return Option$negBase.value_exn(undefined, undefined, undefined, nth$p({
                  contents: n
                }, t.tree));
}

function rank$1(t, key) {
  return rank(t.tree, key, t.comparator.compare);
}

function sexp_of_t$1(sexp_of_k, sexp_of_v, param, t) {
  return sexp_of_t(sexp_of_k, sexp_of_v, t.tree);
}

function to_sequence$1(order, keys_greater_or_equal_to, keys_less_or_equal_to, t) {
  return to_sequence(t.comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t.tree);
}

function binary_search$1(t, compare, how, v) {
  return binary_search(t.tree, compare, how, v);
}

function binary_search_segmented$1(t, segment_of, how) {
  return binary_search_segmented(t.tree, segment_of, how);
}

function hash_fold_direct(hash_fold_key, hash_fold_data, state, t) {
  var t$1 = t.tree;
  return fold(t$1, Import$negBase.hash_fold_int(state, length(t$1)), (function (key, data, state) {
                return Curry._2(hash_fold_data, Curry._2(hash_fold_key, state, key), data);
              }));
}

function binary_search_subrange(t, compare, lower_bound, upper_bound) {
  var match = binary_search_two_sided_bounds(t.tree, compare, lower_bound, upper_bound);
  if (match !== undefined) {
    return subrange(t, match[0], match[1]);
  } else {
    return like_maybe_no_op(t, [
                /* Empty */0,
                0
              ]);
  }
}

function empty(param) {
  return /* Empty */0;
}

function of_tree$1(param, tree) {
  return tree;
}

function singleton(param, k, v) {
  return {
          TAG: /* Leaf */0,
          _0: k,
          _1: v
        };
}

function of_sorted_array_unchecked$1(comparator, array) {
  return Import$negBase.fst(of_sorted_array_unchecked(array, comparator.compare));
}

function of_sorted_array$1(comparator, array) {
  var param = of_sorted_array(array, comparator.compare);
  return Curry._2(Or_error$negBase.map, param, Import$negBase.fst);
}

function of_alist(comparator, alist) {
  var d = of_foldable(alist, comparator.compare);
  if (d.NAME === "Ok") {
    return {
            NAME: "Ok",
            VAL: d.VAL[0]
          };
  } else {
    return d;
  }
}

function of_alist_or_error(comparator, alist) {
  var param = of_foldable_or_error(alist, comparator);
  return Curry._2(Or_error$negBase.map, param, Import$negBase.fst);
}

function of_alist_exn(comparator, alist) {
  return Import$negBase.fst(of_foldable_exn(alist, comparator));
}

function of_alist_multi(comparator, alist) {
  return Import$negBase.fst(of_foldable_multi(alist, List0$negBase.fold, comparator.compare));
}

function of_alist_fold(comparator, alist, init, f) {
  return Import$negBase.fst(of_foldable_fold(alist, init, f, comparator.compare));
}

function of_alist_reduce(comparator, alist, f) {
  return Import$negBase.fst(of_foldable_reduce(alist, f, comparator.compare));
}

function of_iteri$1(comparator, iteri) {
  var d = of_iteri(iteri, comparator.compare);
  if (d.NAME === "Ok") {
    return {
            NAME: "Ok",
            VAL: d.VAL[0]
          };
  } else {
    return d;
  }
}

function of_increasing_iterator_unchecked$1(_required_by_intf, len, f) {
  return of_increasing_iterator_unchecked(len, f);
}

function of_increasing_sequence$1(comparator, seq) {
  return Curry._2(Or_error$negBase.map, of_increasing_sequence(seq, comparator.compare), Import$negBase.fst);
}

function of_sequence(comparator, seq) {
  var d = of_foldable$1(seq, comparator.compare);
  if (d.NAME === "Ok") {
    return {
            NAME: "Ok",
            VAL: d.VAL[0]
          };
  } else {
    return d;
  }
}

function of_sequence_or_error(comparator, seq) {
  var param = of_foldable_or_error$1(seq, comparator);
  return Curry._2(Or_error$negBase.map, param, Import$negBase.fst);
}

function of_sequence_exn(comparator, seq) {
  return Import$negBase.fst(of_foldable_exn$1(seq, comparator));
}

function of_sequence_multi(comparator, seq) {
  return Import$negBase.fst(of_foldable_multi(seq, Sequence$negBase.fold, comparator.compare));
}

function of_sequence_fold(comparator, seq, init, f) {
  return Import$negBase.fst(of_foldable_fold$1(seq, init, f, comparator.compare));
}

function of_sequence_reduce(comparator, seq, f) {
  return Import$negBase.fst(of_foldable_reduce$1(seq, f, comparator.compare));
}

function to_tree$2(t) {
  return t;
}

function invariants$2(comparator, t) {
  return invariants(t, comparator.compare);
}

var is_empty$2 = is_empty;

var length$2 = length;

function set$2(comparator, t, key, data) {
  return Import$negBase.fst(set(t, 0, key, data, comparator.compare));
}

function add_exn$2(comparator, t, key, data) {
  return Import$negBase.fst(add_exn(t, 0, key, data, comparator.compare, comparator.sexp_of_t));
}

function add$1(comparator, t, key, data) {
  try {
    return {
            NAME: "Ok",
            VAL: add_exn$2(comparator, t, key, data)
          };
  }
  catch (exn){
    return "Duplicate";
  }
}

function add_multi$2(comparator, t, key, data) {
  return Import$negBase.fst(add_multi(t, 0, key, data, comparator.compare));
}

function remove_multi$2(comparator, t, key) {
  return Import$negBase.fst(remove_multi(t, key, 0, comparator.compare));
}

function find_multi$2(comparator, t, key) {
  return find_multi(t, key, comparator.compare);
}

function change$2(comparator, t, key, f) {
  return Import$negBase.fst(change(t, key, f, 0, comparator.compare));
}

function update$2(comparator, t, key, f) {
  return change$2(comparator, t, key, (function (data) {
                return Caml_option.some(Curry._1(f, data));
              }));
}

function find_exn$2(comparator, t, key) {
  return find_exn(t, key, comparator.compare, comparator.sexp_of_t);
}

function find$2(comparator, t, key) {
  return find(t, key, comparator.compare);
}

function remove$2(comparator, t, key) {
  return Import$negBase.fst(remove(t, key, 0, comparator.compare));
}

function mem$2(comparator, t, key) {
  return mem(t, key, comparator.compare);
}

var iter_keys$2 = iter_keys;

var iter$2 = iter;

var iteri$2 = iteri;

var iteri_until$1 = iteri_until_loop;

function iter2$2(comparator, t1, t2, f) {
  return iter2(t1, t2, f, comparator.compare);
}

var map$2 = map;

var mapi$2 = mapi;

var fold$3 = fold;

var fold_right$2 = fold_right;

function fold2$3(comparator, t1, t2, init, f) {
  return fold2$1(t1, t2, init, f, comparator.compare);
}

function filter_keys$2(comparator, t, f) {
  return Import$negBase.fst(filter_keys(t, f, comparator.compare));
}

function filter$2(comparator, t, f) {
  return Import$negBase.fst(filter(t, f, comparator.compare));
}

function filteri$2(comparator, t, f) {
  return Import$negBase.fst(filteri(t, f, comparator.compare));
}

function filter_map$2(comparator, t, f) {
  return Import$negBase.fst(filter_map(t, f, comparator.compare));
}

function filter_mapi$2(comparator, t, f) {
  return Import$negBase.fst(filter_mapi(t, f, comparator.compare));
}

function partition_mapi$2(comparator, t, f) {
  var match = partition_mapi(t, f, comparator.compare);
  return [
          match[0][0],
          match[1][0]
        ];
}

function partition_map$2(comparator, t, f) {
  var match = partition_map(t, f, comparator.compare);
  return [
          match[0][0],
          match[1][0]
        ];
}

function partitioni_tf$2(comparator, t, f) {
  var match = partitioni_tf(t, f, comparator.compare);
  return [
          match[0][0],
          match[1][0]
        ];
}

function partition_tf$2(comparator, t, f) {
  var match = partition_tf(t, f, comparator.compare);
  return [
          match[0][0],
          match[1][0]
        ];
}

function combine_errors$2(comparator, t) {
  return Curry._2(Or_error$negBase.map, combine_errors(t, comparator.compare, comparator.sexp_of_t), Import$negBase.fst);
}

function compare_direct$1(comparator, compare_data, t1, t2) {
  return compare(comparator.compare, compare_data, t1, t2);
}

function equal$2(comparator, compare_data, t1, t2) {
  return equal(comparator.compare, compare_data, t1, t2);
}

var keys$2 = keys;

var data$2 = data;

var to_alist$2 = to_alist;

function symmetric_diff$2(comparator, t1, t2, data_equal) {
  return symmetric_diff(t1, t2, comparator.compare, data_equal);
}

function fold_symmetric_diff$2(comparator, t1, t2, data_equal, init, f) {
  return fold_symmetric_diff(t1, t2, comparator.compare, data_equal, init, f);
}

function merge$2(comparator, t1, t2, f) {
  return Import$negBase.fst(merge(t1, t2, f, comparator.compare));
}

var min_elt$2 = min_elt;

var min_elt_exn$2 = min_elt_exn;

var max_elt$2 = max_elt;

var max_elt_exn$2 = max_elt_exn;

var for_all$2 = for_all;

var for_alli$2 = for_alli;

var exists$2 = exists;

var existsi$2 = existsi;

var count$2 = count;

var counti$2 = counti;

function split$2(comparator, t, k) {
  return split(t, k, comparator.compare);
}

function append$2(comparator, lower_part, upper_part) {
  return append(lower_part, upper_part, comparator.compare);
}

function subrange$1(comparator, t, lower_bound, upper_bound) {
  return split_range(t, lower_bound, upper_bound, comparator.compare)[1];
}

function fold_range_inclusive$2(comparator, t, min, max, init, f) {
  return fold_range_inclusive(t, min, max, init, f, comparator.compare);
}

function range_to_alist$2(comparator, t, min, max) {
  return range_to_alist(t, min, max, comparator.compare);
}

function closest_key$2(comparator, t, dir, key) {
  return closest_key(t, dir, key, comparator.compare);
}

function nth$1(param, t, n) {
  return nth$p({
              contents: n
            }, t);
}

function nth_exn$1(comparator, t, n) {
  return Option$negBase.value_exn(undefined, undefined, undefined, nth$p({
                  contents: n
                }, t));
}

function rank$2(comparator, t, key) {
  return rank(t, key, comparator.compare);
}

function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t) {
  return sexp_of_t(sexp_of_k, sexp_of_v, t);
}

function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp) {
  return Import$negBase.fst(t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
}

var to_sequence$2 = to_sequence;

function binary_search$2(param, t, compare, how, v) {
  return binary_search(t, compare, how, v);
}

function binary_search_segmented$2(param, t, segment_of, how) {
  return binary_search_segmented(t, segment_of, how);
}

function binary_search_subrange$1(comparator, t, compare, lower_bound, upper_bound) {
  var match = binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
  if (match !== undefined) {
    return subrange$1(comparator, t, match[0], match[1]);
  } else {
    return /* Empty */0;
  }
}

function empty$1(comparator) {
  return {
          comparator: comparator,
          tree: /* Empty */0,
          length: 0
        };
}

function singleton$1(comparator, k, v) {
  return {
          comparator: comparator,
          tree: {
            TAG: /* Leaf */0,
            _0: k,
            _1: v
          },
          length: 1
        };
}

function of_tree0(comparator, param) {
  return {
          comparator: comparator,
          tree: param[0],
          length: param[1]
        };
}

function of_tree$2(comparator, tree) {
  return of_tree0(comparator, [
              tree,
              length(tree)
            ]);
}

function of_sorted_array_unchecked$2(comparator, array) {
  return of_tree0(comparator, of_sorted_array_unchecked(array, comparator.compare));
}

function of_sorted_array$2(comparator, array) {
  return Curry._2(Or_error$negBase.map, of_sorted_array(array, comparator.compare), (function (tree) {
                return of_tree0(comparator, tree);
              }));
}

function of_alist$1(comparator, alist) {
  var z = of_foldable(alist, comparator.compare);
  if (z.NAME !== "Ok") {
    return z;
  }
  var match = z.VAL;
  return {
          NAME: "Ok",
          VAL: {
            comparator: comparator,
            tree: match[0],
            length: match[1]
          }
        };
}

function of_alist_or_error$1(comparator, alist) {
  return Curry._2(Result$negBase.map, of_foldable_or_error(alist, comparator), (function (tree) {
                return of_tree0(comparator, tree);
              }));
}

function of_alist_exn$1(comparator, alist) {
  return of_tree0(comparator, of_foldable_exn(alist, comparator));
}

function of_alist_multi$1(comparator, alist) {
  return of_tree0(comparator, of_foldable_multi(alist, List0$negBase.fold, comparator.compare));
}

function of_alist_fold$1(comparator, alist, init, f) {
  return of_tree0(comparator, of_foldable_fold(alist, init, f, comparator.compare));
}

function of_alist_reduce$1(comparator, alist, f) {
  return of_tree0(comparator, of_foldable_reduce(alist, f, comparator.compare));
}

function of_iteri$2(comparator, iteri) {
  var z = of_iteri(iteri, comparator.compare);
  if (z.NAME === "Ok") {
    return {
            NAME: "Ok",
            VAL: of_tree0(comparator, z.VAL)
          };
  } else {
    return z;
  }
}

function of_increasing_iterator_unchecked$2(comparator, len, f) {
  return of_tree0(comparator, [
              of_increasing_iterator_unchecked(len, f),
              len
            ]);
}

function of_increasing_sequence$2(comparator, seq) {
  return Curry._2(Or_error$negBase.map, of_increasing_sequence(seq, comparator.compare), (function (param) {
                return of_tree0(comparator, param);
              }));
}

function of_sequence$1(comparator, seq) {
  var z = of_foldable$1(seq, comparator.compare);
  if (z.NAME !== "Ok") {
    return z;
  }
  var match = z.VAL;
  return {
          NAME: "Ok",
          VAL: {
            comparator: comparator,
            tree: match[0],
            length: match[1]
          }
        };
}

function of_sequence_or_error$1(comparator, seq) {
  return Curry._2(Result$negBase.map, of_foldable_or_error$1(seq, comparator), (function (tree) {
                return of_tree0(comparator, tree);
              }));
}

function of_sequence_exn$1(comparator, seq) {
  return of_tree0(comparator, of_foldable_exn$1(seq, comparator));
}

function of_sequence_multi$1(comparator, seq) {
  return of_tree0(comparator, of_foldable_multi(seq, Sequence$negBase.fold, comparator.compare));
}

function of_sequence_fold$1(comparator, seq, init, f) {
  return of_tree0(comparator, of_foldable_fold$1(seq, init, f, comparator.compare));
}

function of_sequence_reduce$1(comparator, seq, f) {
  return of_tree0(comparator, of_foldable_reduce$1(seq, f, comparator.compare));
}

function t_of_sexp_direct$2(comparator, k_of_sexp, v_of_sexp, sexp) {
  return of_tree0(comparator, t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
}

function map_keys(comparator2, f, t) {
  var x = to_sequence$1(undefined, undefined, undefined, t);
  var arg = function (param) {
    return [
            Curry._1(f, param[0]),
            param[1]
          ];
  };
  return of_sequence$1(comparator2, (function (param) {
                  return Curry._2(Sequence$negBase.map, param, arg);
                })(x));
}

function map_keys_exn(comparator2, f, t) {
  var match = map_keys(comparator2, f, t);
  if (match.NAME === "Ok") {
    return match.VAL;
  }
  var sexp_of_key = comparator2.sexp_of_t;
  return Error$negBase.raise_s(Sexp$negBase.message("Map.map_keys_exn: duplicate key", {
                  hd: [
                    "key",
                    Curry._1(sexp_of_key, match.VAL)
                  ],
                  tl: /* [] */0
                }));
}

function Empty_without_value_restriction(K) {
  var empty_comparator = K.comparator;
  var empty = {
    comparator: empty_comparator,
    tree: /* Empty */0,
    length: 0
  };
  return {
          empty: empty
        };
}

function comparator_s(t) {
  var comparator = t.comparator;
  return {
          comparator: comparator
        };
}

function empty$2(m) {
  return {
          comparator: m.comparator,
          tree: /* Empty */0,
          length: 0
        };
}

function singleton$2(m, a) {
  return function (param) {
    return singleton$1(m.comparator, a, param);
  };
}

function of_alist$2(m, a) {
  return of_alist$1(m.comparator, a);
}

function of_alist_or_error$2(m, a) {
  return of_alist_or_error$1(m.comparator, a);
}

function of_alist_exn$2(m, a) {
  return of_alist_exn$1(m.comparator, a);
}

function of_alist_multi$2(m, a) {
  return of_alist_multi$1(m.comparator, a);
}

function of_alist_fold$2(m, a, init, f) {
  return of_alist_fold$1(m.comparator, a, init, f);
}

function of_alist_reduce$2(m, a, f) {
  return of_alist_reduce$1(m.comparator, a, f);
}

function of_sorted_array_unchecked$3(m, a) {
  return of_sorted_array_unchecked$2(m.comparator, a);
}

function of_sorted_array$3(m, a) {
  return of_sorted_array$2(m.comparator, a);
}

function of_iteri$3(m, iteri) {
  return of_iteri$2(m.comparator, iteri);
}

function of_increasing_iterator_unchecked$3(m, len, f) {
  return of_increasing_iterator_unchecked$2(m.comparator, len, f);
}

function of_increasing_sequence$3(m, seq) {
  return of_increasing_sequence$2(m.comparator, seq);
}

function of_sequence$2(m, s) {
  return of_sequence$1(m.comparator, s);
}

function of_sequence_or_error$2(m, s) {
  return of_sequence_or_error$1(m.comparator, s);
}

function of_sequence_exn$2(m, s) {
  return of_sequence_exn$1(m.comparator, s);
}

function of_sequence_multi$2(m, s) {
  return of_sequence_multi$1(m.comparator, s);
}

function of_sequence_fold$2(m, s, init, f) {
  return of_sequence_fold$1(m.comparator, s, init, f);
}

function of_sequence_reduce$2(m, s, f) {
  return of_sequence_reduce$1(m.comparator, s, f);
}

var map_keys$1 = map_keys;

var map_keys_exn$1 = map_keys_exn;

function M(K) {
  return {};
}

function sexp_of_m__t(K, sexp_of_v, t) {
  return sexp_of_t$1(K.sexp_of_t, sexp_of_v, (function (param) {
                return {
                        TAG: /* Atom */0,
                        _0: "_"
                      };
              }), t);
}

function m__t_of_sexp(K, v_of_sexp, sexp) {
  return t_of_sexp_direct$2(K.comparator, K.t_of_sexp, v_of_sexp, sexp);
}

function m__t_sexp_grammar(K, v_grammar) {
  return {
          TAG: /* List */3,
          _0: {
            TAG: /* Many */1,
            _0: {
              TAG: /* List */3,
              _0: {
                TAG: /* Cons */0,
                _0: K.t_sexp_grammar,
                _1: {
                  TAG: /* Cons */0,
                  _0: v_grammar,
                  _1: /* Empty */0
                }
              }
            }
          }
        };
}

function compare_m__t(K, compare_v, t1, t2) {
  return compare_direct(compare_v, t1, t2);
}

function equal_m__t(K, equal_v, t1, t2) {
  return equal$1(equal_v, t1, t2);
}

function hash_fold_m__t(K, hash_fold_v, state) {
  return function (param) {
    return hash_fold_direct(K.hash_fold_t, hash_fold_v, state, param);
  };
}

function merge_skewed(t1, t2, combine) {
  var match = Import$negBase.$less$eq(t2.length, t1.length) ? [
      t1,
      t2,
      combine
    ] : [
      t2,
      t1,
      (function (key, v1, v2) {
          return Curry._3(combine, key, v2, v1);
        })
    ];
  var combine$1 = match[2];
  return fold$2(match[1], match[0], (function (key, v2, t1) {
                return change$1(t1, key, (function (v1) {
                              if (v1 !== undefined) {
                                return Caml_option.some(Curry._3(combine$1, key, Caml_option.valFromOption(v1), v2));
                              } else {
                                return Caml_option.some(v2);
                              }
                            }));
              }));
}

var comparator$1 = Comparator$negBase.Poly.comparator;

function of_tree$3(tree) {
  return {
          comparator: comparator$1,
          tree: tree,
          length: length(tree)
        };
}

var empty_comparator = Comparator$negBase.Poly.comparator;

var empty$3 = {
  comparator: empty_comparator,
  tree: /* Empty */0,
  length: 0
};

function singleton$3(a) {
  return function (param) {
    return singleton$1(comparator$1, a, param);
  };
}

function of_alist$3(a) {
  return of_alist$1(comparator$1, a);
}

function of_alist_or_error$3(a) {
  return of_alist_or_error$1(comparator$1, a);
}

function of_alist_exn$3(a) {
  return of_alist_exn$1(comparator$1, a);
}

function of_alist_multi$3(a) {
  return of_alist_multi$1(comparator$1, a);
}

function of_alist_fold$3(a, init, f) {
  return of_alist_fold$1(comparator$1, a, init, f);
}

function of_alist_reduce$3(a, f) {
  return of_alist_reduce$1(comparator$1, a, f);
}

function of_sorted_array_unchecked$4(a) {
  return of_sorted_array_unchecked$2(comparator$1, a);
}

function of_sorted_array$4(a) {
  return of_sorted_array$2(comparator$1, a);
}

function of_iteri$4(iteri) {
  return of_iteri$2(comparator$1, iteri);
}

function of_increasing_iterator_unchecked$4(len, f) {
  return of_increasing_iterator_unchecked$2(comparator$1, len, f);
}

function of_increasing_sequence$4(seq) {
  return of_increasing_sequence$2(comparator$1, seq);
}

function of_sequence$3(s) {
  return of_sequence$1(comparator$1, s);
}

function of_sequence_or_error$3(s) {
  return of_sequence_or_error$1(comparator$1, s);
}

function of_sequence_exn$3(s) {
  return of_sequence_exn$1(comparator$1, s);
}

function of_sequence_multi$3(s) {
  return of_sequence_multi$1(comparator$1, s);
}

function of_sequence_fold$3(s, init, f) {
  return of_sequence_fold$1(comparator$1, s, init, f);
}

function of_sequence_reduce$3(s, f) {
  return of_sequence_reduce$1(comparator$1, s, f);
}

var Symmetric_diff_element = Map_intf$negBase.Symmetric_diff_element;

var Poly = {
  empty: empty$3,
  singleton: singleton$3,
  of_alist: of_alist$3,
  of_alist_or_error: of_alist_or_error$3,
  of_alist_exn: of_alist_exn$3,
  of_alist_multi: of_alist_multi$3,
  of_alist_fold: of_alist_fold$3,
  of_alist_reduce: of_alist_reduce$3,
  of_sorted_array: of_sorted_array$4,
  of_sorted_array_unchecked: of_sorted_array_unchecked$4,
  of_increasing_iterator_unchecked: of_increasing_iterator_unchecked$4,
  of_increasing_sequence: of_increasing_sequence$4,
  of_sequence: of_sequence$3,
  of_sequence_or_error: of_sequence_or_error$3,
  of_sequence_exn: of_sequence_exn$3,
  of_sequence_multi: of_sequence_multi$3,
  of_sequence_fold: of_sequence_fold$3,
  of_sequence_reduce: of_sequence_reduce$3,
  of_iteri: of_iteri$4,
  of_tree: of_tree$3,
  invariants: invariants$1,
  is_empty: is_empty$1,
  length: length$1,
  add: add,
  add_exn: add_exn$1,
  set: set$1,
  add_multi: add_multi$1,
  remove_multi: remove_multi$1,
  find_multi: find_multi$1,
  change: change$1,
  update: update$1,
  find: find$1,
  find_exn: find_exn$1,
  remove: remove$1,
  mem: mem$1,
  iter_keys: iter_keys$1,
  iter: iter$1,
  iteri: iteri$1,
  iteri_until: iteri_until,
  iter2: iter2$1,
  map: map$1,
  mapi: mapi$1,
  fold: fold$2,
  fold_right: fold_right$1,
  fold2: fold2$2,
  filter_keys: filter_keys$1,
  filter: filter$1,
  filteri: filteri$1,
  filter_map: filter_map$1,
  filter_mapi: filter_mapi$1,
  partition_mapi: partition_mapi$1,
  partition_map: partition_map$1,
  partitioni_tf: partitioni_tf$1,
  partition_tf: partition_tf$1,
  combine_errors: combine_errors$1,
  compare_direct: compare_direct,
  equal: equal$1,
  keys: keys$1,
  data: data$1,
  to_alist: to_alist$1,
  merge: merge$1,
  symmetric_diff: symmetric_diff$1,
  fold_symmetric_diff: fold_symmetric_diff$1,
  min_elt: min_elt$1,
  min_elt_exn: min_elt_exn$1,
  max_elt: max_elt$1,
  max_elt_exn: max_elt_exn$1,
  for_all: for_all$1,
  for_alli: for_alli$1,
  exists: exists$1,
  existsi: existsi$1,
  count: count$1,
  counti: counti$1,
  split: split$1,
  append: append$1,
  subrange: subrange,
  fold_range_inclusive: fold_range_inclusive$1,
  range_to_alist: range_to_alist$1,
  closest_key: closest_key$1,
  nth: nth,
  nth_exn: nth_exn,
  rank: rank$1,
  to_tree: to_tree$1,
  to_sequence: to_sequence$1,
  binary_search: binary_search$1,
  binary_search_segmented: binary_search_segmented$1,
  binary_search_subrange: binary_search_subrange
};

var Using_comparator_Tree = {
  sexp_of_t: sexp_of_t$2,
  t_of_sexp_direct: t_of_sexp_direct$1,
  empty: empty,
  singleton: singleton,
  of_alist: of_alist,
  of_alist_or_error: of_alist_or_error,
  of_alist_exn: of_alist_exn,
  of_alist_multi: of_alist_multi,
  of_alist_fold: of_alist_fold,
  of_alist_reduce: of_alist_reduce,
  of_sorted_array: of_sorted_array$1,
  of_sorted_array_unchecked: of_sorted_array_unchecked$1,
  of_increasing_iterator_unchecked: of_increasing_iterator_unchecked$1,
  of_increasing_sequence: of_increasing_sequence$1,
  of_sequence: of_sequence,
  of_sequence_or_error: of_sequence_or_error,
  of_sequence_exn: of_sequence_exn,
  of_sequence_multi: of_sequence_multi,
  of_sequence_fold: of_sequence_fold,
  of_sequence_reduce: of_sequence_reduce,
  of_iteri: of_iteri$1,
  of_tree: of_tree$1,
  invariants: invariants$2,
  is_empty: is_empty$2,
  length: length$2,
  add: add$1,
  add_exn: add_exn$2,
  set: set$2,
  add_multi: add_multi$2,
  remove_multi: remove_multi$2,
  find_multi: find_multi$2,
  change: change$2,
  update: update$2,
  find: find$2,
  find_exn: find_exn$2,
  remove: remove$2,
  mem: mem$2,
  iter_keys: iter_keys$2,
  iter: iter$2,
  iteri: iteri$2,
  iteri_until: iteri_until$1,
  iter2: iter2$2,
  map: map$2,
  mapi: mapi$2,
  fold: fold$3,
  fold_right: fold_right$2,
  fold2: fold2$3,
  filter_keys: filter_keys$2,
  filter: filter$2,
  filteri: filteri$2,
  filter_map: filter_map$2,
  filter_mapi: filter_mapi$2,
  partition_mapi: partition_mapi$2,
  partition_map: partition_map$2,
  partitioni_tf: partitioni_tf$2,
  partition_tf: partition_tf$2,
  combine_errors: combine_errors$2,
  compare_direct: compare_direct$1,
  equal: equal$2,
  keys: keys$2,
  data: data$2,
  to_alist: to_alist$2,
  merge: merge$2,
  symmetric_diff: symmetric_diff$2,
  fold_symmetric_diff: fold_symmetric_diff$2,
  min_elt: min_elt$2,
  min_elt_exn: min_elt_exn$2,
  max_elt: max_elt$2,
  max_elt_exn: max_elt_exn$2,
  for_all: for_all$2,
  for_alli: for_alli$2,
  exists: exists$2,
  existsi: existsi$2,
  count: count$2,
  counti: counti$2,
  split: split$2,
  append: append$2,
  subrange: subrange$1,
  fold_range_inclusive: fold_range_inclusive$2,
  range_to_alist: range_to_alist$2,
  closest_key: closest_key$2,
  nth: nth$1,
  nth_exn: nth_exn$1,
  rank: rank$2,
  to_tree: to_tree$2,
  to_sequence: to_sequence$2,
  binary_search: binary_search$2,
  binary_search_segmented: binary_search_segmented$2,
  binary_search_subrange: binary_search_subrange$1,
  empty_without_value_restriction: /* Empty */0
};

var Using_comparator = {
  sexp_of_t: sexp_of_t$1,
  t_of_sexp_direct: t_of_sexp_direct$2,
  Tree: Using_comparator_Tree,
  invariants: invariants$1,
  is_empty: is_empty$1,
  length: length$1,
  add: add,
  add_exn: add_exn$1,
  set: set$1,
  add_multi: add_multi$1,
  remove_multi: remove_multi$1,
  find_multi: find_multi$1,
  change: change$1,
  update: update$1,
  find: find$1,
  find_exn: find_exn$1,
  remove: remove$1,
  mem: mem$1,
  iter_keys: iter_keys$1,
  iter: iter$1,
  iteri: iteri$1,
  iteri_until: iteri_until,
  iter2: iter2$1,
  map: map$1,
  mapi: mapi$1,
  map_keys: map_keys,
  map_keys_exn: map_keys_exn,
  fold: fold$2,
  fold_right: fold_right$1,
  fold2: fold2$2,
  filter_keys: filter_keys$1,
  filter: filter$1,
  filteri: filteri$1,
  filter_map: filter_map$1,
  filter_mapi: filter_mapi$1,
  partition_mapi: partition_mapi$1,
  partition_map: partition_map$1,
  partitioni_tf: partitioni_tf$1,
  partition_tf: partition_tf$1,
  combine_errors: combine_errors$1,
  compare_direct: compare_direct,
  equal: equal$1,
  keys: keys$1,
  data: data$1,
  to_alist: to_alist$1,
  merge: merge$1,
  symmetric_diff: symmetric_diff$1,
  fold_symmetric_diff: fold_symmetric_diff$1,
  min_elt: min_elt$1,
  min_elt_exn: min_elt_exn$1,
  max_elt: max_elt$1,
  max_elt_exn: max_elt_exn$1,
  for_all: for_all$1,
  for_alli: for_alli$1,
  exists: exists$1,
  existsi: existsi$1,
  count: count$1,
  counti: counti$1,
  split: split$1,
  append: append$1,
  subrange: subrange,
  fold_range_inclusive: fold_range_inclusive$1,
  range_to_alist: range_to_alist$1,
  closest_key: closest_key$1,
  nth: nth,
  nth_exn: nth_exn,
  rank: rank$1,
  to_tree: to_tree$1,
  to_sequence: to_sequence$1,
  binary_search: binary_search$1,
  binary_search_segmented: binary_search_segmented$1,
  binary_search_subrange: binary_search_subrange,
  empty: empty$1,
  singleton: singleton$1,
  of_alist: of_alist$1,
  of_alist_or_error: of_alist_or_error$1,
  of_alist_exn: of_alist_exn$1,
  of_alist_multi: of_alist_multi$1,
  of_alist_fold: of_alist_fold$1,
  of_alist_reduce: of_alist_reduce$1,
  of_sorted_array: of_sorted_array$2,
  of_sorted_array_unchecked: of_sorted_array_unchecked$2,
  of_increasing_iterator_unchecked: of_increasing_iterator_unchecked$2,
  of_increasing_sequence: of_increasing_sequence$2,
  of_sequence: of_sequence$1,
  of_sequence_or_error: of_sequence_or_error$1,
  of_sequence_exn: of_sequence_exn$1,
  of_sequence_multi: of_sequence_multi$1,
  of_sequence_fold: of_sequence_fold$1,
  of_sequence_reduce: of_sequence_reduce$1,
  of_iteri: of_iteri$2,
  of_tree: of_tree$2,
  comparator: comparator,
  hash_fold_direct: hash_fold_direct,
  Empty_without_value_restriction: Empty_without_value_restriction
};

exports.Finished_or_unfinished = Finished_or_unfinished;
exports.invariants = invariants$1;
exports.comparator_s = comparator_s;
exports.comparator = comparator;
exports.empty = empty$2;
exports.singleton = singleton$2;
exports.of_alist = of_alist$2;
exports.of_alist_or_error = of_alist_or_error$2;
exports.of_alist_exn = of_alist_exn$2;
exports.of_alist_multi = of_alist_multi$2;
exports.of_alist_fold = of_alist_fold$2;
exports.of_alist_reduce = of_alist_reduce$2;
exports.of_iteri = of_iteri$3;
exports.of_sorted_array = of_sorted_array$3;
exports.of_sorted_array_unchecked = of_sorted_array_unchecked$3;
exports.of_increasing_iterator_unchecked = of_increasing_iterator_unchecked$3;
exports.of_increasing_sequence = of_increasing_sequence$3;
exports.of_sequence = of_sequence$2;
exports.of_sequence_or_error = of_sequence_or_error$2;
exports.of_sequence_exn = of_sequence_exn$2;
exports.of_sequence_multi = of_sequence_multi$2;
exports.of_sequence_fold = of_sequence_fold$2;
exports.of_sequence_reduce = of_sequence_reduce$2;
exports.is_empty = is_empty$1;
exports.length = length$1;
exports.set = set$1;
exports.add = add;
exports.add_exn = add_exn$1;
exports.add_multi = add_multi$1;
exports.remove_multi = remove_multi$1;
exports.find_multi = find_multi$1;
exports.change = change$1;
exports.update = update$1;
exports.find = find$1;
exports.find_exn = find_exn$1;
exports.remove = remove$1;
exports.mem = mem$1;
exports.iter_keys = iter_keys$1;
exports.iter = iter$1;
exports.iteri = iteri$1;
exports.iteri_until = iteri_until;
exports.iter2 = iter2$1;
exports.map = map$1;
exports.mapi = mapi$1;
exports.map_keys = map_keys$1;
exports.map_keys_exn = map_keys_exn$1;
exports.fold = fold$2;
exports.fold_right = fold_right$1;
exports.fold2 = fold2$2;
exports.filter_keys = filter_keys$1;
exports.filter = filter$1;
exports.filteri = filteri$1;
exports.filter_map = filter_map$1;
exports.filter_mapi = filter_mapi$1;
exports.partition_mapi = partition_mapi$1;
exports.partition_map = partition_map$1;
exports.partitioni_tf = partitioni_tf$1;
exports.partition_tf = partition_tf$1;
exports.combine_errors = combine_errors$1;
exports.compare_direct = compare_direct;
exports.hash_fold_direct = hash_fold_direct;
exports.equal = equal$1;
exports.keys = keys$1;
exports.data = data$1;
exports.to_alist = to_alist$1;
exports.merge = merge$1;
exports.merge_skewed = merge_skewed;
exports.Symmetric_diff_element = Symmetric_diff_element;
exports.symmetric_diff = symmetric_diff$1;
exports.fold_symmetric_diff = fold_symmetric_diff$1;
exports.min_elt = min_elt$1;
exports.min_elt_exn = min_elt_exn$1;
exports.max_elt = max_elt$1;
exports.max_elt_exn = max_elt_exn$1;
exports.for_all = for_all$1;
exports.for_alli = for_alli$1;
exports.exists = exists$1;
exports.existsi = existsi$1;
exports.count = count$1;
exports.counti = counti$1;
exports.split = split$1;
exports.append = append$1;
exports.subrange = subrange;
exports.fold_range_inclusive = fold_range_inclusive$1;
exports.range_to_alist = range_to_alist$1;
exports.closest_key = closest_key$1;
exports.nth = nth;
exports.nth_exn = nth_exn;
exports.rank = rank$1;
exports.to_sequence = to_sequence$1;
exports.binary_search = binary_search$1;
exports.binary_search_segmented = binary_search_segmented$1;
exports.binary_search_subrange = binary_search_subrange;
exports.M = M;
exports.sexp_of_m__t = sexp_of_m__t;
exports.m__t_of_sexp = m__t_of_sexp;
exports.m__t_sexp_grammar = m__t_sexp_grammar;
exports.compare_m__t = compare_m__t;
exports.equal_m__t = equal_m__t;
exports.hash_fold_m__t = hash_fold_m__t;
exports.Poly = Poly;
exports.Using_comparator = Using_comparator;
/*  Not a pure module */
