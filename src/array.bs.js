// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Blit$negBase = require("./blit.bs.js");
var Int0$negBase = require("./int0.bs.js");
var List$negBase = require("./list.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Random$negBase = require("./random.bs.js");
var Sequence$negBase = require("./sequence.bs.js");
var Container$negBase = require("./container.bs.js");
var Array_permute$negBase = require("./array_permute.bs.js");
var Binary_searchable$negBase = require("./binary_searchable.bs.js");
var Caml_external_polyfill = require("bs-platform/lib/js/caml_external_polyfill.js");
var Ordered_collection_common$negBase = require("./ordered_collection_common.bs.js");

var t_sexp_grammar = Import$negBase.array_sexp_grammar;

function swap(arr, i, j) {
  var tmp = Caml_array.get(arr, i);
  Caml_array.set(arr, i, Caml_array.get(arr, j));
  return Caml_array.set(arr, j, tmp);
}

function sort(arr, compare, left, right) {
  for(var pos = Import$negBase.$plus(left, 1); pos <= right; ++pos){
    var loop = function (arr, left, compare, _i, v) {
      while(true) {
        var i = _i;
        var i_next = Import$negBase.$neg(i, 1);
        if (!(Import$negBase.$great$eq(i_next, left) && Import$negBase.$great(Curry._2(compare, Caml_array.get(arr, i_next), v), 0))) {
          return i;
        }
        Caml_array.set(arr, i, Caml_array.get(arr, i_next));
        _i = i_next;
        continue ;
      };
    };
    var v = Caml_array.get(arr, pos);
    var final_pos = loop(arr, left, compare, pos, v);
    Caml_array.set(arr, final_pos, v);
  }
  
}

var Insertion_sort = {
  sort: sort
};

function heapify(arr, compare, _root, left, right) {
  while(true) {
    var root = _root;
    var relative_root = Import$negBase.$neg(root, left);
    var left_child = Import$negBase.$plus(Import$negBase.$plus(Import$negBase.$star(2, relative_root), left), 1);
    var right_child = Import$negBase.$plus(Import$negBase.$plus(Import$negBase.$star(2, relative_root), left), 2);
    var largest = Import$negBase.$less$eq(left_child, right) && Import$negBase.$great(Curry._2(compare, Caml_array.get(arr, left_child), Caml_array.get(arr, root)), 0) ? left_child : root;
    var largest$1 = Import$negBase.$less$eq(right_child, right) && Import$negBase.$great(Curry._2(compare, Caml_array.get(arr, right_child), Caml_array.get(arr, largest)), 0) ? right_child : largest;
    if (!Import$negBase.$less$great(largest$1, root)) {
      return ;
    }
    swap(arr, root, largest$1);
    _root = largest$1;
    continue ;
  };
}

function build_heap(arr, compare, left, right) {
  for(var i = Import$negBase.$slash(Import$negBase.$plus(left, right), 2); i >= left; --i){
    heapify(arr, compare, i, left, right);
  }
  
}

function sort$1(arr, compare, left, right) {
  build_heap(arr, compare, left, right);
  for(var i = right ,i_finish = Import$negBase.$plus(left, 1); i >= i_finish; --i){
    swap(arr, left, i);
    heapify(arr, compare, left, left, Import$negBase.$neg(i, 1));
  }
  
}

var Heap_sort = {
  sort: sort$1
};

function five_element_sort(arr, compare, m1, m2, m3, m4, m5) {
  var compare_and_swap = function (i, j) {
    if (Import$negBase.$great(Curry._2(compare, Caml_array.get(arr, i), Caml_array.get(arr, j)), 0)) {
      return swap(arr, i, j);
    }
    
  };
  compare_and_swap(m1, m2);
  compare_and_swap(m4, m5);
  compare_and_swap(m1, m3);
  compare_and_swap(m2, m3);
  compare_and_swap(m1, m4);
  compare_and_swap(m3, m4);
  compare_and_swap(m2, m5);
  compare_and_swap(m2, m3);
  return compare_and_swap(m4, m5);
}

function choose_pivots(arr, compare, left, right) {
  var sixth = Import$negBase.$slash(Import$negBase.$neg(right, left), 6);
  var m1 = Import$negBase.$plus(left, sixth);
  var m2 = Import$negBase.$plus(m1, sixth);
  var m3 = Import$negBase.$plus(m2, sixth);
  var m4 = Import$negBase.$plus(m3, sixth);
  var m5 = Import$negBase.$plus(m4, sixth);
  five_element_sort(arr, compare, m1, m2, m3, m4, m5);
  var m2_val = Caml_array.get(arr, m2);
  var m3_val = Caml_array.get(arr, m3);
  var m4_val = Caml_array.get(arr, m4);
  if (Curry._2(compare, m2_val, m3_val) === 0) {
    return [
            m2_val,
            m3_val,
            true
          ];
  } else if (Curry._2(compare, m3_val, m4_val) === 0) {
    return [
            m3_val,
            m4_val,
            true
          ];
  } else {
    return [
            m2_val,
            m4_val,
            false
          ];
  }
}

function dual_pivot_partition(arr, compare, left, right) {
  var match = choose_pivots(arr, compare, left, right);
  var pivot2 = match[1];
  var pivot1 = match[0];
  var cont = function (l, p, r) {
    if (Import$negBase.$great(p, r)) {
      return [
              l,
              r
            ];
    } else {
      var pv = Caml_array.get(arr, p);
      if (Import$negBase.$less(Curry._2(compare, pv, pivot1), 0)) {
        swap(arr, p, l);
        return cont(Import$negBase.$plus(l, 1), Import$negBase.$plus(p, 1), r);
      }
      if (!Import$negBase.$great(Curry._2(compare, pv, pivot2), 0)) {
        return cont(l, Import$negBase.$plus(p, 1), r);
      }
      var scan_backwards = function (_r) {
        while(true) {
          var r = _r;
          if (!(Import$negBase.$great(r, p) && Import$negBase.$great(Curry._2(compare, Caml_array.get(arr, r), pivot2), 0))) {
            return r;
          }
          _r = Import$negBase.$neg(r, 1);
          continue ;
        };
      };
      var r$1 = scan_backwards(r);
      swap(arr, r$1, p);
      return cont(l, p, Import$negBase.$neg(r$1, 1));
    }
  };
  var match$1 = cont(left, left, right);
  return [
          match$1[0],
          match$1[1],
          match[2]
        ];
}

function intro_sort(arr, _max_depth, compare, _left, right) {
  while(true) {
    var left = _left;
    var max_depth = _max_depth;
    var len = Import$negBase.$plus(Import$negBase.$neg(right, left), 1);
    if (Import$negBase.$less$eq(len, 32)) {
      return sort(arr, compare, left, right);
    }
    if (Import$negBase.$less(max_depth, 0)) {
      return sort$1(arr, compare, left, right);
    }
    var max_depth$1 = Import$negBase.$neg(max_depth, 1);
    var match = dual_pivot_partition(arr, compare, left, right);
    var r = match[1];
    var l = match[0];
    intro_sort(arr, max_depth$1, compare, left, Import$negBase.$neg(l, 1));
    if (!match[2]) {
      intro_sort(arr, max_depth$1, compare, l, r);
    }
    _left = Import$negBase.$plus(r, 1);
    _max_depth = max_depth$1;
    continue ;
  };
}

var log10_of_3 = Caml_external_polyfill.resolve("caml_log10_float")(3);

function sort$2(arr, compare, left, right) {
  var len = Import$negBase.$plus(Import$negBase.$neg(right, left), 1);
  var x = Int0$negBase.to_float(len);
  var heap_sort_switch_depth = Int0$negBase.of_float(Import$negBase.$slash$dot(Caml_external_polyfill.resolve("caml_log10_float")(x), log10_of_3));
  return intro_sort(arr, heap_sort_switch_depth, compare, left, right);
}

var Intro_sort = {
  sort: sort$2,
  five_element_sort: five_element_sort
};

function sort$3(pos, len, arr, compare) {
  var match = Ordered_collection_common$negBase.get_pos_len_exn(pos, len, undefined, arr.length);
  var pos$1 = match[0];
  return sort$2(arr, compare, pos$1, Import$negBase.$neg(Import$negBase.$plus(pos$1, match[1]), 1));
}

function to_array(t) {
  return t;
}

function is_empty(t) {
  return t.length === 0;
}

function is_sorted(t, compare) {
  var i = {
    contents: Import$negBase.$neg(t.length, 1)
  };
  var result = true;
  while(Import$negBase.$great(i[0], 0) && result) {
    var elt_i = t[i[0]];
    var elt_i_minus_1 = t[Import$negBase.$neg(i[0], 1)];
    if (Import$negBase.$great(Curry._2(compare, elt_i_minus_1, elt_i), 0)) {
      result = false;
    }
    Import$negBase.decr(i);
  };
  return result;
}

function is_sorted_strictly(t, compare) {
  var i = {
    contents: Import$negBase.$neg(t.length, 1)
  };
  var result = true;
  while(Import$negBase.$great(i[0], 0) && result) {
    var elt_i = t[i[0]];
    var elt_i_minus_1 = t[Import$negBase.$neg(i[0], 1)];
    if (Import$negBase.$great$eq(Curry._2(compare, elt_i_minus_1, elt_i), 0)) {
      result = false;
    }
    Import$negBase.decr(i);
  };
  return result;
}

function merge(a1, a2, compare) {
  var l1 = a1.length;
  var l2 = a2.length;
  if (l1 === 0) {
    return Array0$negBase.copy(a2);
  }
  if (l2 === 0) {
    return Array0$negBase.copy(a1);
  }
  if (Import$negBase.$great$eq(Curry._2(compare, a2[0], a1[Import$negBase.$neg(l1, 1)]), 0)) {
    return Array0$negBase.append(a1, a2);
  }
  if (Import$negBase.$great(Curry._2(compare, a1[0], a2[Import$negBase.$neg(l2, 1)]), 0)) {
    return Array0$negBase.append(a2, a1);
  }
  var len = Import$negBase.$plus(l1, l2);
  var merged = Array0$negBase.create(len, a1[0]);
  var a1_index = 0;
  var a2_index = 0;
  for(var i = 0 ,i_finish = Import$negBase.$neg(len, 1); i <= i_finish; ++i){
    var use_a1 = l1 === a1_index ? false : (
        l2 === a2_index ? true : Import$negBase.$less$eq(Curry._2(compare, a1[a1_index], a2[a2_index]), 0)
      );
    if (use_a1) {
      merged[i] = a1[a1_index];
      a1_index = Import$negBase.$plus(a1_index, 1);
    } else {
      merged[i] = a2[a2_index];
      a2_index = Import$negBase.$plus(a2_index, 1);
    }
  }
  return merged;
}

function folding_map(t, init, f) {
  var acc = {
    contents: init
  };
  return Array0$negBase.map(t, (function (x) {
                var match = Curry._2(f, acc[0], x);
                acc[0] = match[0];
                return match[1];
              }));
}

function fold_map(t, init, f) {
  var acc = {
    contents: init
  };
  var result = Array0$negBase.map(t, (function (x) {
          var match = Curry._2(f, acc[0], x);
          acc[0] = match[0];
          return match[1];
        }));
  return [
          acc[0],
          result
        ];
}

function fold_result(t, init, f) {
  return Container$negBase.fold_result(Array0$negBase.fold, init, f, t);
}

function fold_until(t, init, f) {
  return function (param) {
    return Container$negBase.fold_until(Array0$negBase.fold, init, f, param, t);
  };
}

function count(t, f) {
  return Container$negBase.count(Array0$negBase.fold, t, f);
}

function sum(m, t, f) {
  return Container$negBase.sum(Array0$negBase.fold, m, t, f);
}

function min_elt(t, compare) {
  return Container$negBase.min_elt(Array0$negBase.fold, t, compare);
}

function max_elt(t, compare) {
  return Container$negBase.max_elt(Array0$negBase.fold, t, compare);
}

function foldi(t, init, f) {
  var acc = init;
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    acc = Curry._3(f, i, acc, t[i]);
  }
  return acc;
}

function folding_mapi(t, init, f) {
  var acc = {
    contents: init
  };
  return Array0$negBase.mapi(t, (function (i, x) {
                var match = Curry._3(f, i, acc[0], x);
                acc[0] = match[0];
                return match[1];
              }));
}

function fold_mapi(t, init, f) {
  var acc = {
    contents: init
  };
  var result = Array0$negBase.mapi(t, (function (i, x) {
          var match = Curry._3(f, i, acc[0], x);
          acc[0] = match[0];
          return match[1];
        }));
  return [
          acc[0],
          result
        ];
}

function counti(t, f) {
  return foldi(t, 0, (function (idx, count, a) {
                if (Curry._2(f, idx, a)) {
                  return Import$negBase.$plus(count, 1);
                } else {
                  return count;
                }
              }));
}

function concat_map(t, f) {
  return Array0$negBase.concat(Array0$negBase.to_list(Array0$negBase.map(t, f)));
}

function concat_mapi(t, f) {
  return Array0$negBase.concat(Array0$negBase.to_list(Array0$negBase.mapi(t, f)));
}

function rev_inplace(t) {
  var i = {
    contents: 0
  };
  var j = {
    contents: Import$negBase.$neg(t.length, 1)
  };
  while(Import$negBase.$less(i[0], j[0])) {
    Array0$negBase.swap(t, i[0], j[0]);
    Import$negBase.incr(i);
    Import$negBase.decr(j);
  };
  
}

function of_list_rev(l) {
  if (!l) {
    return [];
  }
  var l$1 = l.tl;
  var len = Import$negBase.$plus(1, List$negBase.length(l$1));
  var t = Array0$negBase.create(len, l.hd);
  var r = l$1;
  for(var i = Import$negBase.$neg(len, 2); i >= 0; --i){
    var match = r;
    if (match) {
      Caml_array.set(t, i, match.hd);
      r = match.tl;
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "array.ml",
              426,
              14
            ],
            Error: new Error()
          };
    }
  }
  return t;
}

function of_list_map(xs, f) {
  if (!xs) {
    return [];
  }
  var tl = xs.tl;
  var a = Array0$negBase.create(Import$negBase.$plus(1, List$negBase.length(tl)), Curry._1(f, xs.hd));
  var _i = 1;
  var _param = tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    a[i] = Curry._1(f, param.hd);
    _param = param.tl;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function of_list_mapi(xs, f) {
  if (!xs) {
    return [];
  }
  var tl = xs.tl;
  var a = Array0$negBase.create(Import$negBase.$plus(1, List$negBase.length(tl)), Curry._2(f, 0, xs.hd));
  var _i = 1;
  var _param = tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    a[i] = Curry._2(f, i, param.hd);
    _param = param.tl;
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

function of_list_rev_map(xs, f) {
  var t = of_list_map(xs, f);
  rev_inplace(t);
  return t;
}

function of_list_rev_mapi(xs, f) {
  var t = of_list_mapi(xs, f);
  rev_inplace(t);
  return t;
}

function filter_mapi(t, f) {
  var r = [];
  var k = {
    contents: 0
  };
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    var a = Curry._2(f, i, t[i]);
    if (a !== undefined) {
      var a$1 = Caml_option.valFromOption(a);
      if (k[0] === 0) {
        r = Array0$negBase.create(t.length, a$1);
      }
      r[k[0]] = a$1;
      Import$negBase.incr(k);
    }
    
  }
  if (k[0] === t.length) {
    return r;
  } else if (Import$negBase.$great(k[0], 0)) {
    return Array0$negBase.sub(r, 0, k[0]);
  } else {
    return [];
  }
}

function filter_map(t, f) {
  return filter_mapi(t, (function (_i, a) {
                return Curry._1(f, a);
              }));
}

function filter_opt(t) {
  return filter_mapi(t, (function (_i, a) {
                return a;
              }));
}

function check_length2_exn(name, t1, t2) {
  var n1 = t1.length;
  var n2 = t2.length;
  if (Import$negBase.$less$great(n1, n2)) {
    return Curry._4(Array0$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "length mismatch in ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: " <> ",
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "length mismatch in %s: %d <> %d"
                  }), name, n1, n2, undefined);
  }
  
}

function iter2_exn(t1, t2, f) {
  check_length2_exn("Array.iter2_exn", t1, t2);
  return Array0$negBase.iteri(t1, (function (i, x1) {
                return Curry._2(f, x1, t2[i]);
              }));
}

function map2_exn(t1, t2, f) {
  check_length2_exn("Array.map2_exn", t1, t2);
  return Array0$negBase.init(t1.length, (function (i) {
                return Curry._2(f, t1[i], t2[i]);
              }));
}

function fold2_exn(t1, t2, init, f) {
  check_length2_exn("Array.fold2_exn", t1, t2);
  return foldi(t1, init, (function (i, ac, x) {
                return Curry._3(f, ac, x, t2[i]);
              }));
}

function filter(t, f) {
  return filter_mapi(t, (function (_i, a) {
                if (Curry._1(f, a)) {
                  return Caml_option.some(a);
                }
                
              }));
}

function filteri(t, f) {
  return filter_mapi(t, (function (i, x) {
                if (Curry._2(f, i, x)) {
                  return Caml_option.some(x);
                }
                
              }));
}

function exists(t, f) {
  var i = {
    contents: Import$negBase.$neg(t.length, 1)
  };
  var result = false;
  while(Import$negBase.$great$eq(i[0], 0) && !result) {
    if (Curry._1(f, t[i[0]])) {
      result = true;
    } else {
      Import$negBase.decr(i);
    }
  };
  return result;
}

function existsi(t, f) {
  var i = {
    contents: Import$negBase.$neg(t.length, 1)
  };
  var result = false;
  while(Import$negBase.$great$eq(i[0], 0) && !result) {
    if (Curry._2(f, i[0], t[i[0]])) {
      result = true;
    } else {
      Import$negBase.decr(i);
    }
  };
  return result;
}

function mem(t, a, equal) {
  return exists(t, Curry._1(equal, a));
}

function for_all(t, f) {
  var i = {
    contents: Import$negBase.$neg(t.length, 1)
  };
  var result = true;
  while(Import$negBase.$great$eq(i[0], 0) && result) {
    if (Curry._1(f, t[i[0]])) {
      Import$negBase.decr(i);
    } else {
      result = false;
    }
  };
  return result;
}

function for_alli(t, f) {
  var length = t.length;
  var i = {
    contents: Import$negBase.$neg(length, 1)
  };
  var result = true;
  while(Import$negBase.$great$eq(i[0], 0) && result) {
    if (Curry._2(f, i[0], t[i[0]])) {
      Import$negBase.decr(i);
    } else {
      result = false;
    }
  };
  return result;
}

function exists2_exn(t1, t2, f) {
  check_length2_exn("Array.exists2_exn", t1, t2);
  var i = {
    contents: Import$negBase.$neg(t1.length, 1)
  };
  var result = false;
  while(Import$negBase.$great$eq(i[0], 0) && !result) {
    if (Curry._2(f, t1[i[0]], t2[i[0]])) {
      result = true;
    } else {
      Import$negBase.decr(i);
    }
  };
  return result;
}

function for_all2_exn(t1, t2, f) {
  check_length2_exn("Array.for_all2_exn", t1, t2);
  var i = {
    contents: Import$negBase.$neg(t1.length, 1)
  };
  var result = true;
  while(Import$negBase.$great$eq(i[0], 0) && result) {
    if (Curry._2(f, t1[i[0]], t2[i[0]])) {
      Import$negBase.decr(i);
    } else {
      result = false;
    }
  };
  return result;
}

function equal(equal$1, t1, t2) {
  if (t1.length === t2.length) {
    return for_all2_exn(t1, t2, equal$1);
  } else {
    return false;
  }
}

function map_inplace(t, f) {
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    t[i] = Curry._1(f, t[i]);
  }
  
}

function findi(t, f) {
  var length = t.length;
  if (length === 0) {
    return ;
  }
  var i = {
    contents: 0
  };
  var found = false;
  var value_found = t[0];
  while(!found && Import$negBase.$less(i[0], length)) {
    var value = t[i[0]];
    if (Curry._2(f, i[0], value)) {
      value_found = value;
      found = true;
    } else {
      Import$negBase.incr(i);
    }
  };
  if (found) {
    return [
            i[0],
            value_found
          ];
  }
  
}

function findi_exn(t, f) {
  var length = t.length;
  if (length === 0) {
    throw {
          RE_EXN_ID: Import$negBase.Not_found_s,
          _1: {
            TAG: /* Atom */0,
            _0: "Array.findi_exn: not found"
          },
          Error: new Error()
        };
  }
  var i = {
    contents: 0
  };
  var found = false;
  var value_found = t[0];
  while(!found && Import$negBase.$less(i[0], length)) {
    var value = t[i[0]];
    if (Curry._2(f, i[0], value)) {
      value_found = value;
      found = true;
    } else {
      Import$negBase.incr(i);
    }
  };
  if (found) {
    return [
            i[0],
            value_found
          ];
  }
  throw {
        RE_EXN_ID: Import$negBase.Not_found_s,
        _1: {
          TAG: /* Atom */0,
          _0: "Array.findi_exn: not found"
        },
        Error: new Error()
      };
}

function find_exn(t, f) {
  var length = t.length;
  if (length === 0) {
    throw {
          RE_EXN_ID: Import$negBase.Not_found_s,
          _1: {
            TAG: /* Atom */0,
            _0: "Array.find_exn: not found"
          },
          Error: new Error()
        };
  }
  var i = {
    contents: 0
  };
  var found = false;
  var value_found = t[0];
  while(!found && Import$negBase.$less(i[0], length)) {
    var value = t[i[0]];
    if (Curry._1(f, value)) {
      value_found = value;
      found = true;
    } else {
      Import$negBase.incr(i);
    }
  };
  if (found) {
    return value_found;
  }
  throw {
        RE_EXN_ID: Import$negBase.Not_found_s,
        _1: {
          TAG: /* Atom */0,
          _0: "Array.find_exn: not found"
        },
        Error: new Error()
      };
}

function find(t, f) {
  return Curry._2(Option$negBase.map, findi(t, (function (_i, x) {
                    return Curry._1(f, x);
                  })), (function (param) {
                return param[1];
              }));
}

function find_map(t, f) {
  var length = t.length;
  if (length === 0) {
    return ;
  }
  var i = {
    contents: 0
  };
  var value_found;
  while(Option$negBase.is_none(value_found) && Import$negBase.$less(i[0], length)) {
    var value = t[i[0]];
    value_found = Curry._1(f, value);
    Import$negBase.incr(i);
  };
  return value_found;
}

var not_found_1 = {
  TAG: /* Atom */0,
  _0: "Array.find_map_exn: not found"
};

var not_found = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1
};

function find_map_exn(t, f) {
  var x = find_map(t, f);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw not_found;
}

function find_mapi(t, f) {
  var length = t.length;
  if (length === 0) {
    return ;
  }
  var i = {
    contents: 0
  };
  var value_found;
  while(Option$negBase.is_none(value_found) && Import$negBase.$less(i[0], length)) {
    var value = t[i[0]];
    value_found = Curry._2(f, i[0], value);
    Import$negBase.incr(i);
  };
  return value_found;
}

var not_found_1$1 = {
  TAG: /* Atom */0,
  _0: "Array.find_mapi_exn: not found"
};

var not_found$1 = {
  RE_EXN_ID: Import$negBase.Not_found_s,
  _1: not_found_1$1
};

function find_mapi_exn(t, f) {
  var x = find_mapi(t, f);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw not_found$1;
}

function find_consecutive_duplicate(t, equal) {
  var n = t.length;
  if (Import$negBase.$less$eq(n, 1)) {
    return ;
  }
  var result;
  var i = {
    contents: 1
  };
  var prev = t[0];
  while(Import$negBase.$less(i[0], n)) {
    var cur = t[i[0]];
    if (Curry._2(equal, cur, prev)) {
      result = [
        prev,
        cur
      ];
      i[0] = n;
    } else {
      prev = cur;
      Import$negBase.incr(i);
    }
  };
  return result;
}

function reduce(t, f) {
  if (t.length === 0) {
    return ;
  }
  var r = t[0];
  for(var i = 1 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    r = Curry._2(f, r, t[i]);
  }
  return Caml_option.some(r);
}

function reduce_exn(t, f) {
  var v = reduce(t, f);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  } else {
    return Import$negBase.invalid_arg("Array.reduce_exn");
  }
}

function random_element_exn(random_stateOpt, t) {
  var random_state = random_stateOpt !== undefined ? Caml_option.valFromOption(random_stateOpt) : Random$negBase.State.$$default;
  if (t.length === 0) {
    return Import$negBase.failwith("Array.random_element_exn: empty array");
  } else {
    return Caml_array.get(t, Curry._2(Random$negBase.State.$$int, random_state, t.length));
  }
}

function random_element(random_stateOpt, t) {
  var random_state = random_stateOpt !== undefined ? Caml_option.valFromOption(random_stateOpt) : Random$negBase.State.$$default;
  try {
    return Caml_option.some(random_element_exn(Caml_option.some(random_state), t));
  }
  catch (exn){
    return ;
  }
}

function zip(t1, t2) {
  if (Import$negBase.$less$great(t1.length, t2.length)) {
    return ;
  } else {
    return map2_exn(t1, t2, (function (x1, x2) {
                  return [
                          x1,
                          x2
                        ];
                }));
  }
}

function zip_exn(t1, t2) {
  if (Import$negBase.$less$great(t1.length, t2.length)) {
    return Import$negBase.failwith("Array.zip_exn");
  } else {
    return map2_exn(t1, t2, (function (x1, x2) {
                  return [
                          x1,
                          x2
                        ];
                }));
  }
}

function unzip(t) {
  var n = t.length;
  if (n === 0) {
    return [
            [],
            []
          ];
  }
  var match = Caml_array.get(t, 0);
  var res1 = Array0$negBase.create(n, match[0]);
  var res2 = Array0$negBase.create(n, match[1]);
  for(var i = 1 ,i_finish = Import$negBase.$neg(n, 1); i <= i_finish; ++i){
    var match$1 = Caml_array.get(t, i);
    Caml_array.set(res1, i, match$1[0]);
    Caml_array.set(res2, i, match$1[1]);
  }
  return [
          res1,
          res2
        ];
}

function sorted_copy(t, compare) {
  var t1 = Array0$negBase.copy(t);
  sort$3(undefined, undefined, t1, compare);
  return t1;
}

function partitioni_tf(t, f) {
  var both = Array0$negBase.mapi(t, (function (i, x) {
          if (Curry._2(f, i, x)) {
            return {
                    TAG: /* First */0,
                    _0: x
                  };
          } else {
            return {
                    TAG: /* Second */1,
                    _0: x
                  };
          }
        }));
  var trues = filter_mapi(both, (function (_i, a) {
          if (a.TAG === /* First */0) {
            return Caml_option.some(a._0);
          }
          
        }));
  var falses = filter_mapi(both, (function (_i, a) {
          if (a.TAG === /* First */0) {
            return ;
          } else {
            return Caml_option.some(a._0);
          }
        }));
  return [
          trues,
          falses
        ];
}

function partition_tf(t, f) {
  return partitioni_tf(t, (function (_i, x) {
                return Curry._1(f, x);
              }));
}

function last(t) {
  return Caml_array.get(t, Import$negBase.$neg(t.length, 1));
}

function to_sequence_mutable(t) {
  return Sequence$negBase.unfold_step(0, (function (i) {
                if (Import$negBase.$great$eq(i, t.length)) {
                  return /* Done */0;
                } else {
                  return {
                          TAG: /* Yield */1,
                          _0: Caml_array.get(t, i),
                          _1: Import$negBase.$plus(i, 1)
                        };
                }
              }));
}

function to_sequence(t) {
  return to_sequence_mutable(Array0$negBase.copy(t));
}

function cartesian_product(t1, t2) {
  if (t1.length === 0 || t2.length === 0) {
    return [];
  }
  var n1 = t1.length;
  var n2 = t2.length;
  var t = Array0$negBase.create(Import$negBase.$star(n1, n2), [
        Caml_array.get(t1, 0),
        Caml_array.get(t2, 0)
      ]);
  var r = {
    contents: 0
  };
  for(var i1 = 0 ,i1_finish = Import$negBase.$neg(n1, 1); i1 <= i1_finish; ++i1){
    for(var i2 = 0 ,i2_finish = Import$negBase.$neg(n2, 1); i2 <= i2_finish; ++i2){
      Caml_array.set(t, r[0], [
            Caml_array.get(t1, i1),
            Caml_array.get(t2, i2)
          ]);
      Import$negBase.incr(r);
    }
  }
  return t;
}

function transpose(tt) {
  if (tt.length === 0) {
    return [];
  }
  var width = tt.length;
  var depth = Caml_array.get(tt, 0).length;
  if (exists(tt, (function (t) {
            return Import$negBase.$less$great(t.length, depth);
          }))) {
    return ;
  } else {
    return Array0$negBase.init(depth, (function (d) {
                  return Array0$negBase.init(width, (function (w) {
                                return Caml_array.get(Caml_array.get(tt, w), d);
                              }));
                }));
  }
}

function transpose_exn(tt) {
  var tt$p = transpose(tt);
  if (tt$p !== undefined) {
    return tt$p;
  } else {
    return Import$negBase.invalid_arg("Array.transpose_exn");
  }
}

var get = Caml_array.get;

function length(prim) {
  return prim.length;
}

var include = Binary_searchable$negBase.Make1({
      get: get,
      length: length
    });

function length$1(prim) {
  return prim.length;
}

function create_like(len, t) {
  if (len === 0) {
    return [];
  }
  if (!Import$negBase.$great(t.length, 0)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "array.ml",
            849,
            8
          ],
          Error: new Error()
        };
  }
  return Array0$negBase.create(len, Caml_array.get(t, 0));
}

var include$1 = Blit$negBase.Make1({
      create_like: create_like,
      length: length$1,
      unsafe_blit: Array0$negBase.blit
    });

function invariant(invariant_a, t) {
  return Array0$negBase.iter(t, invariant_a);
}

var compare = Import$negBase.compare_array;

var t_of_sexp = Import$negBase.array_of_sexp;

var sexp_of_t = Import$negBase.sexp_of_array;

var binary_search = include.binary_search;

var binary_search_segmented = include.binary_search_segmented;

function length$2(prim) {
  return prim.length;
}

var iter = Array0$negBase.iter;

var fold = Array0$negBase.fold;

var to_list = Array0$negBase.to_list;

var max_length = Array0$negBase.max_length;

var create = Array0$negBase.create;

var init = Array0$negBase.init;

var make_matrix = Array0$negBase.make_matrix;

var append = Array0$negBase.append;

var concat = Array0$negBase.concat;

var copy = Array0$negBase.copy;

var fill = Array0$negBase.fill;

var blit = include$1.blit;

var blito = include$1.blito;

var unsafe_blit = include$1.unsafe_blit;

var sub = include$1.sub;

var subo = include$1.subo;

var of_list = Array0$negBase.of_list;

var map = Array0$negBase.map;

var iteri = Array0$negBase.iteri;

var mapi = Array0$negBase.mapi;

var fold_right = Array0$negBase.fold_right;

var stable_sort = Array0$negBase.stable_sort;

var swap$1 = Array0$negBase.swap;

var permute = Array_permute$negBase.permute;

var Private = {
  Sort: {
    Insertion_sort: Insertion_sort,
    Heap_sort: Heap_sort,
    Intro_sort: Intro_sort
  }
};

exports.compare = compare;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.binary_search = binary_search;
exports.binary_search_segmented = binary_search_segmented;
exports.mem = mem;
exports.length = length$2;
exports.is_empty = is_empty;
exports.iter = iter;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.count = count;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.invariant = invariant;
exports.max_length = max_length;
exports.create = create;
exports.init = init;
exports.make_matrix = make_matrix;
exports.append = append;
exports.concat = concat;
exports.copy = copy;
exports.fill = fill;
exports.blit = blit;
exports.blito = blito;
exports.unsafe_blit = unsafe_blit;
exports.sub = sub;
exports.subo = subo;
exports.of_list = of_list;
exports.map = map;
exports.folding_map = folding_map;
exports.folding_mapi = folding_mapi;
exports.fold_map = fold_map;
exports.fold_mapi = fold_mapi;
exports.iteri = iteri;
exports.mapi = mapi;
exports.foldi = foldi;
exports.fold_right = fold_right;
exports.sort = sort$3;
exports.stable_sort = stable_sort;
exports.is_sorted = is_sorted;
exports.is_sorted_strictly = is_sorted_strictly;
exports.merge = merge;
exports.concat_map = concat_map;
exports.concat_mapi = concat_mapi;
exports.partition_tf = partition_tf;
exports.partitioni_tf = partitioni_tf;
exports.cartesian_product = cartesian_product;
exports.transpose = transpose;
exports.transpose_exn = transpose_exn;
exports.filter_opt = filter_opt;
exports.filter_map = filter_map;
exports.filter_mapi = filter_mapi;
exports.for_alli = for_alli;
exports.existsi = existsi;
exports.counti = counti;
exports.iter2_exn = iter2_exn;
exports.map2_exn = map2_exn;
exports.fold2_exn = fold2_exn;
exports.for_all2_exn = for_all2_exn;
exports.exists2_exn = exists2_exn;
exports.filter = filter;
exports.filteri = filteri;
exports.swap = swap$1;
exports.rev_inplace = rev_inplace;
exports.of_list_rev = of_list_rev;
exports.of_list_map = of_list_map;
exports.of_list_mapi = of_list_mapi;
exports.of_list_rev_map = of_list_rev_map;
exports.of_list_rev_mapi = of_list_rev_mapi;
exports.map_inplace = map_inplace;
exports.find_exn = find_exn;
exports.find_map_exn = find_map_exn;
exports.findi = findi;
exports.findi_exn = findi_exn;
exports.find_mapi = find_mapi;
exports.find_mapi_exn = find_mapi_exn;
exports.find_consecutive_duplicate = find_consecutive_duplicate;
exports.reduce = reduce;
exports.reduce_exn = reduce_exn;
exports.permute = permute;
exports.random_element = random_element;
exports.random_element_exn = random_element_exn;
exports.zip = zip;
exports.zip_exn = zip_exn;
exports.unzip = unzip;
exports.sorted_copy = sorted_copy;
exports.last = last;
exports.equal = equal;
exports.to_sequence = to_sequence;
exports.to_sequence_mutable = to_sequence_mutable;
exports.Private = Private;
/* log10_of_3 Not a pure module */
