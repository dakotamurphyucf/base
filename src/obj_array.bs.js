// Generated by Melange
'use strict';

var Obj = require("bs-platform/lib/js/obj.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Blit$negBase = require("./blit.bs.js");
var Int0$negBase = require("./int0.bs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Array0$negBase = require("./array0.bs.js");
var Import$negBase = require("./import.bs.js");
var String0$negBase = require("./string0.bs.js");

function invariant(t) {
  if (Import$negBase.$less$great(t.TAG | 0, Obj.double_array_tag)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "obj_array.ml",
          11,
          18
        ],
        Error: new Error()
      };
}

function length(prim) {
  return prim.length;
}

var swap = Array0$negBase.swap;

function sexp_of_t(t) {
  return {
          TAG: /* Atom */0,
          _0: String0$negBase.concat("", {
                hd: "<Obj_array.t of length ",
                tl: {
                  hd: Int0$negBase.to_string(t.length),
                  tl: {
                    hd: ">",
                    tl: /* [] */0
                  }
                }
              })
        };
}

function create_zero(len) {
  return Array0$negBase.create(len, 0);
}

function create(len, x) {
  if (Import$negBase.$less$great(x.TAG | 0, Obj.double_tag)) {
    return Array0$negBase.create(len, x);
  }
  var t = create_zero(len);
  for(var i = 0 ,i_finish = Import$negBase.$neg(len, 1); i <= i_finish; ++i){
    t[i] = x;
  }
  return t;
}

var empty = [];

var get = Caml_array.get;

function unsafe_get(t, i) {
  return t[i];
}

function unsafe_set_with_caml_modify(t, i, obj) {
  t[i] = obj;
  
}

function unsafe_set_int_assuming_currently_int(t, i, $$int) {
  t[i] = $$int;
  
}

function set(t, i, obj) {
  var old_obj = Caml_array.get(t, i);
  if (typeof old_obj === "number" && typeof obj === "number" || !Import$negBase.phys_equal(old_obj, obj)) {
    t[i] = obj;
    return ;
  }
  
}

function unsafe_set(t, i, obj) {
  var old_obj = t[i];
  if (typeof old_obj === "number" && typeof obj === "number" || !Import$negBase.phys_equal(old_obj, obj)) {
    t[i] = obj;
    return ;
  }
  
}

function unsafe_set_omit_phys_equal_check(t, i, obj) {
  t[i] = obj;
  
}

function singleton(obj) {
  return create(1, obj);
}

function unsafe_set_assuming_currently_int(t, i, obj) {
  t[i] = obj;
  
}

function unsafe_set_int(t, i, $$int) {
  t[i] = $$int;
  
}

function unsafe_clear_if_pointer(t, i) {
  var old_obj = t[i];
  if (typeof old_obj !== "number") {
    t[i] = 0;
    return ;
  }
  
}

function unsafe_blit(src, src_pos, dst, dst_pos, len) {
  if (Import$negBase.$less(dst_pos, src_pos)) {
    for(var i = 0 ,i_finish = Import$negBase.$neg(len, 1); i <= i_finish; ++i){
      var obj = src[Import$negBase.$plus(src_pos, i)];
      var i$1 = Import$negBase.$plus(dst_pos, i);
      var old_obj = dst[i$1];
      if (typeof old_obj === "number" && typeof obj === "number" || !Import$negBase.phys_equal(old_obj, obj)) {
        dst[i$1] = obj;
      }
      
    }
    return ;
  }
  for(var i$2 = Import$negBase.$neg(len, 1); i$2 >= 0; --i$2){
    var obj$1 = src[Import$negBase.$plus(src_pos, i$2)];
    var i$3 = Import$negBase.$plus(dst_pos, i$2);
    var old_obj$1 = dst[i$3];
    if (typeof old_obj$1 === "number" && typeof obj$1 === "number" || !Import$negBase.phys_equal(old_obj$1, obj$1)) {
      dst[i$3] = obj$1;
    }
    
  }
  
}

var include = Blit$negBase.Make({
      length: length,
      create: create_zero,
      unsafe_blit: unsafe_blit
    });

var blito = include.blito;

function copy(src) {
  var dst = create_zero(src.length);
  Curry._6(blito, src, undefined, undefined, dst, undefined, undefined);
  return dst;
}

var blit = include.blit;

var unsafe_blit$1 = include.unsafe_blit;

var sub = include.sub;

var subo = include.subo;

exports.sexp_of_t = sexp_of_t;
exports.blit = blit;
exports.blito = blito;
exports.unsafe_blit = unsafe_blit$1;
exports.sub = sub;
exports.subo = subo;
exports.invariant = invariant;
exports.create = create;
exports.create_zero = create_zero;
exports.copy = copy;
exports.singleton = singleton;
exports.empty = empty;
exports.length = length;
exports.get = get;
exports.unsafe_get = unsafe_get;
exports.set = set;
exports.unsafe_set = unsafe_set;
exports.swap = swap;
exports.unsafe_set_assuming_currently_int = unsafe_set_assuming_currently_int;
exports.unsafe_set_int_assuming_currently_int = unsafe_set_int_assuming_currently_int;
exports.unsafe_set_int = unsafe_set_int;
exports.unsafe_set_omit_phys_equal_check = unsafe_set_omit_phys_equal_check;
exports.unsafe_set_with_caml_modify = unsafe_set_with_caml_modify;
exports.unsafe_clear_if_pointer = unsafe_clear_if_pointer;
/* include Not a pure module */
