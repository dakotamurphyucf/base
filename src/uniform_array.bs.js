// Generated by Melange
'use strict';

var Obj = require("bs-platform/lib/js/obj.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Blit$negBase = require("./blit.bs.js");
var List$negBase = require("./list.bs.js");
var Array$negBase = require("./array.bs.js");
var Import$negBase = require("./import.bs.js");
var Sexpable$negBase = require("./sexpable.bs.js");
var Container$negBase = require("./container.bs.js");
var Obj_array$negBase = require("./obj_array.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");

var unsafe_create_uninitialized = Obj_array$negBase.create_zero;

var create_obj_array = Obj_array$negBase.create_zero;

var create = Obj_array$negBase.create;

var singleton = Obj_array$negBase.singleton;

var swap = Obj_array$negBase.swap;

var get = Obj_array$negBase.get;

var set = Obj_array$negBase.set;

var unsafe_get = Obj_array$negBase.unsafe_get;

var unsafe_set = Obj_array$negBase.unsafe_set;

var unsafe_set_int = Obj_array$negBase.unsafe_set_int;

var unsafe_set_int_assuming_currently_int = Obj_array$negBase.unsafe_set_int_assuming_currently_int;

var unsafe_set_assuming_currently_int = Obj_array$negBase.unsafe_set_assuming_currently_int;

var unsafe_set_omit_phys_equal_check = Obj_array$negBase.unsafe_set_omit_phys_equal_check;

var unsafe_set_with_caml_modify = Obj_array$negBase.unsafe_set_with_caml_modify;

function invariant(t) {
  if (Import$negBase.$less$great(t.TAG | 0, Obj.double_array_tag)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "uniform_array.ml",
          69,
          18
        ],
        Error: new Error()
      };
}

function init(l, f) {
  if (Import$negBase.$less(l, 0)) {
    return Import$negBase.invalid_arg("Uniform_array.init");
  }
  var res = Obj_array$negBase.create_zero(l);
  for(var i = 0 ,i_finish = Import$negBase.$neg(l, 1); i <= i_finish; ++i){
    Obj_array$negBase.unsafe_set(res, i, Curry._1(f, i));
  }
  return res;
}

function of_array(arr) {
  return init(Array$negBase.length(arr), (function (param) {
                return arr[param];
              }));
}

function map(a, f) {
  return init(Obj_array$negBase.length(a), (function (i) {
                return Curry._1(f, Obj_array$negBase.unsafe_get(a, i));
              }));
}

function iter(a, f) {
  for(var i = 0 ,i_finish = Import$negBase.$neg(Obj_array$negBase.length(a), 1); i <= i_finish; ++i){
    Curry._1(f, Obj_array$negBase.unsafe_get(a, i));
  }
  
}

function iteri(a, f) {
  for(var i = 0 ,i_finish = Import$negBase.$neg(Obj_array$negBase.length(a), 1); i <= i_finish; ++i){
    Curry._2(f, i, Obj_array$negBase.unsafe_get(a, i));
  }
  
}

function to_list(t) {
  return List$negBase.init(Obj_array$negBase.length(t), (function (param) {
                return Obj_array$negBase.get(t, param);
              }));
}

function of_list(l) {
  var len = List$negBase.length(l);
  var res = Obj_array$negBase.create_zero(len);
  List$negBase.iteri(l, (function (i, x) {
          return Obj_array$negBase.set(res, i, x);
        }));
  return res;
}

function to_array(t) {
  return Array$negBase.init(Obj_array$negBase.length(t), (function (i) {
                return Obj_array$negBase.unsafe_get(t, i);
              }));
}

function exists(t, f) {
  var _i = Import$negBase.$neg(Obj_array$negBase.length(t), 1);
  while(true) {
    var i = _i;
    if (Import$negBase.$less(i, 0)) {
      return false;
    }
    if (Curry._1(f, Obj_array$negBase.unsafe_get(t, i))) {
      return true;
    }
    _i = Import$negBase.$neg(i, 1);
    continue ;
  };
}

function map2_exn(t1, t2, f) {
  var len = Obj_array$negBase.length(t1);
  if (Import$negBase.$less$great(Obj_array$negBase.length(t2), len)) {
    Import$negBase.invalid_arg("Array.map2_exn");
  }
  return init(len, (function (i) {
                return Curry._2(f, Obj_array$negBase.unsafe_get(t1, i), Obj_array$negBase.unsafe_get(t2, i));
              }));
}

function t_sexp_grammar(grammar) {
  return Sexp_grammar$negSexplib0.coerce(Array$negBase.t_sexp_grammar(grammar));
}

var partial_arg = {
  t_of_sexp: Array$negBase.t_of_sexp,
  sexp_of_t: Array$negBase.sexp_of_t
};

var partial_arg$1 = Sexpable$negBase.Of_sexpable1;

var include = (function (param) {
      return partial_arg$1(partial_arg, param);
    })({
      to_sexpable: to_array,
      of_sexpable: of_array
    });

function create_like(len, t) {
  if (len === 0) {
    return Obj_array$negBase.empty;
  }
  if (!Import$negBase.$great(Obj_array$negBase.length(t), 0)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "uniform_array.ml",
            148,
            8
          ],
          Error: new Error()
        };
  }
  return Obj_array$negBase.create(len, Obj_array$negBase.get(t, 0));
}

var include$1 = Blit$negBase.Make1({
      create_like: create_like,
      length: Obj_array$negBase.length,
      unsafe_blit: Obj_array$negBase.unsafe_blit
    });

function fold(t, init, f) {
  var r = init;
  for(var i = 0 ,i_finish = Import$negBase.$neg(Obj_array$negBase.length(t), 1); i <= i_finish; ++i){
    r = Curry._2(f, r, Obj_array$negBase.unsafe_get(t, i));
  }
  return r;
}

function min_elt(t, compare) {
  return Container$negBase.min_elt(fold, t, compare);
}

function max_elt(t, compare) {
  return Container$negBase.max_elt(fold, t, compare);
}

var t_of_sexp = include.t_of_sexp;

var sexp_of_t = include.sexp_of_t;

var empty = Obj_array$negBase.empty;

var length = Obj_array$negBase.length;

var blit = include$1.blit;

var blito = include$1.blito;

var unsafe_blit = include$1.unsafe_blit;

var sub = include$1.sub;

var subo = include$1.subo;

var copy = Obj_array$negBase.copy;

var unsafe_clear_if_pointer = Obj_array$negBase.unsafe_clear_if_pointer;

exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.invariant = invariant;
exports.empty = empty;
exports.create = create;
exports.singleton = singleton;
exports.init = init;
exports.length = length;
exports.get = get;
exports.unsafe_get = unsafe_get;
exports.set = set;
exports.unsafe_set = unsafe_set;
exports.swap = swap;
exports.unsafe_set_omit_phys_equal_check = unsafe_set_omit_phys_equal_check;
exports.unsafe_set_with_caml_modify = unsafe_set_with_caml_modify;
exports.map = map;
exports.iter = iter;
exports.iteri = iteri;
exports.of_array = of_array;
exports.to_array = to_array;
exports.of_list = of_list;
exports.to_list = to_list;
exports.blit = blit;
exports.blito = blito;
exports.unsafe_blit = unsafe_blit;
exports.sub = sub;
exports.subo = subo;
exports.copy = copy;
exports.unsafe_create_uninitialized = unsafe_create_uninitialized;
exports.create_obj_array = create_obj_array;
exports.unsafe_set_assuming_currently_int = unsafe_set_assuming_currently_int;
exports.unsafe_set_int_assuming_currently_int = unsafe_set_int_assuming_currently_int;
exports.unsafe_set_int = unsafe_set_int;
exports.unsafe_clear_if_pointer = unsafe_clear_if_pointer;
exports.exists = exists;
exports.map2_exn = map2_exn;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
/* include Not a pure module */
