// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int32 = require("bs-platform/lib/js/int32.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Char$negBase = require("./char.bs.js");
var Int0$negBase = require("./int0.bs.js");
var Nativeint = require("bs-platform/lib/js/nativeint.js");
var Sexp$negBase = require("./sexp.bs.js");
var Sys0$negBase = require("./sys0.bs.js");
var Bytes$negBase = require("./bytes.bs.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Import$negBase = require("./import.bs.js");
var Option$negBase = require("./option.bs.js");
var Printf$negBase = require("./printf.bs.js");
var String$negBase = require("./string.bs.js");
var Sexpable$negBase = require("./sexpable.bs.js");
var Hex_lexer$negBase = require("./hex_lexer.bs.js");
var Word_size$negBase = require("./word_size.bs.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");

function convert_failure(x, a, b, to_string) {
  return Curry._4(Printf$negBase.failwithf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "conversion from ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: " to ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " failed: ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " is out of range",
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "conversion from %s to %s failed: %s is out of range"
                }), a, b, Curry._1(to_string, x), undefined);
}

var num_bits_nativeint = Word_size$negBase.num_bits(Word_size$negBase.word_size);

if (!(Sys0$negBase.int_size_in_bits === 63 || Sys0$negBase.int_size_in_bits === 31 || Sys0$negBase.int_size_in_bits === 32)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int_conversions.ml",
          19,
          9
        ],
        Error: new Error()
      };
}

var int_to_string = Import$negBase.Caml.string_of_int;

function int32_to_int_trunc(prim) {
  return prim;
}

function int_to_int32_trunc(prim) {
  return prim;
}

var int_is_representable_as_int32 = Import$negBase.$less$eq(Sys0$negBase.int_size_in_bits, 32) ? (function (param) {
      return true;
    }) : (function (x) {
      if (Import$negBase.$less$eq(Import$negBase.compare_int(Int32.min_int, x), 0)) {
        return Import$negBase.$less$eq(Import$negBase.compare_int(x, Int32.max_int), 0);
      } else {
        return false;
      }
    });

var int32_is_representable_as_int = Import$negBase.$less$eq(32, Sys0$negBase.int_size_in_bits) ? (function (param) {
      return true;
    }) : (function (x) {
      if (Import$negBase.$less$eq(Import$negBase.compare_int32(Int0$negBase.min_value, x), 0)) {
        return Import$negBase.$less$eq(Import$negBase.compare_int32(x, Int0$negBase.max_value), 0);
      } else {
        return false;
      }
    });

function int_to_int32(x) {
  if (Curry._1(int_is_representable_as_int32, x)) {
    return x;
  }
  
}

function int32_to_int(x) {
  if (Curry._1(int32_is_representable_as_int, x)) {
    return x;
  }
  
}

function int_to_int32_exn(x) {
  if (Curry._1(int_is_representable_as_int32, x)) {
    return x;
  } else {
    return convert_failure(x, "int", "int32", int_to_string);
  }
}

function int32_to_int_exn(x) {
  if (Curry._1(int32_is_representable_as_int, x)) {
    return x;
  } else {
    return convert_failure(x, "int32", "int", Int32.to_string);
  }
}

if (!Import$negBase.$less(Sys0$negBase.int_size_in_bits, 64)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int_conversions.ml",
          75,
          9
        ],
        Error: new Error()
      };
}

var int_to_int64 = Caml_int64.of_int32;

var int64_to_int_trunc = Caml_int64.to_int32;

var min = Caml_int64.of_int32(Int0$negBase.min_value);

var max = Caml_int64.of_int32(Int0$negBase.max_value);

function int64_is_representable_as_int(x) {
  if (Import$negBase.$less$eq(Import$negBase.compare_int64(min, x), 0)) {
    return Import$negBase.$less$eq(Import$negBase.compare_int64(x, max), 0);
  } else {
    return false;
  }
}

function int64_to_int(x) {
  if (int64_is_representable_as_int(x)) {
    return Caml_int64.to_int32(x);
  }
  
}

function int64_to_int_exn(x) {
  if (int64_is_representable_as_int(x)) {
    return Caml_int64.to_int32(x);
  } else {
    return convert_failure(x, "int64", "int", Int64.to_string);
  }
}

if (!Import$negBase.$less$eq(Sys0$negBase.int_size_in_bits, num_bits_nativeint)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int_conversions.ml",
          96,
          9
        ],
        Error: new Error()
      };
}

function int_to_nativeint(prim) {
  return prim;
}

function nativeint_to_int_trunc(prim) {
  return prim;
}

var nativeint_is_representable_as_int = Import$negBase.$less$eq(num_bits_nativeint, Sys0$negBase.int_size_in_bits) ? (function (param) {
      return true;
    }) : (function (x) {
      if (Import$negBase.$less$eq(Import$negBase.compare_nativeint(Int0$negBase.min_value, x), 0)) {
        return Import$negBase.$less$eq(Import$negBase.compare_nativeint(x, Int0$negBase.max_value), 0);
      } else {
        return false;
      }
    });

function nativeint_to_int(x) {
  if (Curry._1(nativeint_is_representable_as_int, x)) {
    return x;
  }
  
}

function nativeint_to_int_exn(x) {
  if (Curry._1(nativeint_is_representable_as_int, x)) {
    return x;
  } else {
    return convert_failure(x, "nativeint", "int", Nativeint.to_string);
  }
}

if (!Import$negBase.$less(32, 64)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int_conversions.ml",
          122,
          9
        ],
        Error: new Error()
      };
}

var int32_to_int64 = Caml_int64.of_int32;

var int64_to_int32_trunc = Caml_int64.to_int32;

var min$1 = Caml_int64.of_int32(Int32.min_int);

var max$1 = Caml_int64.of_int32(Int32.max_int);

function int64_is_representable_as_int32(x) {
  if (Import$negBase.$less$eq(Import$negBase.compare_int64(min$1, x), 0)) {
    return Import$negBase.$less$eq(Import$negBase.compare_int64(x, max$1), 0);
  } else {
    return false;
  }
}

function int64_to_int32(x) {
  if (int64_is_representable_as_int32(x)) {
    return Caml_int64.to_int32(x);
  }
  
}

function int64_to_int32_exn(x) {
  if (int64_is_representable_as_int32(x)) {
    return Caml_int64.to_int32(x);
  } else {
    return convert_failure(x, "int64", "int32", Int64.to_string);
  }
}

if (!Import$negBase.$less$eq(32, num_bits_nativeint)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int_conversions.ml",
          148,
          9
        ],
        Error: new Error()
      };
}

function int32_to_nativeint(prim) {
  return prim;
}

function nativeint_to_int32_trunc(prim) {
  return prim;
}

var nativeint_is_representable_as_int32 = Import$negBase.$less$eq(num_bits_nativeint, 32) ? (function (param) {
      return true;
    }) : (function (x) {
      if (Import$negBase.$less$eq(Import$negBase.compare_nativeint(Int32.min_int, x), 0)) {
        return Import$negBase.$less$eq(Import$negBase.compare_nativeint(x, Int32.max_int), 0);
      } else {
        return false;
      }
    });

function nativeint_to_int32(x) {
  if (Curry._1(nativeint_is_representable_as_int32, x)) {
    return x;
  }
  
}

function nativeint_to_int32_exn(x) {
  if (Curry._1(nativeint_is_representable_as_int32, x)) {
    return x;
  } else {
    return convert_failure(x, "nativeint", "int32", Nativeint.to_string);
  }
}

if (!Import$negBase.$great$eq(64, num_bits_nativeint)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int_conversions.ml",
          176,
          9
        ],
        Error: new Error()
      };
}

var int64_to_nativeint_trunc = Caml_int64.to_int32;

var nativeint_to_int64 = Caml_int64.of_int32;

var int64_is_representable_as_nativeint;

if (Import$negBase.$less$eq(64, num_bits_nativeint)) {
  int64_is_representable_as_nativeint = (function (param) {
      return true;
    });
} else {
  var min$2 = Caml_int64.of_int32(Nativeint.min_int);
  var max$2 = Caml_int64.of_int32(Nativeint.max_int);
  int64_is_representable_as_nativeint = (function (x) {
      if (Import$negBase.$less$eq(Import$negBase.compare_int64(min$2, x), 0)) {
        return Import$negBase.$less$eq(Import$negBase.compare_int64(x, max$2), 0);
      } else {
        return false;
      }
    });
}

function int64_to_nativeint(x) {
  if (Curry._1(int64_is_representable_as_nativeint, x)) {
    return Caml_int64.to_int32(x);
  }
  
}

function int64_to_nativeint_exn(x) {
  if (Curry._1(int64_is_representable_as_nativeint, x)) {
    return Caml_int64.to_int32(x);
  } else {
    return convert_failure(x, "int64", "nativeint", Int64.to_string);
  }
}

var min$3 = Caml_int64.asr_(Int64.min_int, 1);

var max$3 = Caml_int64.asr_(Int64.max_int, 1);

function int64_is_representable_as_int63(x) {
  if (Import$negBase.$less$eq(Import$negBase.compare_int64(min$3, x), 0)) {
    return Import$negBase.$less$eq(Import$negBase.compare_int64(x, max$3), 0);
  } else {
    return false;
  }
}

function int64_fit_on_int63_exn(x) {
  if (int64_is_representable_as_int63(x)) {
    return ;
  } else {
    return convert_failure(x, "int64", "int63", Int64.to_string);
  }
}

function insert_delimiter_every(input, delimiter, chars_per_delimiter) {
  var input_length = input.length;
  if (Import$negBase.$less$eq(input_length, chars_per_delimiter)) {
    return input;
  }
  var match = Caml_string.get(input, 0);
  var has_sign = match !== 43 ? match === 45 : true;
  var num_digits = has_sign ? Import$negBase.$neg(input_length, 1) : input_length;
  var num_delimiters = Import$negBase.$slash(Import$negBase.$neg(num_digits, 1), chars_per_delimiter);
  var output_length = Import$negBase.$plus(input_length, num_delimiters);
  var output = Bytes$negBase.create(output_length);
  var input_pos = {
    contents: Import$negBase.$neg(input_length, 1)
  };
  var output_pos = {
    contents: Import$negBase.$neg(output_length, 1)
  };
  var num_chars_until_delimiter = {
    contents: chars_per_delimiter
  };
  var first_digit_pos = has_sign ? 1 : 0;
  while(Import$negBase.$great$eq(input_pos[0], first_digit_pos)) {
    if (num_chars_until_delimiter[0] === 0) {
      Bytes$negBase.set(output, output_pos[0], delimiter);
      Import$negBase.decr(output_pos);
      num_chars_until_delimiter[0] = chars_per_delimiter;
    }
    Bytes$negBase.set(output, output_pos[0], Caml_string.get(input, input_pos[0]));
    Import$negBase.decr(input_pos);
    Import$negBase.decr(output_pos);
    Import$negBase.decr(num_chars_until_delimiter);
  };
  if (has_sign) {
    Bytes$negBase.set(output, 0, Caml_string.get(input, 0));
  }
  return Bytes$negBase.unsafe_to_string(output);
}

function insert_delimiter(input, delimiter) {
  return insert_delimiter_every(input, delimiter, 3);
}

function insert_underscores(input) {
  return insert_delimiter_every(input, /* '_' */95, 3);
}

var num_bits_int = Sys0$negBase.int_size_in_bits;

var num_bits_int32 = 32;

var num_bits_int64 = 64;

function Make(funarg) {
  var to_string_hum = function (delimiterOpt, t) {
    var delimiter = delimiterOpt !== undefined ? delimiterOpt : /* '_' */95;
    return insert_delimiter_every(Curry._1(funarg.to_string, t), delimiter, 3);
  };
  var sexp_of_t = function (t) {
    var s = Curry._1(funarg.to_string, t);
    var match = Sexp$negBase.of_int_style[0];
    return {
            TAG: /* Atom */0,
            _0: match === "No_underscores" ? s : insert_delimiter_every(s, /* '_' */95, 3)
          };
  };
  return {
          to_string_hum: to_string_hum,
          sexp_of_t: sexp_of_t
        };
}

function Make_hex(funarg) {
  var func = funarg.hash;
  var hash = Curry.__1(func);
  var to_string$p = function (delimiter, t) {
    var make_suffix = delimiter !== undefined ? (function (t) {
          return insert_delimiter_every(Curry._1(funarg.to_string, t), delimiter, 4);
        }) : funarg.to_string;
    if (Curry._2(funarg.$less, t, funarg.zero)) {
      return Import$negBase.$caret("-0x", Curry._1(make_suffix, Curry._1(funarg.neg, t)));
    } else {
      return Import$negBase.$caret("0x", Curry._1(make_suffix, t));
    }
  };
  var to_string = function (t) {
    return to_string$p(undefined, t);
  };
  var to_string_hum = function (delimiterOpt, t) {
    var delimiter = delimiterOpt !== undefined ? delimiterOpt : /* '_' */95;
    return to_string$p(delimiter, t);
  };
  var of_string_with_delimiter = function (str) {
    return Curry._1(funarg.of_string, String$negBase.filter(str, (function (c) {
                      return Curry._2(Char$negBase.$less$great, c, /* '_' */95);
                    })));
  };
  var of_string = function (str) {
    var lex = Lexing.from_string(undefined, str);
    var result = Option$negBase.try_with(function (param) {
          return Hex_lexer$negBase.parse_hex(lex);
        });
    if (lex.lex_curr_pos === lex.lex_buffer_len && result !== undefined) {
      if (result.TAG === /* Neg */0) {
        return Curry._1(funarg.neg, of_string_with_delimiter(result._0));
      } else {
        return of_string_with_delimiter(result._0);
      }
    } else {
      return Curry._3(Printf$negBase.failwithf(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ".of_string: invalid input ",
                          _1: {
                            TAG: /* Caml_string */3,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "%s.of_string: invalid input %S"
                    }), funarg.module_name, str, undefined);
    }
  };
  var t_sexp_grammar = Sexp_grammar$negSexplib0.coerce(String$negBase.t_sexp_grammar);
  var include = Sexpable$negBase.Of_stringable({
        of_string: of_string,
        to_string: to_string
      });
  return {
          Hex: {
            t_of_sexp: include.t_of_sexp,
            sexp_of_t: include.sexp_of_t,
            t_sexp_grammar: t_sexp_grammar,
            compare: funarg.compare,
            hash_fold_t: funarg.hash_fold_t,
            hash: hash,
            of_string: of_string,
            to_string: to_string,
            to_string_hum: to_string_hum
          }
        };
}

var sexp_of_int_style = Sexp$negBase.of_int_style;

exports.int_to_int32 = int_to_int32;
exports.int_to_int32_exn = int_to_int32_exn;
exports.int_to_int32_trunc = int_to_int32_trunc;
exports.int_to_int64 = int_to_int64;
exports.int_to_nativeint = int_to_nativeint;
exports.int32_to_int = int32_to_int;
exports.int32_to_int_exn = int32_to_int_exn;
exports.int32_to_int_trunc = int32_to_int_trunc;
exports.int32_to_int64 = int32_to_int64;
exports.int32_to_nativeint = int32_to_nativeint;
exports.int64_to_int = int64_to_int;
exports.int64_to_int_exn = int64_to_int_exn;
exports.int64_to_int_trunc = int64_to_int_trunc;
exports.int64_to_int32 = int64_to_int32;
exports.int64_to_int32_exn = int64_to_int32_exn;
exports.int64_to_int32_trunc = int64_to_int32_trunc;
exports.int64_to_nativeint = int64_to_nativeint;
exports.int64_to_nativeint_exn = int64_to_nativeint_exn;
exports.int64_to_nativeint_trunc = int64_to_nativeint_trunc;
exports.int64_fit_on_int63_exn = int64_fit_on_int63_exn;
exports.int64_is_representable_as_int63 = int64_is_representable_as_int63;
exports.nativeint_to_int = nativeint_to_int;
exports.nativeint_to_int_exn = nativeint_to_int_exn;
exports.nativeint_to_int_trunc = nativeint_to_int_trunc;
exports.nativeint_to_int32 = nativeint_to_int32;
exports.nativeint_to_int32_exn = nativeint_to_int32_exn;
exports.nativeint_to_int32_trunc = nativeint_to_int32_trunc;
exports.nativeint_to_int64 = nativeint_to_int64;
exports.num_bits_int = num_bits_int;
exports.num_bits_int32 = num_bits_int32;
exports.num_bits_int64 = num_bits_int64;
exports.num_bits_nativeint = num_bits_nativeint;
exports.Make = Make;
exports.Make_hex = Make_hex;
exports.sexp_of_int_style = sexp_of_int_style;
exports.insert_delimiter_every = insert_delimiter_every;
exports.insert_delimiter = insert_delimiter;
exports.insert_underscores = insert_underscores;
/* num_bits_nativeint Not a pure module */
