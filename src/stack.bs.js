// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Exn$negBase = require("./exn.bs.js");
var List$negBase = require("./list.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Error$negBase = require("./error.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Container$negBase = require("./container.bs.js");
var Option_array$negBase = require("./option_array.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Sexp_grammar$negSexplib0 = require("sexplib0/./sexp_grammar.bs.js");

function sexp_of_t(_of_a, param) {
  var v_length = param.length;
  var v_elts = param.elts;
  var arg = Option_array$negBase.sexp_of_t(_of_a, v_elts);
  var bnds_0 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "elts"
      },
      tl: {
        hd: arg,
        tl: /* [] */0
      }
    }
  };
  var bnds = {
    hd: bnds_0,
    tl: /* [] */0
  };
  var arg$1 = Import$negBase.sexp_of_int(v_length);
  var bnds_0$1 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "length"
      },
      tl: {
        hd: arg$1,
        tl: /* [] */0
      }
    }
  };
  var bnds$1 = {
    hd: bnds_0$1,
    tl: bnds
  };
  return {
          TAG: /* List */1,
          _0: bnds$1
        };
}

function capacity(t) {
  return Option_array$negBase.length(t.elts);
}

function invariant(invariant_a, t) {
  var length = t.length;
  var elts = t.elts;
  try {
    if (!(Import$negBase.$less$eq(0, length) && Import$negBase.$less$eq(length, Option_array$negBase.length(elts)))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "stack.ml",
              40,
              4
            ],
            Error: new Error()
          };
    }
    for(var i = 0 ,i_finish = Import$negBase.$neg(length, 1); i <= i_finish; ++i){
      Curry._1(invariant_a, Option_array$negBase.get_some_exn(elts, i));
    }
    for(var i$1 = length ,i_finish$1 = Import$negBase.$neg(Option_array$negBase.length(elts), 1); i$1 <= i_finish$1; ++i$1){
      if (Option_array$negBase.is_some(elts, i$1)) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "stack.ml",
                47,
                6
              ],
              Error: new Error()
            };
      }
      
    }
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return Error$negBase.raise_s(Sexp$negBase.message("Stack.invariant failed", {
                    hd: [
                      "exn",
                      Exn$negBase.sexp_of_t(exn)
                    ],
                    tl: {
                      hd: [
                        "stack",
                        sexp_of_t(Import$negBase.sexp_of_opaque, t)
                      ],
                      tl: /* [] */0
                    }
                  }));
  }
}

function create(param) {
  return {
          length: 0,
          elts: Option_array$negBase.empty
        };
}

function length(t) {
  return t.length;
}

function is_empty(t) {
  return t.length === 0;
}

function fold(t, init, f) {
  var r = init;
  for(var i = Import$negBase.$neg(t.length, 1); i >= 0; --i){
    r = Curry._2(f, r, Option_array$negBase.get_some_exn(t.elts, i));
  }
  return r;
}

function iter(t, f) {
  for(var i = Import$negBase.$neg(t.length, 1); i >= 0; --i){
    Curry._1(f, Option_array$negBase.get_some_exn(t.elts, i));
  }
  
}

var iter$1 = {
  NAME: "Custom",
  VAL: iter
};

var length$1 = {
  NAME: "Custom",
  VAL: length
};

var C = Container$negBase.Make({
      fold: fold,
      iter: iter$1,
      length: length$1
    });

var to_list = C.to_list;

function of_list(l) {
  if (List$negBase.is_empty(l)) {
    return {
            length: 0,
            elts: Option_array$negBase.empty
          };
  }
  var length = List$negBase.length(l);
  var elts = Option_array$negBase.create(Import$negBase.$star(2, length));
  var r = l;
  for(var i = Import$negBase.$neg(length, 1); i >= 0; --i){
    var match = r;
    if (match) {
      Option_array$negBase.set_some(elts, i, match.hd);
      r = match.tl;
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "stack.ml",
              108,
              14
            ],
            Error: new Error()
          };
    }
  }
  return {
          length: length,
          elts: elts
        };
}

function sexp_of_t$1(sexp_of_a, t) {
  return List$negBase.sexp_of_t(sexp_of_a, Curry._1(to_list, t));
}

function t_of_sexp(a_of_sexp, sexp) {
  return of_list(List$negBase.t_of_sexp(a_of_sexp, sexp));
}

function t_sexp_grammar(grammar) {
  return Sexp_grammar$negSexplib0.coerce(List$negBase.t_sexp_grammar(grammar));
}

function resize(t, size) {
  var arr = Option_array$negBase.create(size);
  Curry._5(Option_array$negBase.blit, t.elts, 0, arr, 0, t.length);
  t.elts = arr;
  
}

function set_capacity(t, new_capacity) {
  var new_capacity$1 = Import$negBase.max(new_capacity, t.length);
  if (Import$negBase.$less$great(new_capacity$1, Option_array$negBase.length(t.elts))) {
    return resize(t, new_capacity$1);
  }
  
}

function push(t, a) {
  if (t.length === Option_array$negBase.length(t.elts)) {
    resize(t, Import$negBase.$star(2, Import$negBase.$plus(t.length, 1)));
  }
  Option_array$negBase.set_some(t.elts, t.length, a);
  t.length = Import$negBase.$plus(t.length, 1);
  
}

function pop_nonempty(t) {
  var i = Import$negBase.$neg(t.length, 1);
  var result = Option_array$negBase.get_some_exn(t.elts, i);
  Option_array$negBase.set_none(t.elts, i);
  t.length = i;
  return result;
}

var pop_error = Error$negBase.of_string("Stack.pop of empty stack");

function pop(t) {
  if (t.length === 0) {
    return ;
  } else {
    return Caml_option.some(pop_nonempty(t));
  }
}

function pop_exn(t) {
  if (t.length === 0) {
    return Error$negBase.raise(pop_error);
  } else {
    return pop_nonempty(t);
  }
}

function top_nonempty(t) {
  return Option_array$negBase.get_some_exn(t.elts, Import$negBase.$neg(t.length, 1));
}

var top_error = Error$negBase.of_string("Stack.top of empty stack");

function top(t) {
  if (t.length === 0) {
    return ;
  } else {
    return Caml_option.some(top_nonempty(t));
  }
}

function top_exn(t) {
  if (t.length === 0) {
    return Error$negBase.raise(top_error);
  } else {
    return top_nonempty(t);
  }
}

function copy(param) {
  var length = param.length;
  var elts = param.elts;
  return {
          length: length,
          elts: Option_array$negBase.copy(elts)
        };
}

function clear(t) {
  if (!Import$negBase.$great(t.length, 0)) {
    return ;
  }
  for(var i = 0 ,i_finish = Import$negBase.$neg(t.length, 1); i <= i_finish; ++i){
    Option_array$negBase.set_none(t.elts, i);
  }
  t.length = 0;
  
}

function until_empty(t, f) {
  var _param;
  while(true) {
    if (!Import$negBase.$great(t.length, 0)) {
      return ;
    }
    Curry._1(f, pop_nonempty(t));
    _param = undefined;
    continue ;
  };
}

function singleton(x) {
  var t = {
    length: 0,
    elts: Option_array$negBase.empty
  };
  push(t, x);
  return t;
}

var mem = C.mem;

var fold_result = C.fold_result;

var fold_until = C.fold_until;

var exists = C.exists;

var for_all = C.for_all;

var count = C.count;

var sum = C.sum;

var find = C.find;

var find_map = C.find_map;

var to_array = C.to_array;

var min_elt = C.min_elt;

var max_elt = C.max_elt;

exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t$1;
exports.t_sexp_grammar = t_sexp_grammar;
exports.invariant = invariant;
exports.mem = mem;
exports.length = length;
exports.is_empty = is_empty;
exports.iter = iter;
exports.fold = fold;
exports.fold_result = fold_result;
exports.fold_until = fold_until;
exports.exists = exists;
exports.for_all = for_all;
exports.count = count;
exports.sum = sum;
exports.find = find;
exports.find_map = find_map;
exports.to_list = to_list;
exports.to_array = to_array;
exports.min_elt = min_elt;
exports.max_elt = max_elt;
exports.of_list = of_list;
exports.create = create;
exports.singleton = singleton;
exports.push = push;
exports.pop = pop;
exports.pop_exn = pop_exn;
exports.top = top;
exports.top_exn = top_exn;
exports.clear = clear;
exports.copy = copy;
exports.until_empty = until_empty;
exports.capacity = capacity;
exports.set_capacity = set_capacity;
/* C Not a pure module */
