// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Ppx_compare_lib$negBase = require("./ppx_compare_lib.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

function sexp_of_t(_of_a, param) {
  if (typeof param === "string") {
    return {
            TAG: /* Atom */0,
            _0: "Duplicate"
          };
  } else {
    return {
            TAG: /* List */1,
            _0: {
              hd: {
                TAG: /* Atom */0,
                _0: "Ok"
              },
              tl: {
                hd: Curry._1(_of_a, param.VAL),
                tl: /* [] */0
              }
            }
          };
  }
}

var Or_duplicate = {
  sexp_of_t: sexp_of_t
};

var Without_comparator = {};

var With_comparator = {};

var With_first_class_module = {};

function compare(_cmp__k, _cmp__v, a__001_, b__002_) {
  var t__006_ = b__002_[1];
  var t__004_ = a__001_[1];
  var n = Curry._2(_cmp__k, a__001_[0], b__002_[0]);
  if (n !== 0) {
    return n;
  }
  if (Ppx_compare_lib$negBase.phys_equal(t__004_, t__006_)) {
    return 0;
  }
  var variant = t__004_.NAME;
  if (variant === "Left") {
    if (typeof t__006_ === "string" || t__006_.NAME !== "Left") {
      return Caml_obj.caml_compare(t__004_, t__006_);
    } else {
      return Curry._2(_cmp__v, t__004_.VAL, t__006_.VAL);
    }
  }
  if (variant !== "Unequal") {
    if (typeof t__006_ === "string" || t__006_.NAME !== "Right") {
      return Caml_obj.caml_compare(t__004_, t__006_);
    } else {
      return Curry._2(_cmp__v, t__004_.VAL, t__006_.VAL);
    }
  }
  if (typeof t__006_ === "string") {
    return Caml_obj.caml_compare(t__004_, t__006_);
  }
  if (t__006_.NAME !== "Unequal") {
    return Caml_obj.caml_compare(t__004_, t__006_);
  }
  var _right__012_ = t__006_.VAL;
  var _left__011_ = t__004_.VAL;
  var n$1 = Curry._2(_cmp__v, _left__011_[0], _right__012_[0]);
  if (n$1 !== 0) {
    return n$1;
  } else {
    return Curry._2(_cmp__v, _left__011_[1], _right__012_[1]);
  }
}

var _tp_loc = "map_intf.ml.Symmetric_diff_element.t";

function t_of_sexp(_of_k, _of_v, sexp) {
  if (sexp.TAG === /* Atom */0) {
    return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
  }
  var match = sexp._0;
  if (!match) {
    return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
  }
  var match$1 = match.tl;
  if (!match$1) {
    return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
  }
  if (match$1.tl) {
    return Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, sexp);
  }
  var v1 = match$1.hd;
  var v0 = Curry._1(_of_k, match.hd);
  var v1$1;
  try {
    if (v1.TAG === /* Atom */0) {
      switch (v1._0) {
        case "Left" :
        case "Right" :
        case "Unequal" :
            v1$1 = Sexp_conv_error$negSexplib0.ptag_takes_args(_tp_loc, v1);
            break;
        default:
          v1$1 = Sexp_conv_error$negSexplib0.no_variant_match(undefined);
      }
    } else {
      var match$2 = v1._0;
      if (match$2) {
        var atom = match$2.hd;
        if (atom.TAG === /* Atom */0) {
          var sexp_args = match$2.tl;
          var atom$1 = atom._0;
          switch (atom$1) {
            case "Left" :
                if (sexp_args && !sexp_args.tl) {
                  var v0$1 = Curry._1(_of_v, sexp_args.hd);
                  v1$1 = {
                    NAME: "Left",
                    VAL: v0$1
                  };
                } else {
                  v1$1 = Sexp_conv_error$negSexplib0.ptag_incorrect_n_args(_tp_loc, atom$1, v1);
                }
                break;
            case "Right" :
                if (sexp_args && !sexp_args.tl) {
                  var v0$2 = Curry._1(_of_v, sexp_args.hd);
                  v1$1 = {
                    NAME: "Right",
                    VAL: v0$2
                  };
                } else {
                  v1$1 = Sexp_conv_error$negSexplib0.ptag_incorrect_n_args(_tp_loc, atom$1, v1);
                }
                break;
            case "Unequal" :
                if (sexp_args && !sexp_args.tl) {
                  var v0$3 = sexp_args.hd;
                  var v0$4;
                  if (v0$3.TAG === /* Atom */0) {
                    v0$4 = Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, v0$3);
                  } else {
                    var match$3 = v0$3._0;
                    if (match$3) {
                      var match$4 = match$3.tl;
                      if (match$4 && !match$4.tl) {
                        var v0$5 = Curry._1(_of_v, match$3.hd);
                        var v1$2 = Curry._1(_of_v, match$4.hd);
                        v0$4 = [
                          v0$5,
                          v1$2
                        ];
                      } else {
                        v0$4 = Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, v0$3);
                      }
                    } else {
                      v0$4 = Sexp_conv_error$negSexplib0.tuple_of_size_n_expected(_tp_loc, 2, v0$3);
                    }
                  }
                  v1$1 = {
                    NAME: "Unequal",
                    VAL: v0$4
                  };
                } else {
                  v1$1 = Sexp_conv_error$negSexplib0.ptag_incorrect_n_args(_tp_loc, atom$1, v1);
                }
                break;
            default:
              v1$1 = Sexp_conv_error$negSexplib0.no_variant_match(undefined);
          }
        } else {
          v1$1 = Sexp_conv_error$negSexplib0.nested_list_invalid_poly_var(_tp_loc, v1);
        }
      } else {
        v1$1 = Sexp_conv_error$negSexplib0.empty_list_invalid_poly_var(_tp_loc, v1);
      }
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Sexp_conv_error$negSexplib0.No_variant_match) {
      v1$1 = Sexp_conv_error$negSexplib0.no_matching_variant_found(_tp_loc, v1);
    } else {
      throw exn;
    }
  }
  return [
          v0,
          v1$1
        ];
}

function sexp_of_t$1(_of_k, _of_v, param) {
  var v1 = param[1];
  var v0 = Curry._1(_of_k, param[0]);
  var variant = v1.NAME;
  var v1$1;
  if (variant === "Left") {
    v1$1 = {
      TAG: /* List */1,
      _0: {
        hd: {
          TAG: /* Atom */0,
          _0: "Left"
        },
        tl: {
          hd: Curry._1(_of_v, v1.VAL),
          tl: /* [] */0
        }
      }
    };
  } else if (variant === "Unequal") {
    var v0$1 = v1.VAL;
    var v0$2 = Curry._1(_of_v, v0$1[0]);
    var v1$2 = Curry._1(_of_v, v0$1[1]);
    v1$1 = {
      TAG: /* List */1,
      _0: {
        hd: {
          TAG: /* Atom */0,
          _0: "Unequal"
        },
        tl: {
          hd: {
            TAG: /* List */1,
            _0: {
              hd: v0$2,
              tl: {
                hd: v1$2,
                tl: /* [] */0
              }
            }
          },
          tl: /* [] */0
        }
      }
    };
  } else {
    v1$1 = {
      TAG: /* List */1,
      _0: {
        hd: {
          TAG: /* Atom */0,
          _0: "Right"
        },
        tl: {
          hd: Curry._1(_of_v, v1.VAL),
          tl: /* [] */0
        }
      }
    };
  }
  return {
          TAG: /* List */1,
          _0: {
            hd: v0,
            tl: {
              hd: v1$1,
              tl: /* [] */0
            }
          }
        };
}

function t_sexp_grammar(_$pk_sexp_grammar, _$pv_sexp_grammar) {
  return {
          TAG: /* List */3,
          _0: {
            TAG: /* Cons */0,
            _0: _$pk_sexp_grammar,
            _1: {
              TAG: /* Cons */0,
              _0: {
                TAG: /* Variant */4,
                _0: {
                  name_kind: /* Any_case */0,
                  clauses: {
                    hd: {
                      name: "Left",
                      args: {
                        TAG: /* Cons */0,
                        _0: _$pv_sexp_grammar,
                        _1: /* Empty */0
                      }
                    },
                    tl: {
                      hd: {
                        name: "Right",
                        args: {
                          TAG: /* Cons */0,
                          _0: _$pv_sexp_grammar,
                          _1: /* Empty */0
                        }
                      },
                      tl: {
                        hd: {
                          name: "Unequal",
                          args: {
                            TAG: /* Cons */0,
                            _0: {
                              TAG: /* List */3,
                              _0: {
                                TAG: /* Cons */0,
                                _0: _$pv_sexp_grammar,
                                _1: {
                                  TAG: /* Cons */0,
                                  _0: _$pv_sexp_grammar,
                                  _1: /* Empty */0
                                }
                              }
                            },
                            _1: /* Empty */0
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              },
              _1: /* Empty */0
            }
          }
        };
}

var Symmetric_diff_element = {
  compare: compare,
  t_of_sexp: t_of_sexp,
  sexp_of_t: sexp_of_t$1,
  t_sexp_grammar: t_sexp_grammar
};

var compare$1 = Caml.caml_int_compare;

function equal(prim, prim$1) {
  return prim === prim$1;
}

function sexp_of_t$2(param) {
  if (param) {
    return {
            TAG: /* Atom */0,
            _0: "Stop"
          };
  } else {
    return {
            TAG: /* Atom */0,
            _0: "Continue"
          };
  }
}

var Continue_or_stop_all = {
  hd: /* Continue */0,
  tl: {
    hd: /* Stop */1,
    tl: /* [] */0
  }
};

var Continue_or_stop = {
  compare: compare$1,
  all: Continue_or_stop_all,
  equal: equal,
  sexp_of_t: sexp_of_t$2
};

var compare$2 = Caml.caml_int_compare;

function equal$1(prim, prim$1) {
  return prim === prim$1;
}

function sexp_of_t$3(param) {
  if (param) {
    return {
            TAG: /* Atom */0,
            _0: "Unfinished"
          };
  } else {
    return {
            TAG: /* Atom */0,
            _0: "Finished"
          };
  }
}

var Finished_or_unfinished_all = {
  hd: /* Finished */0,
  tl: {
    hd: /* Unfinished */1,
    tl: /* [] */0
  }
};

var Finished_or_unfinished = {
  compare: compare$2,
  all: Finished_or_unfinished_all,
  equal: equal$1,
  sexp_of_t: sexp_of_t$3
};

function Check_accessors(T, Tree, Key, Cmp, Options, M) {
  return {};
}

function Check_accessors1(M) {
  return {};
}

function Check_accessors2(M) {
  return {};
}

function Check_accessors3(M) {
  return {};
}

function Check_accessors3_with_comparator(M) {
  return {};
}

function Check_creators(T, Tree, Key, Cmp, Options, M) {
  return {};
}

function Check_creators1(M) {
  return {};
}

function Check_creators2(M) {
  return {};
}

function Check_creators3_with_comparator(M) {
  return {};
}

exports.Or_duplicate = Or_duplicate;
exports.Without_comparator = Without_comparator;
exports.With_comparator = With_comparator;
exports.With_first_class_module = With_first_class_module;
exports.Symmetric_diff_element = Symmetric_diff_element;
exports.Continue_or_stop = Continue_or_stop;
exports.Finished_or_unfinished = Finished_or_unfinished;
exports.Check_accessors = Check_accessors;
exports.Check_accessors1 = Check_accessors1;
exports.Check_accessors2 = Check_accessors2;
exports.Check_accessors3 = Check_accessors3;
exports.Check_accessors3_with_comparator = Check_accessors3_with_comparator;
exports.Check_creators = Check_creators;
exports.Check_creators1 = Check_creators1;
exports.Check_creators2 = Check_creators2;
exports.Check_creators3_with_comparator = Check_creators3_with_comparator;
/* Ppx_compare_lib-Base Not a pure module */
