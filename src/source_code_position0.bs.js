// Generated by Melange
'use strict';

var Hash$negBase = require("./hash.bs.js");
var Int0$negBase = require("./int0.bs.js");
var Import$negBase = require("./import.bs.js");
var String0$negBase = require("./string0.bs.js");
var Comparator$negBase = require("./comparator.bs.js");
var Ppx_compare_lib$negBase = require("./ppx_compare_lib.bs.js");

function compare(a__001_, b__002_) {
  if (Ppx_compare_lib$negBase.phys_equal(a__001_, b__002_)) {
    return 0;
  }
  var n = Import$negBase.compare_string(a__001_.pos_fname, b__002_.pos_fname);
  if (n !== 0) {
    return n;
  }
  var n$1 = Import$negBase.compare_int(a__001_.pos_lnum, b__002_.pos_lnum);
  if (n$1 !== 0) {
    return n$1;
  }
  var n$2 = Import$negBase.compare_int(a__001_.pos_bol, b__002_.pos_bol);
  if (n$2 !== 0) {
    return n$2;
  } else {
    return Import$negBase.compare_int(a__001_.pos_cnum, b__002_.pos_cnum);
  }
}

function hash_fold_t(hsv, arg) {
  var hsv$1 = Import$negBase.hash_fold_string(hsv, arg.pos_fname);
  var hsv$2 = Import$negBase.hash_fold_int(hsv$1, arg.pos_lnum);
  var hsv$3 = Import$negBase.hash_fold_int(hsv$2, arg.pos_bol);
  return Import$negBase.hash_fold_int(hsv$3, arg.pos_cnum);
}

function hash(x) {
  var hsv = Hash$negBase.create(undefined, undefined);
  return Hash$negBase.get_hash_value(hash_fold_t(hsv, x));
}

function sexp_of_t(param) {
  var arg = Import$negBase.sexp_of_int(param.pos_cnum);
  var bnds_0 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "pos_cnum"
      },
      tl: {
        hd: arg,
        tl: /* [] */0
      }
    }
  };
  var bnds = {
    hd: bnds_0,
    tl: /* [] */0
  };
  var arg$1 = Import$negBase.sexp_of_int(param.pos_bol);
  var bnds_0$1 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "pos_bol"
      },
      tl: {
        hd: arg$1,
        tl: /* [] */0
      }
    }
  };
  var bnds$1 = {
    hd: bnds_0$1,
    tl: bnds
  };
  var arg$2 = Import$negBase.sexp_of_int(param.pos_lnum);
  var bnds_0$2 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "pos_lnum"
      },
      tl: {
        hd: arg$2,
        tl: /* [] */0
      }
    }
  };
  var bnds$2 = {
    hd: bnds_0$2,
    tl: bnds$1
  };
  var arg$3 = Import$negBase.sexp_of_string(param.pos_fname);
  var bnds_0$3 = {
    TAG: /* List */1,
    _0: {
      hd: {
        TAG: /* Atom */0,
        _0: "pos_fname"
      },
      tl: {
        hd: arg$3,
        tl: /* [] */0
      }
    }
  };
  var bnds$3 = {
    hd: bnds_0$3,
    tl: bnds$2
  };
  return {
          TAG: /* List */1,
          _0: bnds$3
        };
}

var T = {
  compare: compare,
  hash_fold_t: hash_fold_t,
  hash: hash,
  sexp_of_t: sexp_of_t
};

var include = Comparator$negBase.Make({
      compare: compare,
      sexp_of_t: sexp_of_t
    });

function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol) {
  return String0$negBase.concat(undefined, {
              hd: pos_fname,
              tl: {
                hd: ":",
                tl: {
                  hd: Int0$negBase.to_string(pos_lnum),
                  tl: {
                    hd: ":",
                    tl: {
                      hd: Int0$negBase.to_string(Import$negBase.$neg(pos_cnum, pos_bol)),
                      tl: /* [] */0
                    }
                  }
                }
              }
            });
}

function to_string(param) {
  return make_location_string(param.pos_fname, param.pos_lnum, param.pos_cnum, param.pos_bol);
}

function sexp_of_t$1(t) {
  return {
          TAG: /* Atom */0,
          _0: to_string(t)
        };
}

var comparator = include.comparator;

exports.T = T;
exports.compare = compare;
exports.hash_fold_t = hash_fold_t;
exports.hash = hash;
exports.comparator = comparator;
exports.make_location_string = make_location_string;
exports.to_string = to_string;
exports.sexp_of_t = sexp_of_t$1;
/* include Not a pure module */
