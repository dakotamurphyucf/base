// Generated by Melange
'use strict';

var Caml = require("bs-platform/lib/js/caml.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Int$negBase = require("./int.bs.js");
var Char$negBase = require("./char.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Error$negBase = require("./error.bs.js");
var Int63$negBase = require("./int63.bs.js");
var Int64$negBase = require("./int64.bs.js");
var Bytes0$negBase = require("./bytes0.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Float0$negBase = require("./float0.bs.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var String$negBase = require("./string.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Word_size$negBase = require("./word_size.bs.js");
var Comparable$negBase = require("./comparable.bs.js");
var Comparator$negBase = require("./comparator.bs.js");
var Pretty_printer$negBase = require("./pretty_printer.bs.js");
var Int_conversions$negBase = require("./int_conversions.bs.js");
var Caml_external_polyfill = require("bs-platform/lib/js/caml_external_polyfill.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

var hash = Import$negBase.hash_float;

var hashable = {
  hash: hash,
  compare: Float0$negBase.compare,
  sexp_of_t: Import$negBase.sexp_of_float
};

var compare = Import$negBase.Float_replace_polymorphic_compare.compare;

var include = Comparator$negBase.Make({
      compare: compare,
      sexp_of_t: Import$negBase.sexp_of_float
    });

function invariant(param) {
  
}

function to_float(x) {
  return x;
}

function of_float(x) {
  return x;
}

function of_string(s) {
  try {
    return Float0$negBase.float_of_string(s);
  }
  catch (exn){
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.of_string ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "Float.of_string %s"
                  }), s, undefined);
  }
}

function to_string(x) {
  var y = Caml_format.caml_format_float("%.15g", x);
  var s = Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, Float0$negBase.float_of_string(y), x) ? y : Caml_format.caml_format_float("%.17g", x);
  var l = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$great$eq, i, l)) {
      return Import$negBase.$caret(s, ".");
    }
    var match = Caml_string.get(s, i);
    if (match >= 48) {
      if (match >= 58) {
        return s;
      }
      _i = Import$negBase.$plus(i, 1);
      continue ;
    }
    if (match !== 45) {
      return s;
    }
    _i = Import$negBase.$plus(i, 1);
    continue ;
  };
}

var min_positive_subnormal_value = Float0$negBase.$star$star(2, -1074);

var min_positive_normal_value = Float0$negBase.$star$star(2, -1022);

function of_int63(i) {
  return Curry._1(Int63$negBase.to_float, i);
}

var of_int64 = Caml_int64.to_float;

var to_int64 = Caml_int64.of_float;

var iround_lbound = Float0$negBase.lower_bound_for_int(Int$negBase.num_bits);

var iround_ubound = Float0$negBase.upper_bound_for_int(Int$negBase.num_bits);

function iround_up(t) {
  if (!Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0.0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, iround_lbound)) {
      return Int$negBase.of_float_unchecked(t);
    } else {
      return ;
    }
  }
  var t$p = Float0$negBase.ceil(t);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t$p, iround_ubound)) {
    return Int$negBase.of_float_unchecked(t$p);
  }
  
}

function iround_up_exn(t) {
  if (!Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0.0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, iround_lbound)) {
      return Int$negBase.of_float_unchecked(t);
    } else {
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Float.iround_up_exn: argument (",
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_f */0
                          ],
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ") is too small or NaN",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Float.iround_up_exn: argument (%f) is too small or NaN"
                    }), Float0$negBase.box(t), undefined);
    }
  }
  var t$p = Float0$negBase.ceil(t);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t$p, iround_ubound)) {
    return Int$negBase.of_float_unchecked(t$p);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.iround_up_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is too large",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.iround_up_exn: argument (%f) is too large"
                  }), Float0$negBase.box(t), undefined);
  }
}

function iround_down(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0.0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, iround_ubound)) {
      return Int$negBase.of_float_unchecked(t);
    } else {
      return ;
    }
  }
  var t$p = Float0$negBase.floor(t);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t$p, iround_lbound)) {
    return Int$negBase.of_float_unchecked(t$p);
  }
  
}

function iround_down_exn(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0.0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, iround_ubound)) {
      return Int$negBase.of_float_unchecked(t);
    } else {
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Float.iround_down_exn: argument (",
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_f */0
                          ],
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ") is too large",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Float.iround_down_exn: argument (%f) is too large"
                    }), Float0$negBase.box(t), undefined);
    }
  }
  var t$p = Float0$negBase.floor(t);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t$p, iround_lbound)) {
    return Int$negBase.of_float_unchecked(t$p);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.iround_down_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is too small or NaN",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.iround_down_exn: argument (%f) is too small or NaN"
                  }), Float0$negBase.box(t), undefined);
  }
}

function iround_towards_zero(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, iround_lbound) && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, iround_ubound)) {
    return Int$negBase.of_float_unchecked(t);
  }
  
}

function iround_towards_zero_exn(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, iround_lbound) && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, iround_ubound)) {
    return Int$negBase.of_float_unchecked(t);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.iround_towards_zero_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is out of range or NaN",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"
                  }), Float0$negBase.box(t), undefined);
  }
}

var round_nearest_lb = Import$negBase.$tilde$neg$dot(Float0$negBase.$star$star(2, 52));

var round_nearest_ub = Float0$negBase.$star$star(2, 52);

var one_ulp_less_than_half = Float0$negBase.one_ulp("Down", 0.5);

function iround_nearest_32(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0)) {
    var t$p = Import$negBase.$plus$dot(t, Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, one_ulp_less_than_half) ? one_ulp_less_than_half : 0.5);
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t$p, iround_ubound)) {
      return Int$negBase.of_float_unchecked(t$p);
    } else {
      return ;
    }
  }
  var t$p$1 = Float0$negBase.floor(Import$negBase.$plus$dot(t, 0.5));
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t$p$1, iround_lbound)) {
    return Int$negBase.of_float_unchecked(t$p$1);
  }
  
}

function iround_nearest_64(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, round_nearest_ub)) {
      return Int$negBase.of_float_unchecked(Import$negBase.$plus$dot(t, Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, one_ulp_less_than_half) ? one_ulp_less_than_half : 0.5));
    } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, iround_ubound)) {
      return Int$negBase.of_float_unchecked(t);
    } else {
      return ;
    }
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, round_nearest_lb)) {
    return Int$negBase.of_float_unchecked(Float0$negBase.floor(Import$negBase.$plus$dot(t, 0.5)));
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, iround_lbound)) {
    return Int$negBase.of_float_unchecked(t);
  } else {
    return ;
  }
}

var iround_nearest = Word_size$negBase.word_size ? iround_nearest_64 : iround_nearest_32;

function iround_nearest_exn_32(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0)) {
    var t$p = Import$negBase.$plus$dot(t, Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, one_ulp_less_than_half) ? one_ulp_less_than_half : 0.5);
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t$p, iround_ubound)) {
      return Int$negBase.of_float_unchecked(t$p);
    } else {
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Float.iround_nearest_exn: argument (",
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_f */0
                          ],
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ") is too large",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Float.iround_nearest_exn: argument (%f) is too large"
                    }), Float0$negBase.box(t), undefined);
    }
  }
  var t$p$1 = Float0$negBase.floor(Import$negBase.$plus$dot(t, 0.5));
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t$p$1, iround_lbound)) {
    return Int$negBase.of_float_unchecked(t$p$1);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.iround_nearest_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is too small",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.iround_nearest_exn: argument (%f) is too small"
                  }), Float0$negBase.box(t), undefined);
  }
}

function iround_nearest_exn_64(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, round_nearest_ub)) {
      return Int$negBase.of_float_unchecked(Import$negBase.$plus$dot(t, Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, one_ulp_less_than_half) ? one_ulp_less_than_half : 0.5));
    } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, iround_ubound)) {
      return Int$negBase.of_float_unchecked(t);
    } else {
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Float.iround_nearest_exn: argument (",
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_f */0
                          ],
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ") is too large",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Float.iround_nearest_exn: argument (%f) is too large"
                    }), Float0$negBase.box(t), undefined);
    }
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, round_nearest_lb)) {
    return Int$negBase.of_float_unchecked(Float0$negBase.floor(Import$negBase.$plus$dot(t, 0.5)));
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, iround_lbound)) {
    return Int$negBase.of_float_unchecked(t);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.iround_nearest_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is too small or NaN",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.iround_nearest_exn: argument (%f) is too small or NaN"
                  }), Float0$negBase.box(t), undefined);
  }
}

var iround_nearest_exn = Word_size$negBase.word_size ? iround_nearest_exn_64 : iround_nearest_exn_32;

function iround_exn(dirOpt, t) {
  var dir = dirOpt !== undefined ? dirOpt : "Nearest";
  if (dir === "Down") {
    return iround_down_exn(t);
  } else if (dir === "Nearest") {
    return iround_nearest_exn(t);
  } else if (dir === "Zero") {
    return iround_towards_zero_exn(t);
  } else {
    return iround_up_exn(t);
  }
}

function iround(dirOpt, t) {
  var dir = dirOpt !== undefined ? dirOpt : "Nearest";
  try {
    var dirOpt$1 = dir;
    return dirOpt$1 === "Down" ? iround_down_exn(t) : (
              dirOpt$1 === "Nearest" ? iround_nearest_exn(t) : (
                  dirOpt$1 === "Zero" ? iround_towards_zero_exn(t) : iround_up_exn(t)
                )
            );
  }
  catch (exn){
    return ;
  }
}

function is_inf(x) {
  var match = Float0$negBase.classify_float(x);
  return match === 3;
}

function min_inan(x, y) {
  if (Float0$negBase.is_nan(y) || !(Float0$negBase.is_nan(x) || !Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, x, y))) {
    return x;
  } else {
    return y;
  }
}

function max_inan(x, y) {
  if (Float0$negBase.is_nan(y) || !(Float0$negBase.is_nan(x) || !Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, x, y))) {
    return x;
  } else {
    return y;
  }
}

function square(x) {
  return Import$negBase.$star$dot(x, x);
}

var fractional = Import$negBase.fst;

var integral = Import$negBase.snd;

var Parts = {
  fractional: fractional,
  integral: integral,
  modf: Float0$negBase.modf
};

function round_towards_zero(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0)) {
    return Float0$negBase.floor(t);
  } else {
    return Float0$negBase.ceil(t);
  }
}

function round_nearest(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, round_nearest_lb) && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, round_nearest_ub)) {
    return Float0$negBase.floor(Import$negBase.$plus$dot(t, Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, one_ulp_less_than_half) ? one_ulp_less_than_half : 0.5));
  } else {
    return Import$negBase.$plus$dot(t, 0);
  }
}

function round_nearest_half_to_even(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, round_nearest_lb) || Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, round_nearest_ub)) {
    return Import$negBase.$plus$dot(t, 0);
  }
  var floor = Float0$negBase.floor(t);
  var ceil_or_succ = Import$negBase.$plus$dot(floor, 1);
  var diff_floor = Import$negBase.$neg$dot(t, floor);
  var diff_ceil = Import$negBase.$neg$dot(ceil_or_succ, t);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, diff_floor, diff_ceil) || !(Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, diff_floor, diff_ceil) || !Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, Float0$negBase.mod_float(floor, 2), 0))) {
    return floor;
  } else {
    return ceil_or_succ;
  }
}

var int63_round_lbound = Float0$negBase.lower_bound_for_int(Int63$negBase.num_bits);

var int63_round_ubound = Float0$negBase.upper_bound_for_int(Int63$negBase.num_bits);

function int63_round_up_exn(t) {
  if (!Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0.0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, int63_round_lbound)) {
      return Curry._1(Int63$negBase.of_float_unchecked, t);
    } else {
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Float.int63_round_up_exn: argument (",
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_f */0
                          ],
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ") is too small or NaN",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Float.int63_round_up_exn: argument (%f) is too small or NaN"
                    }), Float0$negBase.box(t), undefined);
    }
  }
  var t$p = Float0$negBase.ceil(t);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t$p, int63_round_ubound)) {
    return Curry._1(Int63$negBase.of_float_unchecked, t$p);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.int63_round_up_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is too large",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.int63_round_up_exn: argument (%f) is too large"
                  }), Float0$negBase.box(t), undefined);
  }
}

function int63_round_down_exn(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0.0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, int63_round_ubound)) {
      return Curry._1(Int63$negBase.of_float_unchecked, t);
    } else {
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Float.int63_round_down_exn: argument (",
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_f */0
                          ],
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ") is too large",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Float.int63_round_down_exn: argument (%f) is too large"
                    }), Float0$negBase.box(t), undefined);
    }
  }
  var t$p = Float0$negBase.floor(t);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t$p, int63_round_lbound)) {
    return Curry._1(Int63$negBase.of_float_unchecked, t$p);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.int63_round_down_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is too small or NaN",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.int63_round_down_exn: argument (%f) is too small or NaN"
                  }), Float0$negBase.box(t), undefined);
  }
}

function int63_round_nearest_portable_alloc_exn(t0) {
  var t = round_nearest(t0);
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0)) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, int63_round_ubound)) {
      return Curry._1(Int63$negBase.of_float_unchecked, t);
    } else {
      return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Float.int63_round_nearest_portable_alloc_exn: argument (",
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_f */0
                          ],
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ") is too large",
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"
                    }), Float0$negBase.box(t0), undefined);
    }
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, int63_round_lbound)) {
    return Curry._1(Int63$negBase.of_float_unchecked, t);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.int63_round_nearest_portable_alloc_exn: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is too small or NaN",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"
                  }), Float0$negBase.box(t0), undefined);
  }
}

function int63_round_nearest_arch64_noalloc_exn(f) {
  return Curry._1(Int63$negBase.of_int, iround_nearest_exn(f));
}

var int63_round_nearest_exn = Word_size$negBase.word_size ? int63_round_nearest_arch64_noalloc_exn : int63_round_nearest_portable_alloc_exn;

function round(dirOpt, t) {
  var dir = dirOpt !== undefined ? dirOpt : "Nearest";
  if (dir === "Down") {
    return Float0$negBase.floor(t);
  } else if (dir === "Nearest") {
    return round_nearest(t);
  } else if (dir === "Zero") {
    return round_towards_zero(t);
  } else {
    return Float0$negBase.ceil(t);
  }
}

var compare$1 = Caml.caml_int_compare;

var _tp_loc = "float.ml.Class.t";

function t_of_sexp(sexp) {
  if (sexp.TAG === /* Atom */0) {
    switch (sexp._0) {
      case "Infinite" :
      case "infinite" :
          return /* Infinite */0;
      case "Nan" :
      case "nan" :
          return /* Nan */1;
      case "Normal" :
      case "normal" :
          return /* Normal */2;
      case "Subnormal" :
      case "subnormal" :
          return /* Subnormal */3;
      case "Zero" :
      case "zero" :
          return /* Zero */4;
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  } else {
    var match = sexp._0;
    if (!match) {
      return Sexp_conv_error$negSexplib0.empty_list_invalid_sum(_tp_loc, sexp);
    }
    var match$1 = match.hd;
    if (match$1.TAG !== /* Atom */0) {
      return Sexp_conv_error$negSexplib0.nested_list_invalid_sum(_tp_loc, sexp);
    }
    switch (match$1._0) {
      case "Infinite" :
      case "Nan" :
      case "Normal" :
      case "Subnormal" :
      case "Zero" :
      case "infinite" :
      case "nan" :
      case "normal" :
      case "subnormal" :
      case "zero" :
          return Sexp_conv_error$negSexplib0.stag_no_args(_tp_loc, sexp);
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, sexp);
    }
  }
}

function sexp_of_t(param) {
  switch (param) {
    case /* Infinite */0 :
        return {
                TAG: /* Atom */0,
                _0: "Infinite"
              };
    case /* Nan */1 :
        return {
                TAG: /* Atom */0,
                _0: "Nan"
              };
    case /* Normal */2 :
        return {
                TAG: /* Atom */0,
                _0: "Normal"
              };
    case /* Subnormal */3 :
        return {
                TAG: /* Atom */0,
                _0: "Subnormal"
              };
    case /* Zero */4 :
        return {
                TAG: /* Atom */0,
                _0: "Zero"
              };
    
  }
}

function to_string$1(t) {
  return Import$negBase.string_of_sexp(sexp_of_t(t));
}

function of_string$1(s) {
  return t_of_sexp(Import$negBase.sexp_of_string(s));
}

function classify(t) {
  var match = Float0$negBase.classify_float(t);
  switch (match) {
    case /* FP_normal */0 :
        return /* Normal */2;
    case /* FP_subnormal */1 :
        return /* Subnormal */3;
    case /* FP_zero */2 :
        return /* Zero */4;
    case /* FP_infinite */3 :
        return /* Infinite */0;
    case /* FP_nan */4 :
        return /* Nan */1;
    
  }
}

function is_finite(t) {
  return !(Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, Float0$negBase.infinity) || Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, Float0$negBase.neg_infinity) || Float0$negBase.is_nan(t));
}

function insert_underscores(delimiterOpt, strip_zeroOpt, string) {
  var delimiter = delimiterOpt !== undefined ? delimiterOpt : /* '_' */95;
  var strip_zero = strip_zeroOpt !== undefined ? strip_zeroOpt : false;
  var match = String$negBase.lsplit2(string, /* '.' */46);
  if (match === undefined) {
    return Int_conversions$negBase.insert_delimiter(string, delimiter);
  }
  var right = match[1];
  var left = Int_conversions$negBase.insert_delimiter(match[0], delimiter);
  var right$1 = strip_zero ? String$negBase.rstrip((function (c) {
            return Curry._2(Char$negBase.$eq, c, /* '0' */48);
          }), right) : right;
  if (right$1 === "") {
    return left;
  } else {
    return Import$negBase.$caret(left, Import$negBase.$caret(".", right$1));
  }
}

function to_string_hum(delimiter, decimalsOpt, strip_zero, f) {
  var decimals = decimalsOpt !== undefined ? decimalsOpt : 3;
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, decimals, 0)) {
    Curry._2(Printf$negBase.invalid_argf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "to_string_hum: invalid argument ~decimals=",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: /* End_of_format */0
                }
              },
              _1: "to_string_hum: invalid argument ~decimals=%d"
            }), decimals, undefined);
  }
  var match = classify(f);
  if (match !== 1) {
    if (match) {
      return insert_underscores(delimiter, strip_zero, Curry._2(Printf$negBase.sprintf(/* Format */{
                          _0: {
                            TAG: /* Float */8,
                            _0: [
                              /* Float_flag_ */0,
                              /* Float_f */0
                            ],
                            _1: /* No_padding */0,
                            _2: /* Arg_precision */1,
                            _3: /* End_of_format */0
                          },
                          _1: "%.*f"
                        }), decimals, f));
    } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, f, 0)) {
      return "inf";
    } else {
      return "-inf";
    }
  } else {
    return "nan";
  }
}

function sexp_of_t$1(t) {
  var sexp = Import$negBase.sexp_of_float(t);
  var match = Sexp$negBase.of_float_style[0];
  if (match === "No_underscores") {
    return sexp;
  }
  if (sexp.TAG !== /* Atom */0) {
    return Error$negBase.raise_s(Sexp$negBase.message("[sexp_of_float] produced strange sexp", {
                    hd: [
                      "sexp",
                      Sexp$negBase.sexp_of_t(sexp)
                    ],
                    tl: /* [] */0
                  }));
  }
  var string = sexp._0;
  if (String$negBase.contains(undefined, undefined, string, /* 'E' */69)) {
    return sexp;
  } else {
    return {
            TAG: /* Atom */0,
            _0: insert_underscores(undefined, undefined, string)
          };
  }
}

function to_padded_compact_string_custom(t, prefixOpt, kilo, mega, giga, tera, peta, param) {
  var prefix = prefixOpt !== undefined ? prefixOpt : "";
  var iround_ratio_exn = function (numerator, denominator) {
    var k = Float0$negBase.floor(Import$negBase.$slash$dot(numerator, denominator));
    var lower = Import$negBase.$star$dot(denominator, k);
    var higher = Import$negBase.$star$dot(denominator, Import$negBase.$plus$dot(k, 1));
    var diff_right = Import$negBase.$neg$dot(higher, numerator);
    var diff_left = Import$negBase.$neg$dot(numerator, lower);
    var k$1 = iround_nearest_exn(k);
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, diff_right, diff_left) || !(Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, diff_right, diff_left) || Curry._2(Import$negBase.Int_replace_polymorphic_compare.$eq, Import$negBase.mod(k$1, 2), 0))) {
      return Import$negBase.$plus(k$1, 1);
    } else {
      return k$1;
    }
  };
  var match = classify(t);
  if (match === 1) {
    return "nan  ";
  }
  if (!match) {
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 0.0)) {
      return "-inf  ";
    } else {
      return "inf  ";
    }
  }
  var go = function (t) {
    var conv = function (mag, t, denominator) {
      if (!(Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, denominator, 100) && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 999.95) || Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, denominator, 100000) && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, round_nearest(Import$negBase.$star$dot(denominator, 9.9995))))) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "float.ml",
                693,
                8
              ],
              Error: new Error()
            };
      }
      if (!Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, round_nearest(Import$negBase.$star$dot(denominator, 9999.5)))) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "float.ml",
                696,
                8
              ],
              Error: new Error()
            };
      }
      var k = iround_ratio_exn(t, denominator);
      var i = Import$negBase.$slash(k, 10);
      var d = Import$negBase.mod(k, 10);
      if (!(Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less$eq, 0, i) && Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, i, 1000))) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "float.ml",
                703,
                8
              ],
              Error: new Error()
            };
      }
      if (!(Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less$eq, 0, d) && Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, d, 10))) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "float.ml",
                704,
                8
              ],
              Error: new Error()
            };
      }
      if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$eq, d, 0)) {
        return Curry._3(Printf$negBase.sprintf(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ' ' */32,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%s%d%s "
                      }), prefix, i, mag);
      } else {
        return Curry._4(Printf$negBase.sprintf(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%s%d%s%d"
                      }), prefix, i, mag, d);
      }
    };
    if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 999.95E0)) {
      if (!(Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, 0, t) && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 999.95))) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "float.ml",
                680,
                8
              ],
              Error: new Error()
            };
      }
      var x = Import$negBase.$caret(prefix, Caml_format.caml_format_float("%.1f", t));
      if (!String$negBase.is_suffix(x, ".0")) {
        return x;
      }
      var x$1 = Bytes0$negBase.of_string(x);
      var n = x$1.length;
      Caml_bytes.set(x$1, Import$negBase.$neg(n, 1), /* ' ' */32);
      Caml_bytes.set(x$1, Import$negBase.$neg(n, 2), /* ' ' */32);
      return Bytes0$negBase.unsafe_to_string(x$1);
    } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 999.95E3)) {
      return conv(kilo, t, 100);
    } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 999.95E6)) {
      return conv(mega, t, 100000);
    } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 999.95E9)) {
      return conv(giga, t, 100000000);
    } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 999.95E12)) {
      return conv(tera, t, 100000000000);
    } else if (peta !== undefined && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 999.95E15)) {
      return conv(peta, t, 100000000000000);
    } else {
      return Curry._2(Printf$negBase.sprintf(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_e */1
                          ],
                          _1: /* No_padding */0,
                          _2: /* Lit_precision */{
                            _0: 1
                          },
                          _3: /* End_of_format */0
                        }
                      },
                      _1: "%s%.1e"
                    }), prefix, t);
    }
  };
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0)) {
    return go(t);
  } else {
    return Import$negBase.$caret("-", go(Import$negBase.$tilde$neg$dot(t)));
  }
}

function to_padded_compact_string(t) {
  return to_padded_compact_string_custom(t, undefined, "k", "m", "g", "t", "p", undefined);
}

function int_pow(x, n) {
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$eq, n, 0)) {
    return 1;
  }
  var x$1 = Import$negBase.$plus$dot(x, -0);
  var n$1 = {
    contents: n
  };
  var accum = 1;
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, n$1[0], 0)) {
    x$1 = Import$negBase.$slash$dot(1, x$1);
    n$1[0] = Import$negBase.$tilde$neg(n$1[0]);
    if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, n$1[0], 0)) {
      accum = x$1;
      Import$negBase.decr(n$1);
    }
    
  }
  while(Curry._2(Import$negBase.Int_replace_polymorphic_compare.$great, n$1[0], 1)) {
    if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less$great, Import$negBase.land(n$1[0], 1), 0)) {
      accum = Import$negBase.$star$dot(x$1, accum);
    }
    x$1 = Import$negBase.$star$dot(x$1, x$1);
    n$1[0] = Import$negBase.lsr(n$1[0], 1);
  };
  return Import$negBase.$star$dot(x$1, accum);
}

function round_gen(x, how) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, x, 0)) {
    return 0;
  }
  if (!is_finite(x)) {
    return x;
  }
  var match;
  if (how.NAME === "significant_digits") {
    var sd = how.VAL;
    var dd = Import$negBase.$neg(sd, Int$negBase.of_float(Float0$negBase.ceil(Caml_external_polyfill.resolve("caml_log10_float")(Float0$negBase.abs_float(x)))));
    match = [
      sd,
      dd
    ];
  } else {
    var dd$1 = how.VAL;
    var sd$1 = Import$negBase.$plus(dd$1, Int$negBase.of_float(Float0$negBase.ceil(Caml_external_polyfill.resolve("caml_log10_float")(Float0$negBase.abs_float(x)))));
    match = [
      sd$1,
      dd$1
    ];
  }
  var dd$2 = match[1];
  var sd$2 = match[0];
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, sd$2, 0)) {
    return 0;
  }
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$great$eq, sd$2, 17)) {
    return x;
  }
  var abs_dd = Int$negBase.abs(dd$2);
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$great, abs_dd, 22) || Curry._2(Import$negBase.Int_replace_polymorphic_compare.$great$eq, sd$2, 16)) {
    return of_string(Curry._2(Printf$negBase.sprintf(/* Format */{
                        _0: {
                          TAG: /* Float */8,
                          _0: [
                            /* Float_flag_ */0,
                            /* Float_g */3
                          ],
                          _1: /* No_padding */0,
                          _2: /* Arg_precision */1,
                          _3: /* End_of_format */0
                        },
                        _1: "%.*g"
                      }), sd$2, x));
  }
  var order = int_pow(10, abs_dd);
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$great$eq, dd$2, 0)) {
    return Import$negBase.$slash$dot(round_nearest_half_to_even(Import$negBase.$star$dot(x, order)), order);
  } else {
    return Import$negBase.$star$dot(round_nearest_half_to_even(Import$negBase.$slash$dot(x, order)), order);
  }
}

function round_significant(x, significant_digits) {
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less$eq, significant_digits, 0)) {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Float.round_significant: invalid argument significant_digits:",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: /* End_of_format */0
                      }
                    },
                    _1: "Float.round_significant: invalid argument significant_digits:%d"
                  }), significant_digits, undefined);
  } else {
    return round_gen(x, {
                NAME: "significant_digits",
                VAL: significant_digits
              });
  }
}

function round_decimal(x, decimal_digits) {
  return round_gen(x, {
              NAME: "decimal_digits",
              VAL: decimal_digits
            });
}

function between(t, low, high) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, low, t)) {
    return Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, high);
  } else {
    return false;
  }
}

function clamp_exn(t, min, max) {
  if (!Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, min, max)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "float.ml",
            856,
            2
          ],
          Error: new Error()
        };
  }
  return Float0$negBase.clamp_unchecked(t, min, max);
}

function clamp(t, min, max) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, min, max)) {
    return {
            TAG: /* Ok */0,
            _0: Float0$negBase.clamp_unchecked(t, min, max)
          };
  } else {
    return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                    hd: [
                      "min",
                      Import$negBase.sexp_of_float(min)
                    ],
                    tl: {
                      hd: [
                        "max",
                        Import$negBase.sexp_of_float(max)
                      ],
                      tl: /* [] */0
                    }
                  }));
  }
}

function sign_exn(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0)) {
    return /* Pos */2;
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 0)) {
    return /* Neg */0;
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, 0)) {
    return /* Zero */1;
  } else {
    return Error$negBase.raise_s(Sexp$negBase.message("Float.sign_exn of NAN", {
                    hd: [
                      "",
                      sexp_of_t$1(t)
                    ],
                    tl: /* [] */0
                  }));
  }
}

function sign_or_nan(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0)) {
    return /* Pos */2;
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 0)) {
    return /* Neg */0;
  } else if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$eq, t, 0)) {
    return /* Zero */1;
  } else {
    return /* Nan */3;
  }
}

function ieee_negative(t) {
  var bits = Caml_int64.bits_of_float(t);
  return Caml.i64_lt(bits, Int64.zero);
}

var exponent_mask64 = Int64$negBase.$neg(Int64$negBase.shift_left(Int64$negBase.one, 11), Int64$negBase.one);

var exponent_mask = Int64$negBase.to_int_exn(exponent_mask64);

var mantissa_mask = Curry._2(Int63$negBase.$neg, Curry._2(Int63$negBase.shift_left, Int63$negBase.one, 52), Int63$negBase.one);

var mantissa_mask64 = Curry._1(Int63$negBase.to_int64, mantissa_mask);

function ieee_exponent(t) {
  var bits = Caml_int64.bits_of_float(t);
  return Caml_int64.to_int32(Int64$negBase.bit_and(Int64$negBase.shift_right_logical(bits, 52), exponent_mask64));
}

function ieee_mantissa(t) {
  var bits = Caml_int64.bits_of_float(t);
  return Curry._1(Int63$negBase.of_int64_exn, Caml_int64.and_(bits, mantissa_mask64));
}

function create_ieee_exn(negative, exponent, mantissa) {
  if (Curry._2(Int$negBase.$less$great, Int$negBase.bit_and(exponent, exponent_mask), exponent)) {
    return Curry._3(Printf$negBase.failwithf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "exponent ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: " out of range [0, ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* ']' */93,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    },
                    _1: "exponent %d out of range [0, %d]"
                  }), exponent, exponent_mask, undefined);
  }
  if (Curry._2(Int63$negBase.$less$great, Curry._2(Int63$negBase.bit_and, mantissa, mantissa_mask), mantissa)) {
    return Curry._3(Printf$negBase.failwithf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "mantissa ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: " out of range [0, ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Char_literal */12,
                              _0: /* ']' */93,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    },
                    _1: "mantissa %s out of range [0, %s]"
                  }), Curry._1(Int63$negBase.to_string, mantissa), Curry._1(Int63$negBase.to_string, mantissa_mask), undefined);
  }
  var sign_bits = negative ? Int64.min_int : Int64.zero;
  var expt_bits = Caml_int64.lsl_(Caml_int64.of_int32(exponent), 52);
  var mant_bits = Curry._1(Int63$negBase.to_int64, mantissa);
  return Caml_int64.float_of_bits(Caml_int64.or_(sign_bits, Caml_int64.or_(expt_bits, mant_bits)));
}

function create_ieee(negative, exponent, mantissa) {
  return Or_error$negBase.try_with(undefined, (function (param) {
                return create_ieee_exn(negative, exponent, mantissa);
              }));
}

function to_string$2(x) {
  return Curry._1(Printf$negBase.sprintf(/* Format */{
                  _0: {
                    TAG: /* Float */8,
                    _0: [
                      /* Float_flag_ */0,
                      /* Float_G */4
                    ],
                    _1: /* No_padding */0,
                    _2: /* Lit_precision */{
                      _0: 8
                    },
                    _3: /* End_of_format */0
                  },
                  _1: "%.8G"
                }), x);
}

function sexp_of_t$2(x) {
  return {
          TAG: /* Atom */0,
          _0: to_string$2(x)
        };
}

var of_string$2 = of_string;

var include$1 = Comparable$negBase.With_zero({
      compare: compare,
      sexp_of_t: Import$negBase.sexp_of_float,
      zero: 0
    });

function is_positive(t) {
  return Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great, t, 0);
}

function is_non_negative(t) {
  return Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, 0);
}

function is_negative(t) {
  return Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less, t, 0);
}

function is_non_positive(t) {
  return Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, 0);
}

var include$2 = Pretty_printer$negBase.Register({
      module_name: "Base.Float",
      to_string: to_string
    });

function of_float$1(x) {
  return x;
}

var Private = {
  box: Float0$negBase.box,
  clamp_unchecked: Float0$negBase.clamp_unchecked,
  lower_bound_for_int: Float0$negBase.lower_bound_for_int,
  upper_bound_for_int: Float0$negBase.upper_bound_for_int,
  specialized_hash: Import$negBase.hash_float,
  one_ulp_less_than_half: one_ulp_less_than_half,
  int63_round_nearest_portable_alloc_exn: int63_round_nearest_portable_alloc_exn,
  int63_round_nearest_arch64_noalloc_exn: int63_round_nearest_arch64_noalloc_exn,
  iround_nearest_exn_64: iround_nearest_exn_64
};

var $less = Import$negBase.Float_replace_polymorphic_compare.$less;

var $great = Import$negBase.Float_replace_polymorphic_compare.$great;

function min(x, y) {
  if (Curry._2($less, x, y) || Float0$negBase.is_nan(x)) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (Curry._2($great, x, y) || Float0$negBase.is_nan(x)) {
    return x;
  } else {
    return y;
  }
}

var t_sexp_grammar = Import$negBase.float_sexp_grammar;

var hash_fold_t = Import$negBase.hash_fold_float;

var t_of_sexp$1 = Import$negBase.float_of_sexp;

var $great$eq = Import$negBase.Float_replace_polymorphic_compare.$great$eq;

var $less$eq = Import$negBase.Float_replace_polymorphic_compare.$less$eq;

var $eq = Import$negBase.Float_replace_polymorphic_compare.$eq;

var $less$great = Import$negBase.Float_replace_polymorphic_compare.$less$great;

var equal = Import$negBase.Float_replace_polymorphic_compare.equal;

var compare$2 = Import$negBase.Float_replace_polymorphic_compare.compare;

var ascending = Import$negBase.Float_replace_polymorphic_compare.ascending;

var descending = Import$negBase.Float_replace_polymorphic_compare.descending;

var comparator = include.comparator;

var pp = include$2.pp;

var nan = Float0$negBase.nan;

var infinity = Float0$negBase.infinity;

var neg_infinity = Float0$negBase.neg_infinity;

var max_value = Float0$negBase.infinity;

var min_value = Float0$negBase.neg_infinity;

var zero = 0;

var one = 1;

var minus_one = -1;

var pi = 3.14159265358979312;

var sqrt_pi = 1.7724538509055161;

var sqrt_2pi = 2.50662827463100069;

var euler = 0.577215664901532866;

var epsilon_float = Float0$negBase.epsilon_float;

var max_finite_value = Float0$negBase.max_finite_value;

var to_int64_preserve_order = Float0$negBase.to_int64_preserve_order;

var to_int64_preserve_order_exn = Float0$negBase.to_int64_preserve_order_exn;

var of_int64_preserve_order = Float0$negBase.of_int64_preserve_order;

var one_ulp = Float0$negBase.one_ulp;

var of_int = Int$negBase.to_float;

var to_int = Int$negBase.of_float;

var round_down = Float0$negBase.floor;

var round_up = Float0$negBase.ceil;

var is_nan = Float0$negBase.is_nan;

var $plus = Import$negBase.$plus$dot;

var $neg = Import$negBase.$neg$dot;

var $slash = Import$negBase.$slash$dot;

var $star = Import$negBase.$star$dot;

var $star$star = Float0$negBase.$star$star;

var $tilde$neg = Import$negBase.$tilde$neg$dot;

var modf = Float0$negBase.modf;

var mod_float = Float0$negBase.mod_float;

var add = Import$negBase.$plus$dot;

var sub = Import$negBase.$neg$dot;

var neg = Import$negBase.$tilde$neg$dot;

var scale = Import$negBase.$star$dot;

var abs = Float0$negBase.abs_float;

var O_$great$eq = Import$negBase.Float_replace_polymorphic_compare.$great$eq;

var O_$less$eq = Import$negBase.Float_replace_polymorphic_compare.$less$eq;

var O_$eq = Import$negBase.Float_replace_polymorphic_compare.$eq;

var O_$great = Import$negBase.Float_replace_polymorphic_compare.$great;

var O_$less = Import$negBase.Float_replace_polymorphic_compare.$less;

var O_$less$great = Import$negBase.Float_replace_polymorphic_compare.$less$great;

var O = {
  $plus: Import$negBase.$plus$dot,
  $neg: Import$negBase.$neg$dot,
  $star: Import$negBase.$star$dot,
  $slash: Import$negBase.$slash$dot,
  $star$star: Float0$negBase.$star$star,
  $tilde$neg: Import$negBase.$tilde$neg$dot,
  $great$eq: O_$great$eq,
  $less$eq: O_$less$eq,
  $eq: O_$eq,
  $great: O_$great,
  $less: O_$less,
  $less$great: O_$less$great,
  abs: Float0$negBase.abs_float,
  neg: Import$negBase.$tilde$neg$dot,
  zero: 0,
  of_int: Int$negBase.to_float,
  of_float: of_float$1
};

var O_dot = {
  $plus$dot: Import$negBase.$plus$dot,
  $neg$dot: Import$negBase.$neg$dot,
  $star$dot: Import$negBase.$star$dot,
  $slash$dot: Import$negBase.$slash$dot,
  $star$star$dot: Float0$negBase.$star$star,
  $tilde$neg$dot: Import$negBase.$tilde$neg$dot
};

var ldexp = Float0$negBase.ldexp;

var frexp = Float0$negBase.frexp;

var Class_all = {
  hd: /* Infinite */0,
  tl: {
    hd: /* Nan */1,
    tl: {
      hd: /* Normal */2,
      tl: {
        hd: /* Subnormal */3,
        tl: {
          hd: /* Zero */4,
          tl: /* [] */0
        }
      }
    }
  }
};

var Class_t_sexp_grammar = {
  TAG: /* Enum */1,
  _0: {
    name_kind: /* Capitalized */1,
    names: {
      hd: "Infinite",
      tl: {
        hd: "Nan",
        tl: {
          hd: "Normal",
          tl: {
            hd: "Subnormal",
            tl: {
              hd: "Zero",
              tl: /* [] */0
            }
          }
        }
      }
    }
  }
};

var Class = {
  compare: compare$1,
  all: Class_all,
  t_of_sexp: t_of_sexp,
  sexp_of_t: sexp_of_t,
  t_sexp_grammar: Class_t_sexp_grammar,
  of_string: of_string$1,
  to_string: to_string$1
};

var sign = include$1.sign;

var Terse = {
  t_of_sexp: Import$negBase.float_of_sexp,
  sexp_of_t: sexp_of_t$2,
  t_sexp_grammar: Import$negBase.float_sexp_grammar,
  of_string: of_string$2,
  to_string: to_string$2
};

exports.t_sexp_grammar = t_sexp_grammar;
exports.of_float = of_float;
exports.to_float = to_float;
exports.hash_fold_t = hash_fold_t;
exports.hash = hash;
exports.t_of_sexp = t_of_sexp$1;
exports.sexp_of_t = sexp_of_t$1;
exports.of_string = of_string;
exports.$great$eq = $great$eq;
exports.$less$eq = $less$eq;
exports.$eq = $eq;
exports.$great = $great;
exports.$less = $less;
exports.$less$great = $less$great;
exports.equal = equal;
exports.compare = compare$2;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.pp = pp;
exports.hashable = hashable;
exports.is_positive = is_positive;
exports.is_non_negative = is_non_negative;
exports.is_negative = is_negative;
exports.is_non_positive = is_non_positive;
exports.invariant = invariant;
exports.nan = nan;
exports.infinity = infinity;
exports.neg_infinity = neg_infinity;
exports.max_value = max_value;
exports.min_value = min_value;
exports.zero = zero;
exports.one = one;
exports.minus_one = minus_one;
exports.pi = pi;
exports.sqrt_pi = sqrt_pi;
exports.sqrt_2pi = sqrt_2pi;
exports.euler = euler;
exports.epsilon_float = epsilon_float;
exports.max_finite_value = max_finite_value;
exports.min_positive_subnormal_value = min_positive_subnormal_value;
exports.min_positive_normal_value = min_positive_normal_value;
exports.to_int64_preserve_order = to_int64_preserve_order;
exports.to_int64_preserve_order_exn = to_int64_preserve_order_exn;
exports.of_int64_preserve_order = of_int64_preserve_order;
exports.one_ulp = one_ulp;
exports.of_int = of_int;
exports.to_int = to_int;
exports.of_int63 = of_int63;
exports.of_int64 = of_int64;
exports.to_int64 = to_int64;
exports.round = round;
exports.iround = iround;
exports.iround_exn = iround_exn;
exports.round_towards_zero = round_towards_zero;
exports.round_down = round_down;
exports.round_up = round_up;
exports.round_nearest = round_nearest;
exports.round_nearest_half_to_even = round_nearest_half_to_even;
exports.iround_towards_zero = iround_towards_zero;
exports.iround_down = iround_down;
exports.iround_up = iround_up;
exports.iround_nearest = iround_nearest;
exports.iround_towards_zero_exn = iround_towards_zero_exn;
exports.iround_down_exn = iround_down_exn;
exports.iround_up_exn = iround_up_exn;
exports.iround_nearest_exn = iround_nearest_exn;
exports.int63_round_down_exn = int63_round_down_exn;
exports.int63_round_up_exn = int63_round_up_exn;
exports.int63_round_nearest_exn = int63_round_nearest_exn;
exports.iround_lbound = iround_lbound;
exports.iround_ubound = iround_ubound;
exports.round_significant = round_significant;
exports.round_decimal = round_decimal;
exports.is_nan = is_nan;
exports.is_inf = is_inf;
exports.min_inan = min_inan;
exports.max_inan = max_inan;
exports.$plus = $plus;
exports.$neg = $neg;
exports.$slash = $slash;
exports.$star = $star;
exports.$star$star = $star$star;
exports.$tilde$neg = $tilde$neg;
exports.Parts = Parts;
exports.modf = modf;
exports.mod_float = mod_float;
exports.add = add;
exports.sub = sub;
exports.neg = neg;
exports.scale = scale;
exports.abs = abs;
exports.O = O;
exports.O_dot = O_dot;
exports.to_string = to_string;
exports.to_string_hum = to_string_hum;
exports.to_padded_compact_string = to_padded_compact_string;
exports.to_padded_compact_string_custom = to_padded_compact_string_custom;
exports.int_pow = int_pow;
exports.square = square;
exports.ldexp = ldexp;
exports.frexp = frexp;
exports.Class = Class;
exports.classify = classify;
exports.is_finite = is_finite;
exports.sign = sign;
exports.sign_exn = sign_exn;
exports.sign_or_nan = sign_or_nan;
exports.create_ieee = create_ieee;
exports.create_ieee_exn = create_ieee_exn;
exports.ieee_negative = ieee_negative;
exports.ieee_exponent = ieee_exponent;
exports.ieee_mantissa = ieee_mantissa;
exports.Terse = Terse;
exports.Private = Private;
/* include Not a pure module */
