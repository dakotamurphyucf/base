// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Hash$negBase = require("./hash.bs.js");
var Char0$negBase = require("./char0.bs.js");
var Array0$negBase = require("./array0.bs.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Import$negBase = require("./import.bs.js");
var String0$negBase = require("./string0.bs.js");
var Comparable$negBase = require("./comparable.bs.js");
var Identifiable$negBase = require("./identifiable.bs.js");

var hash = Import$negBase.hash_char;

function to_string(t) {
  return String0$negBase.make(1, t);
}

function of_string(s) {
  var match = s.length;
  if (match !== 1) {
    return Curry._2(Char0$negBase.failwithf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Char.of_string: ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "Char.of_string: %S"
                  }), s, undefined);
  } else {
    return Caml_string.get(s, 0);
  }
}

var include = Identifiable$negBase.Make({
      compare: Import$negBase.compare_char,
      hash_fold_t: Import$negBase.hash_fold_char,
      hash: hash,
      t_of_sexp: Import$negBase.char_of_sexp,
      sexp_of_t: Import$negBase.sexp_of_char,
      of_string: of_string,
      to_string: to_string,
      module_name: "Base.Char"
    });

function invariant(param) {
  
}

var all = Array0$negBase.to_list(Array0$negBase.init(256, Char0$negBase.unsafe_of_int));

function is_lowercase(param) {
  return !(param > 122 || param < 97);
}

function is_uppercase(param) {
  return !(param > 90 || param < 65);
}

function is_print(param) {
  return !(param > 126 || param < 32);
}

function is_whitespace(param) {
  if (param >= 14) {
    return param === 32;
  } else {
    return param >= 9;
  }
}

function is_digit(param) {
  return !(param > 57 || param < 48);
}

function is_alpha(param) {
  if (param >= 91) {
    return !(param > 122 || param < 97);
  } else {
    return param >= 65;
  }
}

function is_alphanum(param) {
  if (param > 90 || param < 48) {
    return !(param > 122 || param < 97);
  } else {
    return param > 64 || param < 58;
  }
}

function get_digit_unsafe(t) {
  return Import$negBase.$neg(Char0$negBase.to_int(t), Char0$negBase.to_int(/* '0' */48));
}

function get_digit_exn(t) {
  if (t > 57 || t < 48) {
    return Curry._2(Char0$negBase.failwithf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Char.get_digit_exn ",
                      _1: {
                        TAG: /* Caml_char */1,
                        _0: {
                          TAG: /* String_literal */11,
                          _0: ": not a digit",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Char.get_digit_exn %C: not a digit"
                  }), t, undefined);
  } else {
    return get_digit_unsafe(t);
  }
}

function get_digit(t) {
  if (!(t > 57 || t < 48)) {
    return get_digit_unsafe(t);
  }
  
}

var $great$eq = Import$negBase.Char_replace_polymorphic_compare.$great$eq;

var $less$eq = Import$negBase.Char_replace_polymorphic_compare.$less$eq;

var $eq = Import$negBase.Char_replace_polymorphic_compare.$eq;

var $great = Import$negBase.Char_replace_polymorphic_compare.$great;

var $less = Import$negBase.Char_replace_polymorphic_compare.$less;

var $less$great = Import$negBase.Char_replace_polymorphic_compare.$less$great;

var O = {
  $great$eq: $great$eq,
  $less$eq: $less$eq,
  $eq: $eq,
  $great: $great,
  $less: $less,
  $less$great: $less$great
};

function compare(c1, c2) {
  return Curry._2(Import$negBase.Char_replace_polymorphic_compare.compare, Char0$negBase.lowercase(c1), Char0$negBase.lowercase(c2));
}

function hash_fold_t(state, t) {
  return Import$negBase.hash_fold_char(state, Char0$negBase.lowercase(t));
}

function hash$1(t) {
  return Hash$negBase.run(undefined, hash_fold_t, t);
}

var include$1 = Comparable$negBase.Make({
      compare: compare,
      sexp_of_t: Import$negBase.sexp_of_char
    });

var t_sexp_grammar = Import$negBase.char_sexp_grammar;

var hash_fold_t$1 = include.hash_fold_t;

var hash$2 = include.hash;

var t_of_sexp = include.t_of_sexp;

var sexp_of_t = include.sexp_of_t;

var of_string$1 = include.of_string;

var to_string$1 = include.to_string;

var $great$eq$1 = Import$negBase.Char_replace_polymorphic_compare.$great$eq;

var $less$eq$1 = Import$negBase.Char_replace_polymorphic_compare.$less$eq;

var $eq$1 = Import$negBase.Char_replace_polymorphic_compare.$eq;

var $great$1 = Import$negBase.Char_replace_polymorphic_compare.$great;

var $less$1 = Import$negBase.Char_replace_polymorphic_compare.$less;

var $less$great$1 = Import$negBase.Char_replace_polymorphic_compare.$less$great;

var equal = Import$negBase.Char_replace_polymorphic_compare.equal;

var compare$1 = Import$negBase.Char_replace_polymorphic_compare.compare;

var min = Import$negBase.Char_replace_polymorphic_compare.min;

var max = Import$negBase.Char_replace_polymorphic_compare.max;

var ascending = Import$negBase.Char_replace_polymorphic_compare.ascending;

var descending = Import$negBase.Char_replace_polymorphic_compare.descending;

var between = include.between;

var clamp_exn = include.clamp_exn;

var clamp = include.clamp;

var comparator = include.comparator;

var pp = include.pp;

var hashable = include.hashable;

var to_int = Char0$negBase.to_int;

var of_int = Char0$negBase.of_int;

var of_int_exn = Char0$negBase.of_int_exn;

var unsafe_of_int = Char0$negBase.unsafe_of_int;

var escaped = Char0$negBase.escaped;

var lowercase = Char0$negBase.lowercase;

var uppercase = Char0$negBase.uppercase;

var min_value = Char0$negBase.min_value;

var max_value = Char0$negBase.max_value;

var Caseless_$great$eq = include$1.$great$eq;

var Caseless_$less$eq = include$1.$less$eq;

var Caseless_$eq = include$1.$eq;

var Caseless_$great = include$1.$great;

var Caseless_$less = include$1.$less;

var Caseless_$less$great = include$1.$less$great;

var Caseless_equal = include$1.equal;

var Caseless_compare = include$1.compare;

var Caseless_min = include$1.min;

var Caseless_max = include$1.max;

var Caseless_ascending = include$1.ascending;

var Caseless_descending = include$1.descending;

var Caseless_between = include$1.between;

var Caseless_clamp_exn = include$1.clamp_exn;

var Caseless_clamp = include$1.clamp;

var Caseless_comparator = include$1.comparator;

var Caseless = {
  hash_fold_t: hash_fold_t,
  hash: hash$1,
  t_of_sexp: Import$negBase.char_of_sexp,
  sexp_of_t: Import$negBase.sexp_of_char,
  t_sexp_grammar: Import$negBase.char_sexp_grammar,
  $great$eq: Caseless_$great$eq,
  $less$eq: Caseless_$less$eq,
  $eq: Caseless_$eq,
  $great: Caseless_$great,
  $less: Caseless_$less,
  $less$great: Caseless_$less$great,
  equal: Caseless_equal,
  compare: Caseless_compare,
  min: Caseless_min,
  max: Caseless_max,
  ascending: Caseless_ascending,
  descending: Caseless_descending,
  between: Caseless_between,
  clamp_exn: Caseless_clamp_exn,
  clamp: Caseless_clamp,
  comparator: Caseless_comparator
};

exports.all = all;
exports.t_sexp_grammar = t_sexp_grammar;
exports.hash_fold_t = hash_fold_t$1;
exports.hash = hash$2;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.of_string = of_string$1;
exports.to_string = to_string$1;
exports.$great$eq = $great$eq$1;
exports.$less$eq = $less$eq$1;
exports.$eq = $eq$1;
exports.$great = $great$1;
exports.$less = $less$1;
exports.$less$great = $less$great$1;
exports.equal = equal;
exports.compare = compare$1;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.pp = pp;
exports.hashable = hashable;
exports.invariant = invariant;
exports.O = O;
exports.to_int = to_int;
exports.of_int = of_int;
exports.of_int_exn = of_int_exn;
exports.unsafe_of_int = unsafe_of_int;
exports.escaped = escaped;
exports.lowercase = lowercase;
exports.uppercase = uppercase;
exports.is_digit = is_digit;
exports.is_lowercase = is_lowercase;
exports.is_uppercase = is_uppercase;
exports.is_alpha = is_alpha;
exports.is_alphanum = is_alphanum;
exports.is_print = is_print;
exports.is_whitespace = is_whitespace;
exports.get_digit = get_digit;
exports.get_digit_exn = get_digit_exn;
exports.min_value = min_value;
exports.max_value = max_value;
exports.Caseless = Caseless;
/* include Not a pure module */
