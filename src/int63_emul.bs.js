// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Sexp$negBase = require("./sexp.bs.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Int64$negBase = require("./int64.bs.js");
var MoreLabels = require("bs-platform/lib/js/moreLabels.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Float0$negBase = require("./float0.bs.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var String$negBase = require("./string.bs.js");
var Int_math$negBase = require("./int_math.bs.js");
var Or_error$negBase = require("./or_error.bs.js");
var Popcount$negBase = require("./popcount.bs.js");
var Comparable$negBase = require("./comparable.bs.js");
var Comparator$negBase = require("./comparator.bs.js");
var Pretty_printer$negBase = require("./pretty_printer.bs.js");
var Int_conversions$negBase = require("./int_conversions.bs.js");

var $less = Import$negBase.Int64_replace_polymorphic_compare.$less;

var $less$eq = Import$negBase.Int64_replace_polymorphic_compare.$less$eq;

var $eq = Import$negBase.Int64_replace_polymorphic_compare.$eq;

var $great = Import$negBase.Int64_replace_polymorphic_compare.$great;

var include = Comparator$negBase.Make({
      compare: Import$negBase.compare_int64,
      sexp_of_t: Import$negBase.sexp_of_int64
    });

function wrap_exn(x) {
  Int_conversions$negBase.int64_fit_on_int63_exn(x);
  return Caml_int64.mul(x, [
              0,
              2
            ]);
}

function unwrap(x) {
  return Caml_int64.asr_(x, 1);
}

var mask = [
  -1,
  4294967294
];

function invariant(t) {
  if (Curry._2($eq, Caml_int64.and_(t, mask), t)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int63_emul.ml",
          114,
          20
        ],
        Error: new Error()
      };
}

var add = Caml_int64.add;

var sub = Caml_int64.sub;

var neg = Caml_int64.neg;

var abs = Int64.abs;

var one = wrap_exn(Caml_int64.one);

function succ(a) {
  return Caml_int64.add(a, one);
}

function pred(a) {
  return Caml_int64.sub(a, one);
}

var min_value = Caml_int64.and_(Int64.min_int, mask);

var max_value = Caml_int64.and_(Int64.max_int, mask);

function bit_not(x) {
  return Caml_int64.and_(Int64.lognot(x), mask);
}

var bit_and = Caml_int64.and_;

var bit_xor = Caml_int64.xor;

var bit_or = Caml_int64.or_;

var shift_left = Caml_int64.lsl_;

function shift_right(x, i) {
  return Caml_int64.and_(Caml_int64.asr_(x, i), mask);
}

function shift_right_logical(x, i) {
  return Caml_int64.and_(Caml_int64.lsr_(x, i), mask);
}

function pow(param, param$1) {
  var f = Int_math$negBase.Private.int63_pow_on_int64;
  return Caml_int64.mul(Curry._2(f, Caml_int64.asr_(param, 1), Caml_int64.asr_(param$1, 1)), [
              0,
              2
            ]);
}

function mul(a, b) {
  return Caml_int64.mul(a, Caml_int64.asr_(b, 1));
}

function div(a, b) {
  return Caml_int64.mul(Caml_int64.div(a, b), [
              0,
              2
            ]);
}

var rem = Caml_int64.mod_;

var popcount = Popcount$negBase.int64_popcount;

function to_int64(t) {
  return Caml_int64.asr_(t, 1);
}

function of_int64(t) {
  if (Int_conversions$negBase.int64_is_representable_as_int63(t)) {
    return Caml_int64.mul(t, [
                0,
                2
              ]);
  }
  
}

var of_int64_exn = wrap_exn;

function of_int64_trunc(t) {
  return Caml_int64.mul(t, [
              0,
              2
            ]);
}

function t_of_sexp(x) {
  return wrap_exn(Import$negBase.int64_of_sexp(x));
}

function sexp_of_t(x) {
  return Import$negBase.sexp_of_int64(Caml_int64.asr_(x, 1));
}

var compare = Import$negBase.compare_int64;

function is_pow2(x) {
  return Int64$negBase.is_pow2(Caml_int64.asr_(x, 1));
}

var clz = Int64$negBase.clz;

function ctz(x) {
  return Int64$negBase.ctz(Caml_int64.asr_(x, 1));
}

function floor_pow2(x) {
  return wrap_exn(Int64$negBase.floor_pow2(Caml_int64.asr_(x, 1)));
}

function ceil_pow2(x) {
  return wrap_exn(Int64$negBase.floor_pow2(Caml_int64.asr_(x, 1)));
}

function floor_log2(x) {
  return Int64$negBase.floor_log2(Caml_int64.asr_(x, 1));
}

function ceil_log2(x) {
  return Int64$negBase.ceil_log2(Caml_int64.asr_(x, 1));
}

function hash(x) {
  return Curry._1(MoreLabels.Hashtbl.hash, x);
}

var hashable = {
  hash: hash,
  compare: compare,
  sexp_of_t: sexp_of_t
};

function invalid_str(x) {
  return Curry._2(Printf$negBase.failwithf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Int63.of_string: invalid input ",
                    _1: {
                      TAG: /* Caml_string */3,
                      _0: /* No_padding */0,
                      _1: /* End_of_format */0
                    }
                  },
                  _1: "Int63.of_string: invalid input %S"
                }), x, undefined);
}

function sign_and_signedness(x) {
  var len = x.length;
  var match;
  if (Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, 0, len)) {
    var match$1 = Caml_string.get(x, 0);
    switch (match$1) {
      case 43 :
          match = [
            1,
            "Pos"
          ];
          break;
      case 44 :
          match = [
            0,
            "Pos"
          ];
          break;
      case 45 :
          match = [
            1,
            "Neg"
          ];
          break;
      default:
        match = [
          0,
          "Pos"
        ];
    }
  } else {
    match = [
      0,
      "Pos"
    ];
  }
  var sign = match[1];
  var pos = match[0];
  if (!Curry._2(Import$negBase.Int_replace_polymorphic_compare.$less, Import$negBase.$plus(pos, 2), len)) {
    return [
            sign,
            true
          ];
  }
  var c1 = Caml_string.get(x, pos);
  var c2 = Caml_string.get(x, Import$negBase.$plus(pos, 1));
  if (c1 !== 48 || !(c2 > 57 || c2 < 48)) {
    return [
            sign,
            true
          ];
  } else {
    return [
            sign,
            false
          ];
  }
}

function to_string(x) {
  return Int64.to_string(Caml_int64.asr_(x, 1));
}

function of_string(str) {
  try {
    var match = sign_and_signedness(str);
    var sign = match[0];
    if (match[1]) {
      return wrap_exn(Caml_format.caml_int64_of_string(str));
    }
    var pos_str = sign === "Pos" ? str : String$negBase.sub(str, 1, Import$negBase.$neg(str.length, 1));
    var int64 = Caml_format.caml_int64_of_string(pos_str);
    if (Curry._2(Import$negBase.Int64_replace_polymorphic_compare.$less, int64, Caml_int64.zero)) {
      invalid_str(str);
    }
    var int63 = Caml_int64.mul(int64, [
          0,
          2
        ]);
    if (sign === "Pos") {
      return int63;
    } else {
      return Caml_int64.neg(int63);
    }
  }
  catch (exn){
    return invalid_str(str);
  }
}

var float_lower_bound = Float0$negBase.lower_bound_for_int(63);

var float_upper_bound = Float0$negBase.upper_bound_for_int(63);

var minus_one = wrap_exn(Int64.minus_one);

var one$1 = wrap_exn(Int64.one);

var zero = wrap_exn(Int64.zero);

function to_float(x) {
  return Caml_int64.to_float(Caml_int64.asr_(x, 1));
}

function of_float_unchecked(x) {
  return Caml_int64.mul(Caml_int64.of_float(x), [
              0,
              2
            ]);
}

function of_float(t) {
  if (Curry._2(Import$negBase.Float_replace_polymorphic_compare.$great$eq, t, float_lower_bound) && Curry._2(Import$negBase.Float_replace_polymorphic_compare.$less$eq, t, float_upper_bound)) {
    return Caml_int64.mul(Caml_int64.of_float(t), [
                0,
                2
              ]);
  } else {
    return Curry._2(Printf$negBase.invalid_argf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Int63.of_float: argument (",
                      _1: {
                        TAG: /* Float */8,
                        _0: [
                          /* Float_flag_ */0,
                          /* Float_f */0
                        ],
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is out of range or NaN",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Int63.of_float: argument (%f) is out of range or NaN"
                  }), Float0$negBase.box(t), undefined);
  }
}

var include$1 = Comparable$negBase.With_zero({
      compare: compare,
      sexp_of_t: sexp_of_t,
      zero: zero
    });

function between(t, low, high) {
  if (Curry._2($less$eq, low, t)) {
    return Curry._2($less$eq, t, high);
  } else {
    return false;
  }
}

function clamp_unchecked(t, min, max) {
  if (Curry._2($less, t, min)) {
    return min;
  } else if (Curry._2($less$eq, t, max)) {
    return t;
  } else {
    return max;
  }
}

function clamp_exn(t, min, max) {
  if (!Curry._2($less$eq, min, max)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "int63_emul.ml",
            320,
            2
          ],
          Error: new Error()
        };
  }
  return clamp_unchecked(t, min, max);
}

function clamp(t, min, max) {
  if (Curry._2($great, min, max)) {
    return Or_error$negBase.error_s(Sexp$negBase.message("clamp requires [min <= max]", {
                    hd: [
                      "min",
                      Import$negBase.sexp_of_int64(Caml_int64.asr_(min, 1))
                    ],
                    tl: {
                      hd: [
                        "max",
                        Import$negBase.sexp_of_int64(Caml_int64.asr_(max, 1))
                      ],
                      tl: /* [] */0
                    }
                  }));
  } else {
    return {
            TAG: /* Ok */0,
            _0: clamp_unchecked(t, min, max)
          };
  }
}

var $star$star = pow;

function incr(r) {
  r[0] = Caml_int64.add(r[0], one$1);
  
}

function decr(r) {
  r[0] = Caml_int64.sub(r[0], one$1);
  
}

function of_int(x) {
  return wrap_exn(Int_conversions$negBase.int_to_int64(x));
}

function of_int_exn(x) {
  return wrap_exn(Int_conversions$negBase.int_to_int64(x));
}

function to_int(x) {
  return Int_conversions$negBase.int64_to_int(Caml_int64.asr_(x, 1));
}

function to_int_exn(x) {
  return Int_conversions$negBase.int64_to_int_exn(Caml_int64.asr_(x, 1));
}

function to_int_trunc(x) {
  return Int_conversions$negBase.int64_to_int_trunc(Caml_int64.asr_(x, 1));
}

function of_int32(x) {
  return wrap_exn(Int_conversions$negBase.int32_to_int64(x));
}

function of_int32_exn(x) {
  return wrap_exn(Int_conversions$negBase.int32_to_int64(x));
}

function to_int32(x) {
  return Int_conversions$negBase.int64_to_int32(Caml_int64.asr_(x, 1));
}

function to_int32_exn(x) {
  return Int_conversions$negBase.int64_to_int32_exn(Caml_int64.asr_(x, 1));
}

function to_int32_trunc(x) {
  return Int_conversions$negBase.int64_to_int32_trunc(Caml_int64.asr_(x, 1));
}

function of_nativeint(x) {
  return of_int64(Int_conversions$negBase.nativeint_to_int64(x));
}

function of_nativeint_exn(x) {
  return wrap_exn(Int_conversions$negBase.nativeint_to_int64(x));
}

function of_nativeint_trunc(x) {
  return Caml_int64.mul(Int_conversions$negBase.nativeint_to_int64(x), [
              0,
              2
            ]);
}

function to_nativeint(x) {
  return Int_conversions$negBase.int64_to_nativeint(Caml_int64.asr_(x, 1));
}

function to_nativeint_exn(x) {
  return Int_conversions$negBase.int64_to_nativeint_exn(Caml_int64.asr_(x, 1));
}

function to_nativeint_trunc(x) {
  return Int_conversions$negBase.int64_to_nativeint_trunc(Caml_int64.asr_(x, 1));
}

var include$2 = Int_conversions$negBase.Make({
      to_string: to_string
    });

function hash$1(x) {
  return Curry._1(MoreLabels.Hashtbl.hash, x);
}

function to_string$1(i) {
  return Curry._1(Printf$negBase.sprintf(/* Format */{
                  _0: {
                    TAG: /* Int64 */7,
                    _0: /* Int_x */6,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: /* End_of_format */0
                  },
                  _1: "%Lx"
                }), Caml_int64.lsr_(i, 1));
}

function of_string$1(s) {
  return of_string(Import$negBase.$caret("0x", s));
}

var include$3 = Int_conversions$negBase.Make_hex({
      compare: compare,
      hash_fold_t: Import$negBase.hash_fold_int64,
      hash: hash$1,
      to_string: to_string$1,
      of_string: of_string$1,
      zero: zero,
      $less: $less,
      neg: neg,
      module_name: "Base.Int63.Hex"
    });

function to_string$2(x) {
  return Int64.to_string(Caml_int64.asr_(x, 1));
}

var include$4 = Pretty_printer$negBase.Register({
      module_name: "Base.Int63",
      to_string: to_string$2
    });

var $great$eq = Import$negBase.Int64_replace_polymorphic_compare.$great$eq;

var $less$eq$1 = Import$negBase.Int64_replace_polymorphic_compare.$less$eq;

var $eq$1 = Import$negBase.Int64_replace_polymorphic_compare.$eq;

var $great$1 = Import$negBase.Int64_replace_polymorphic_compare.$great;

var $less$1 = Import$negBase.Int64_replace_polymorphic_compare.$less;

var $less$great = Import$negBase.Int64_replace_polymorphic_compare.$less$great;

var include$5 = Int_math$negBase.Make({
      of_float: of_float,
      to_float: to_float,
      of_string: of_string,
      to_string: to_string,
      $plus: add,
      $neg: sub,
      $star: mul,
      $slash: div,
      $tilde$neg: neg,
      $great$eq: $great$eq,
      $less$eq: $less$eq$1,
      $eq: $eq$1,
      $great: $great$1,
      $less: $less$1,
      $less$great: $less$great,
      abs: abs,
      neg: neg,
      zero: zero,
      of_int_exn: of_int_exn,
      rem: rem
    });

var $percent = include$5.$percent;

var $slash$percent = include$5.$slash$percent;

var $slash$slash = include$5.$slash$slash;

var Repr = {};

var t_sexp_grammar = Import$negBase.int64_sexp_grammar;

var hash_fold_t = Import$negBase.hash_fold_int64;

var sexp_of_t$1 = include$2.sexp_of_t;

var $great$eq$1 = Import$negBase.Int64_replace_polymorphic_compare.$great$eq;

var $less$eq$2 = Import$negBase.Int64_replace_polymorphic_compare.$less$eq;

var $eq$2 = Import$negBase.Int64_replace_polymorphic_compare.$eq;

var $great$2 = Import$negBase.Int64_replace_polymorphic_compare.$great;

var $less$2 = Import$negBase.Int64_replace_polymorphic_compare.$less;

var $less$great$1 = Import$negBase.Int64_replace_polymorphic_compare.$less$great;

var equal = Import$negBase.Int64_replace_polymorphic_compare.equal;

var compare$1 = Import$negBase.Int64_replace_polymorphic_compare.compare;

var min = Import$negBase.Int64_replace_polymorphic_compare.min;

var max = Import$negBase.Int64_replace_polymorphic_compare.max;

var ascending = Import$negBase.Int64_replace_polymorphic_compare.ascending;

var descending = Import$negBase.Int64_replace_polymorphic_compare.descending;

var comparator = include.comparator;

var pp = include$4.pp;

var is_positive = include$1.is_positive;

var is_non_negative = include$1.is_non_negative;

var is_negative = include$1.is_negative;

var is_non_positive = include$1.is_non_positive;

var sign = include$1.sign;

var Hex = include$3.Hex;

var to_string_hum = include$2.to_string_hum;

var $plus = add;

var $neg = sub;

var $star = mul;

var $tilde$neg = neg;

var $slash = div;

var land = bit_and;

var lor = bit_or;

var lxor = bit_xor;

var lnot = bit_not;

var lsl = shift_left;

var asr = shift_right;

var round = include$5.round;

var round_towards_zero = include$5.round_towards_zero;

var round_down = include$5.round_down;

var round_up = include$5.round_up;

var round_nearest = include$5.round_nearest;

var num_bits = 63;

var lsr = shift_right_logical;

var O = {
  $plus: add,
  $neg: sub,
  $star: mul,
  $slash: div,
  $tilde$neg: neg,
  $star$star: $star$star,
  $great$eq: $great$eq,
  $less$eq: $less$eq$1,
  $eq: $eq$1,
  $great: $great$1,
  $less: $less$1,
  $less$great: $less$great,
  abs: abs,
  neg: neg,
  zero: zero,
  $percent: $percent,
  $slash$percent: $slash$percent,
  $slash$slash: $slash$slash,
  land: bit_and,
  lor: bit_or,
  lxor: bit_xor,
  lnot: bit_not,
  lsl: shift_left,
  asr: shift_right,
  lsr: shift_right_logical
};

var W = {
  wrap_exn: wrap_exn,
  unwrap: unwrap
};

var repr = /* Int64 */1;

exports.t_sexp_grammar = t_sexp_grammar;
exports.of_float = of_float;
exports.to_float = to_float;
exports.of_int_exn = of_int_exn;
exports.to_int_exn = to_int_exn;
exports.hash_fold_t = hash_fold_t;
exports.hash = hash;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t$1;
exports.of_string = of_string;
exports.to_string = to_string;
exports.$great$eq = $great$eq$1;
exports.$less$eq = $less$eq$2;
exports.$eq = $eq$2;
exports.$great = $great$2;
exports.$less = $less$2;
exports.$less$great = $less$great$1;
exports.equal = equal;
exports.compare = compare$1;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.pp = pp;
exports.hashable = hashable;
exports.is_positive = is_positive;
exports.is_non_negative = is_non_negative;
exports.is_negative = is_negative;
exports.is_non_positive = is_non_positive;
exports.sign = sign;
exports.invariant = invariant;
exports.Hex = Hex;
exports.to_string_hum = to_string_hum;
exports.zero = zero;
exports.one = one$1;
exports.minus_one = minus_one;
exports.$plus = $plus;
exports.$neg = $neg;
exports.$star = $star;
exports.$star$star = $star$star;
exports.neg = neg;
exports.$tilde$neg = $tilde$neg;
exports.$slash$percent = $slash$percent;
exports.$percent = $percent;
exports.$slash = $slash;
exports.rem = rem;
exports.$slash$slash = $slash$slash;
exports.land = land;
exports.lor = lor;
exports.lxor = lxor;
exports.lnot = lnot;
exports.lsl = lsl;
exports.asr = asr;
exports.round = round;
exports.round_towards_zero = round_towards_zero;
exports.round_down = round_down;
exports.round_up = round_up;
exports.round_nearest = round_nearest;
exports.abs = abs;
exports.succ = succ;
exports.pred = pred;
exports.pow = pow;
exports.bit_and = bit_and;
exports.bit_or = bit_or;
exports.bit_xor = bit_xor;
exports.bit_not = bit_not;
exports.popcount = popcount;
exports.shift_left = shift_left;
exports.shift_right = shift_right;
exports.decr = decr;
exports.incr = incr;
exports.of_int32_exn = of_int32_exn;
exports.to_int32_exn = to_int32_exn;
exports.of_int64_exn = of_int64_exn;
exports.to_int64 = to_int64;
exports.of_nativeint_exn = of_nativeint_exn;
exports.to_nativeint_exn = to_nativeint_exn;
exports.of_float_unchecked = of_float_unchecked;
exports.num_bits = num_bits;
exports.max_value = max_value;
exports.min_value = min_value;
exports.lsr = lsr;
exports.shift_right_logical = shift_right_logical;
exports.ceil_pow2 = ceil_pow2;
exports.floor_pow2 = floor_pow2;
exports.ceil_log2 = ceil_log2;
exports.floor_log2 = floor_log2;
exports.is_pow2 = is_pow2;
exports.clz = clz;
exports.ctz = ctz;
exports.O = O;
exports.of_int = of_int;
exports.to_int = to_int;
exports.to_int_trunc = to_int_trunc;
exports.of_int32 = of_int32;
exports.to_int32 = to_int32;
exports.to_int32_trunc = to_int32_trunc;
exports.of_int64 = of_int64;
exports.of_int64_trunc = of_int64_trunc;
exports.of_nativeint = of_nativeint;
exports.to_nativeint = to_nativeint;
exports.of_nativeint_trunc = of_nativeint_trunc;
exports.to_nativeint_trunc = to_nativeint_trunc;
exports.W = W;
exports.Repr = Repr;
exports.repr = repr;
/* include Not a pure module */
