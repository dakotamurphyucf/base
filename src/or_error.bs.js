// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var List$negBase = require("./list.bs.js");
var Error$negBase = require("./error.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Result$negBase = require("./result.bs.js");
var Applicative$negBase = require("./applicative.bs.js");
var With_return$negBase = require("./with_return.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function compare(_cmp__a, a__001_, b__002_) {
  return Result$negBase.compare(_cmp__a, Error$negBase.compare, a__001_, b__002_);
}

function equal(_cmp__a, a__007_, b__008_) {
  return Result$negBase.equal(_cmp__a, Error$negBase.equal, a__007_, b__008_);
}

function hash_fold_t(_hash_fold_a, hsv, arg) {
  return Result$negBase.hash_fold_t(_hash_fold_a, Error$negBase.hash_fold_t, hsv, arg);
}

function t_of_sexp(_of_a, t) {
  return Result$negBase.t_of_sexp(_of_a, Error$negBase.t_of_sexp, t);
}

function sexp_of_t(_of_a, v) {
  return Result$negBase.sexp_of_t(_of_a, Error$negBase.sexp_of_t, v);
}

function t_sexp_grammar(_$pa_sexp_grammar) {
  return Result$negBase.t_sexp_grammar(_$pa_sexp_grammar, Error$negBase.t_sexp_grammar);
}

function invariant(invariant_a, t) {
  if (t.TAG === /* Ok */0) {
    return Curry._1(invariant_a, t._0);
  } else {
    return Error$negBase.invariant(t._0);
  }
}

function apply(f, x) {
  return Result$negBase.combine(f, x, (function (f, x) {
                return Curry._1(f, x);
              }), (function (e1, e2) {
                return Error$negBase.of_list(undefined, {
                            hd: e1,
                            tl: {
                              hd: e2,
                              tl: /* [] */0
                            }
                          });
              }));
}

var map = {
  NAME: "Custom",
  VAL: Result$negBase.map
};

var include = Applicative$negBase.Make({
      $$return: Result$negBase.$$return,
      apply: apply,
      map: map
    });

var $$return = include.$$return;

var both = include.both;

var Open_on_rhs = {};

function try_with(backtraceOpt, f) {
  var backtrace = backtraceOpt !== undefined ? backtraceOpt : false;
  try {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, undefined)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: /* Error */1,
            _0: Error$negBase.of_exn(backtrace ? "Get" : undefined, exn)
          };
  }
}

function try_with_join(backtrace, f) {
  return Curry._1(Result$negBase.join, try_with(backtrace, f));
}

function ok_exn(x) {
  if (x.TAG === /* Ok */0) {
    return x._0;
  } else {
    return Error$negBase.raise(x._0);
  }
}

function of_exn(backtrace, exn) {
  return {
          TAG: /* Error */1,
          _0: Error$negBase.of_exn(backtrace, exn)
        };
}

function of_exn_result(backtrace, z) {
  if (z.TAG === /* Ok */0) {
    return z;
  } else {
    return {
            TAG: /* Error */1,
            _0: Error$negBase.of_exn(backtrace, z._0)
          };
  }
}

function error(here, strict, message, a, sexp_of_a) {
  return {
          TAG: /* Error */1,
          _0: Error$negBase.create(here, strict, message, a, sexp_of_a)
        };
}

function error_s(sexp) {
  return {
          TAG: /* Error */1,
          _0: Error$negBase.create_s(sexp)
        };
}

function error_string(message) {
  return {
          TAG: /* Error */1,
          _0: Error$negBase.of_string(message)
        };
}

function errorf(format) {
  return Printf$negBase.ksprintf(error_string, format);
}

function tag(t, tag$1) {
  return Result$negBase.map_error(t, (function (param) {
                return Error$negBase.tag(param, tag$1);
              }));
}

function tag_s(t, tag) {
  return Result$negBase.map_error(t, (function (param) {
                return Error$negBase.tag_s(param, tag);
              }));
}

function tag_arg(t, message, a, sexp_of_a) {
  return Result$negBase.map_error(t, (function (e) {
                return Error$negBase.tag_arg(e, message, a, sexp_of_a);
              }));
}

function unimplemented(s) {
  return error(undefined, undefined, "unimplemented", s, Import$negBase.sexp_of_string);
}

function combine_errors(l) {
  return Result$negBase.map_error(Result$negBase.combine_errors(l), (function (eta) {
                return Error$negBase.of_list(undefined, eta);
              }));
}

function combine_errors_unit(l) {
  return Curry._2(Result$negBase.map, combine_errors(l), (function (param) {
                
              }));
}

function filter_ok_at_least_one(l) {
  var match = List$negBase.partition_map(l, Result$negBase.to_either);
  var ok = match[0];
  if (ok) {
    return {
            TAG: /* Ok */0,
            _0: ok
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Error$negBase.of_list(undefined, match[1])
          };
  }
}

function find_ok(l) {
  var x = List$negBase.find_map(l, Result$negBase.ok);
  if (x !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(x)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Error$negBase.of_list(undefined, List$negBase.map(l, (function (err) {
                        if (err.TAG !== /* Ok */0) {
                          return err._0;
                        }
                        throw {
                              RE_EXN_ID: "Assert_failure",
                              _1: [
                                "or_error.ml",
                                128,
                                22
                              ],
                              Error: new Error()
                            };
                      })))
          };
  }
}

function find_map_ok(l, f) {
  return With_return$negBase.with_return(function (param) {
              return {
                      TAG: /* Error */1,
                      _0: Error$negBase.of_list(undefined, List$negBase.map(l, (function (elt) {
                                  var x = Curry._1(f, elt);
                                  if (x.TAG === /* Ok */0) {
                                    return Curry._1(param, x);
                                  } else {
                                    return x._0;
                                  }
                                })))
                    };
            });
}

var $less$star$great = include.$less$star$great;

var $less$star = include.$less$star;

var $star$great = include.$star$great;

var apply$1 = include.apply;

var map2 = include.map2;

var map3 = include.map3;

var Applicative_infix = include.Applicative_infix;

var $great$great$eq = Result$negBase.$great$great$eq;

var $great$great$pipe = include.$great$great$pipe;

var Monad_infix = Result$negBase.Monad_infix;

var bind = Result$negBase.bind;

var join = Result$negBase.join;

var ignore_m = Result$negBase.ignore_m;

var all = include.all;

var all_unit = include.all_unit;

var Let_syntax_$great$great$eq = Result$negBase.Monad_infix.$great$great$eq;

var Let_syntax_$great$great$pipe = Result$negBase.Monad_infix.$great$great$pipe;

var Let_syntax_Let_syntax = {
  $$return: $$return,
  bind: Result$negBase.bind,
  map: include.map,
  both: both,
  Open_on_rhs: Open_on_rhs
};

var Let_syntax = {
  $$return: $$return,
  $great$great$eq: Let_syntax_$great$great$eq,
  $great$great$pipe: Let_syntax_$great$great$pipe,
  Let_syntax: Let_syntax_Let_syntax
};

var is_ok = Result$negBase.is_ok;

var is_error = Result$negBase.is_error;

var ok = Result$negBase.ok;

var map$1 = Result$negBase.map;

var iter = Result$negBase.iter;

var iter_error = Result$negBase.iter_error;

exports.compare = compare;
exports.equal = equal;
exports.hash_fold_t = hash_fold_t;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.both = both;
exports.$less$star$great = $less$star$great;
exports.$less$star = $less$star;
exports.$star$great = $star$great;
exports.apply = apply$1;
exports.map2 = map2;
exports.map3 = map3;
exports.Applicative_infix = Applicative_infix;
exports.invariant = invariant;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.Monad_infix = Monad_infix;
exports.bind = bind;
exports.$$return = $$return;
exports.join = join;
exports.ignore_m = ignore_m;
exports.all = all;
exports.all_unit = all_unit;
exports.Let_syntax = Let_syntax;
exports.is_ok = is_ok;
exports.is_error = is_error;
exports.try_with = try_with;
exports.try_with_join = try_with_join;
exports.ok = ok;
exports.ok_exn = ok_exn;
exports.of_exn = of_exn;
exports.of_exn_result = of_exn_result;
exports.error = error;
exports.error_s = error_s;
exports.error_string = error_string;
exports.errorf = errorf;
exports.tag = tag;
exports.tag_s = tag_s;
exports.tag_arg = tag_arg;
exports.unimplemented = unimplemented;
exports.map = map$1;
exports.iter = iter;
exports.iter_error = iter_error;
exports.combine_errors = combine_errors;
exports.combine_errors_unit = combine_errors_unit;
exports.filter_ok_at_least_one = filter_ok_at_least_one;
exports.find_ok = find_ok;
exports.find_map_ok = find_map_ok;
/* include Not a pure module */
