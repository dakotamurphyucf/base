// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Container$negBase = require("./container.bs.js");
var With_return$negBase = require("./with_return.bs.js");

function iteri(fold, t, f) {
  Curry._3(fold, t, 0, (function (i, x) {
          Curry._2(f, i, x);
          return i + 1 | 0;
        }));
  
}

function foldi(fold, t, init, f) {
  var i = {
    contents: 0
  };
  return Curry._3(fold, t, init, (function (acc, v) {
                var acc$1 = Curry._3(f, i.contents, acc, v);
                i.contents = i.contents + 1 | 0;
                return acc$1;
              }));
}

function counti(foldi, t, f) {
  return Curry._3(foldi, t, 0, (function (i, n, a) {
                if (Curry._2(f, i, a)) {
                  return n + 1 | 0;
                } else {
                  return n;
                }
              }));
}

function existsi(iteri, c, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iteri, c, (function (i, x) {
                      if (Curry._2(f, i, x)) {
                        return Curry._1(r, true);
                      }
                      
                    }));
              return false;
            });
}

function for_alli(iteri, c, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iteri, c, (function (i, x) {
                      if (!Curry._2(f, i, x)) {
                        return Curry._1(r, false);
                      }
                      
                    }));
              return true;
            });
}

function find_mapi(iteri, t, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iteri, t, (function (i, x) {
                      var res = Curry._2(f, i, x);
                      if (res !== undefined) {
                        return Curry._1(r, res);
                      }
                      
                    }));
              
            });
}

function findi(iteri, c, f) {
  return With_return$negBase.with_return(function (r) {
              Curry._2(iteri, c, (function (i, x) {
                      if (Curry._2(f, i, x)) {
                        return Curry._1(r, [
                                    i,
                                    x
                                  ]);
                      }
                      
                    }));
              
            });
}

function Make(funarg) {
  var C = Container$negBase.Make(funarg);
  var iteri$1 = funarg.iteri;
  var foldi$1 = funarg.foldi;
  var T_fold = funarg.fold;
  var T_iter = funarg.iter;
  var T_length = funarg.length;
  var T = {
    fold: T_fold,
    iter: T_iter,
    length: T_length,
    iteri: iteri$1,
    foldi: foldi$1
  };
  var include = Container$negBase.Make_gen(T);
  var fold = include.fold;
  var iteri$2 = typeof iteri$1 === "string" ? (function (t, f) {
        return iteri(fold, t, f);
      }) : iteri$1.VAL;
  var foldi$2 = typeof foldi$1 === "string" ? (function (t, init, f) {
        return foldi(fold, t, init, f);
      }) : foldi$1.VAL;
  var counti$1 = function (t, f) {
    return counti(foldi$2, t, f);
  };
  var existsi$1 = function (t, f) {
    return existsi(iteri$2, t, f);
  };
  var for_alli$1 = function (t, f) {
    return for_alli(iteri$2, t, f);
  };
  var find_mapi$1 = function (t, f) {
    return find_mapi(iteri$2, t, f);
  };
  var findi$1 = function (t, f) {
    return findi(iteri$2, t, f);
  };
  return {
          mem: C.mem,
          length: include.length,
          is_empty: include.is_empty,
          iter: include.iter,
          fold: fold,
          fold_result: include.fold_result,
          fold_until: include.fold_until,
          exists: include.exists,
          for_all: include.for_all,
          count: include.count,
          sum: include.sum,
          find: include.find,
          find_map: include.find_map,
          to_list: include.to_list,
          to_array: include.to_array,
          min_elt: include.min_elt,
          max_elt: include.max_elt,
          foldi: foldi$2,
          iteri: iteri$2,
          existsi: existsi$1,
          for_alli: for_alli$1,
          counti: counti$1,
          findi: findi$1,
          find_mapi: find_mapi$1
        };
}

function Make0(funarg) {
  var C = Container$negBase.Make0(funarg);
  var iteri$1 = funarg.iteri;
  var foldi$1 = funarg.foldi;
  var T_fold = funarg.fold;
  var T_iter = funarg.iter;
  var T_length = funarg.length;
  var T = {
    fold: T_fold,
    iter: T_iter,
    length: T_length,
    iteri: iteri$1,
    foldi: foldi$1
  };
  var include = Container$negBase.Make_gen(T);
  var fold = include.fold;
  var iteri$2 = typeof iteri$1 === "string" ? (function (t, f) {
        return iteri(fold, t, f);
      }) : iteri$1.VAL;
  var foldi$2 = typeof foldi$1 === "string" ? (function (t, init, f) {
        return foldi(fold, t, init, f);
      }) : foldi$1.VAL;
  var counti$1 = function (t, f) {
    return counti(foldi$2, t, f);
  };
  var existsi$1 = function (t, f) {
    return existsi(iteri$2, t, f);
  };
  var for_alli$1 = function (t, f) {
    return for_alli(iteri$2, t, f);
  };
  var find_mapi$1 = function (t, f) {
    return find_mapi(iteri$2, t, f);
  };
  var findi$1 = function (t, f) {
    return findi(iteri$2, t, f);
  };
  return {
          mem: C.mem,
          length: include.length,
          is_empty: include.is_empty,
          iter: include.iter,
          fold: fold,
          fold_result: include.fold_result,
          fold_until: include.fold_until,
          exists: include.exists,
          for_all: include.for_all,
          count: include.count,
          sum: include.sum,
          find: include.find,
          find_map: include.find_map,
          to_list: include.to_list,
          to_array: include.to_array,
          min_elt: include.min_elt,
          max_elt: include.max_elt,
          foldi: foldi$2,
          iteri: iteri$2,
          existsi: existsi$1,
          for_alli: for_alli$1,
          counti: counti$1,
          findi: findi$1,
          find_mapi: find_mapi$1
        };
}

exports.foldi = foldi;
exports.iteri = iteri;
exports.counti = counti;
exports.existsi = existsi;
exports.for_alli = for_alli;
exports.findi = findi;
exports.find_mapi = find_mapi;
exports.Make = Make;
exports.Make0 = Make0;
/* Container-Base Not a pure module */
