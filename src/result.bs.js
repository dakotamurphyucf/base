// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Hash$negBase = require("./hash.bs.js");
var List1$negBase = require("./list1.bs.js");
var Monad$negBase = require("./monad.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Printf$negBase = require("./printf.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Ppx_compare_lib$negBase = require("./ppx_compare_lib.bs.js");
var Sexp_conv_error$negSexplib0 = require("sexplib0/./sexp_conv_error.bs.js");

var _tp_loc = "result.ml.t";

function t_of_sexp(_of_a, _of_b, _sexp) {
  if (_sexp.TAG === /* Atom */0) {
    switch (_sexp._0) {
      case "Error" :
      case "Ok" :
      case "error" :
      case "ok" :
          return Sexp_conv_error$negSexplib0.stag_takes_args(_tp_loc, _sexp);
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, _sexp);
    }
  } else {
    var match = _sexp._0;
    if (!match) {
      return Sexp_conv_error$negSexplib0.empty_list_invalid_sum(_tp_loc, _sexp);
    }
    var _tag = match.hd;
    if (_tag.TAG !== /* Atom */0) {
      return Sexp_conv_error$negSexplib0.nested_list_invalid_sum(_tp_loc, _sexp);
    }
    var _tag$1 = _tag._0;
    var exit = 0;
    switch (_tag$1) {
      case "Error" :
      case "error" :
          exit = 2;
          break;
      case "Ok" :
      case "ok" :
          exit = 1;
          break;
      default:
        return Sexp_conv_error$negSexplib0.unexpected_stag(_tp_loc, _sexp);
    }
    switch (exit) {
      case 1 :
          var sexp_args = match.tl;
          if (!sexp_args) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          if (sexp_args.tl) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var v0 = Curry._1(_of_a, sexp_args.hd);
          return {
                  TAG: /* Ok */0,
                  _0: v0
                };
      case 2 :
          var sexp_args$1 = match.tl;
          if (!sexp_args$1) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          if (sexp_args$1.tl) {
            return Sexp_conv_error$negSexplib0.stag_incorrect_n_args(_tp_loc, _tag$1, _sexp);
          }
          var v0$1 = Curry._1(_of_b, sexp_args$1.hd);
          return {
                  TAG: /* Error */1,
                  _0: v0$1
                };
      
    }
  }
}

function sexp_of_t(_of_a, _of_b, v0) {
  if (v0.TAG === /* Ok */0) {
    var v0$1 = Curry._1(_of_a, v0._0);
    return {
            TAG: /* List */1,
            _0: {
              hd: {
                TAG: /* Atom */0,
                _0: "Ok"
              },
              tl: {
                hd: v0$1,
                tl: /* [] */0
              }
            }
          };
  }
  var v0$2 = Curry._1(_of_b, v0._0);
  return {
          TAG: /* List */1,
          _0: {
            hd: {
              TAG: /* Atom */0,
              _0: "Error"
            },
            tl: {
              hd: v0$2,
              tl: /* [] */0
            }
          }
        };
}

function t_sexp_grammar(_$pa_sexp_grammar, _$pb_sexp_grammar) {
  return {
          TAG: /* Variant */4,
          _0: {
            name_kind: /* Capitalized */1,
            clauses: {
              hd: {
                name: "Ok",
                args: {
                  TAG: /* Cons */0,
                  _0: _$pa_sexp_grammar,
                  _1: /* Empty */0
                }
              },
              tl: {
                hd: {
                  name: "Error",
                  args: {
                    TAG: /* Cons */0,
                    _0: _$pb_sexp_grammar,
                    _1: /* Empty */0
                  }
                },
                tl: /* [] */0
              }
            }
          }
        };
}

function compare(_cmp__a, _cmp__b, a__001_, b__002_) {
  if (Ppx_compare_lib$negBase.phys_equal(a__001_, b__002_)) {
    return 0;
  } else if (a__001_.TAG === /* Ok */0) {
    if (b__002_.TAG === /* Ok */0) {
      return Curry._2(_cmp__a, a__001_._0, b__002_._0);
    } else {
      return -1;
    }
  } else if (b__002_.TAG === /* Ok */0) {
    return 1;
  } else {
    return Curry._2(_cmp__b, a__001_._0, b__002_._0);
  }
}

function equal(_cmp__a, _cmp__b, a__007_, b__008_) {
  if (Ppx_compare_lib$negBase.phys_equal(a__007_, b__008_)) {
    return true;
  } else if (a__007_.TAG === /* Ok */0) {
    if (b__008_.TAG === /* Ok */0) {
      return Curry._2(_cmp__a, a__007_._0, b__008_._0);
    } else {
      return false;
    }
  } else if (b__008_.TAG === /* Ok */0) {
    return false;
  } else {
    return Curry._2(_cmp__b, a__007_._0, b__008_._0);
  }
}

function hash_fold_t(_hash_fold_a, _hash_fold_b, hsv, arg) {
  if (arg.TAG === /* Ok */0) {
    var hsv$1 = Hash$negBase.fold_int(hsv, 0);
    return Curry._2(_hash_fold_a, hsv$1, arg._0);
  }
  var hsv$2 = Hash$negBase.fold_int(hsv, 1);
  return Curry._2(_hash_fold_b, hsv$2, arg._0);
}

function bind(x, f) {
  if (x.TAG === /* Ok */0) {
    return Curry._1(f, x._0);
  } else {
    return x;
  }
}

function map(x, f) {
  if (x.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, x._0)
          };
  } else {
    return x;
  }
}

var map$1 = {
  NAME: "Custom",
  VAL: map
};

function $$return(x) {
  return {
          TAG: /* Ok */0,
          _0: x
        };
}

var include = Monad$negBase.Make2({
      bind: bind,
      map: map$1,
      $$return: $$return
    });

var map$2 = include.map;

function invariant(check_ok, check_error, t) {
  if (t.TAG === /* Ok */0) {
    return Curry._1(check_ok, t._0);
  } else {
    return Curry._1(check_error, t._0);
  }
}

function fail(x) {
  return {
          TAG: /* Error */1,
          _0: x
        };
}

function failf(format) {
  return Printf$negBase.ksprintf(fail, format);
}

function map_error(t, f) {
  if (t.TAG === /* Ok */0) {
    return t;
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(f, t._0)
          };
  }
}

function is_ok(param) {
  if (param.TAG === /* Ok */0) {
    return true;
  } else {
    return false;
  }
}

function is_error(param) {
  if (param.TAG === /* Ok */0) {
    return false;
  } else {
    return true;
  }
}

function ok(x) {
  if (x.TAG === /* Ok */0) {
    return Caml_option.some(x._0);
  }
  
}

function error(x) {
  if (x.TAG === /* Ok */0) {
    return ;
  } else {
    return Caml_option.some(x._0);
  }
}

function of_option(opt, error) {
  if (opt !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(opt)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: error
          };
  }
}

function iter(v, f) {
  if (v.TAG === /* Ok */0) {
    return Curry._1(f, v._0);
  }
  
}

function iter_error(v, f) {
  if (v.TAG === /* Ok */0) {
    return ;
  } else {
    return Curry._1(f, v._0);
  }
}

function to_either(x) {
  if (x.TAG === /* Ok */0) {
    return {
            TAG: /* First */0,
            _0: x._0
          };
  } else {
    return {
            TAG: /* Second */1,
            _0: x._0
          };
  }
}

function of_either(x) {
  if (x.TAG === /* First */0) {
    return {
            TAG: /* Ok */0,
            _0: x._0
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: x._0
          };
  }
}

function ok_if_true(bool, error) {
  if (bool) {
    return {
            TAG: /* Ok */0,
            _0: undefined
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: error
          };
  }
}

function try_with(f) {
  try {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, undefined)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: /* Error */1,
            _0: exn
          };
  }
}

function ok_exn(x) {
  if (x.TAG === /* Ok */0) {
    return x._0;
  }
  throw x._0;
}

function ok_or_failwith(x) {
  if (x.TAG === /* Ok */0) {
    return x._0;
  } else {
    return Import$negBase.failwith(x._0);
  }
}

function combine(t1, t2, ok, err) {
  if (t1.TAG === /* Ok */0) {
    if (t2.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(ok, t1._0, t2._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: t2._0
            };
    }
  }
  var err1 = t1._0;
  if (t2.TAG === /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: err1
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._2(err, err1, t2._0)
          };
  }
}

function combine_errors(l) {
  var match = List1$negBase.partition_map(l, to_either);
  var errs = match[1];
  if (errs) {
    return {
            TAG: /* Error */1,
            _0: errs
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: match[0]
          };
  }
}

function combine_errors_unit(l) {
  return Curry._2(map$2, combine_errors(l), (function (param) {
                
              }));
}

var $great$great$eq = include.$great$great$eq;

var $great$great$pipe = include.$great$great$pipe;

var Let_syntax = include.Let_syntax;

var Monad_infix = include.Monad_infix;

var bind$1 = include.bind;

var $$return$1 = include.$$return;

var join = include.join;

var ignore_m = include.ignore_m;

var all = include.all;

var all_unit = include.all_unit;

var ok_fst = to_either;

var Export = {
  is_ok: is_ok,
  is_error: is_error
};

exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.t_sexp_grammar = t_sexp_grammar;
exports.compare = compare;
exports.equal = equal;
exports.hash_fold_t = hash_fold_t;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.Let_syntax = Let_syntax;
exports.Monad_infix = Monad_infix;
exports.bind = bind$1;
exports.$$return = $$return$1;
exports.join = join;
exports.ignore_m = ignore_m;
exports.all = all;
exports.all_unit = all_unit;
exports.invariant = invariant;
exports.fail = fail;
exports.failf = failf;
exports.is_ok = is_ok;
exports.is_error = is_error;
exports.ok = ok;
exports.ok_exn = ok_exn;
exports.ok_or_failwith = ok_or_failwith;
exports.error = error;
exports.of_option = of_option;
exports.iter = iter;
exports.iter_error = iter_error;
exports.map = map$2;
exports.map_error = map_error;
exports.combine = combine;
exports.combine_errors = combine_errors;
exports.combine_errors_unit = combine_errors_unit;
exports.to_either = to_either;
exports.of_either = of_either;
exports.ok_fst = ok_fst;
exports.ok_if_true = ok_if_true;
exports.try_with = try_with;
exports.Export = Export;
/* include Not a pure module */
