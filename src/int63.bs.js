// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Int$negBase = require("./int.bs.js");
var Bool$negBase = require("./bool.bs.js");
var Sexp$negBase = require("./sexp.bs.js");
var Error$negBase = require("./error.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Import$negBase = require("./import.bs.js");
var Random$negBase = require("./random.bs.js");
var Word_size$negBase = require("./word_size.bs.js");
var Int63_emul$negBase = require("./int63_emul.bs.js");

var repr = Word_size$negBase.word_size ? /* Immediate */0 : /* Non_immediate */1;

var include = {
  repr: repr
};

function to_int(x) {
  return Caml_option.some(x);
}

function to_int_trunc(x) {
  return x;
}

var to_nativeint_trunc = Int$negBase.to_nativeint;

function to_nativeint(x) {
  return Int$negBase.to_nativeint(x);
}

var impl = include.repr ? ({
      t_sexp_grammar: Int63_emul$negBase.t_sexp_grammar,
      of_float: Int63_emul$negBase.of_float,
      to_float: Int63_emul$negBase.to_float,
      of_int_exn: Int63_emul$negBase.of_int_exn,
      to_int_exn: Int63_emul$negBase.to_int_exn,
      hash_fold_t: Int63_emul$negBase.hash_fold_t,
      hash: Int63_emul$negBase.hash,
      t_of_sexp: Int63_emul$negBase.t_of_sexp,
      sexp_of_t: Int63_emul$negBase.sexp_of_t,
      of_string: Int63_emul$negBase.of_string,
      to_string: Int63_emul$negBase.to_string,
      $great$eq: Int63_emul$negBase.$great$eq,
      $less$eq: Int63_emul$negBase.$less$eq,
      $eq: Int63_emul$negBase.$eq,
      $great: Int63_emul$negBase.$great,
      $less: Int63_emul$negBase.$less,
      $less$great: Int63_emul$negBase.$less$great,
      equal: Int63_emul$negBase.equal,
      compare: Int63_emul$negBase.compare,
      min: Int63_emul$negBase.min,
      max: Int63_emul$negBase.max,
      ascending: Int63_emul$negBase.ascending,
      descending: Int63_emul$negBase.descending,
      between: Int63_emul$negBase.between,
      clamp_exn: Int63_emul$negBase.clamp_exn,
      clamp: Int63_emul$negBase.clamp,
      comparator: Int63_emul$negBase.comparator,
      pp: Int63_emul$negBase.pp,
      hashable: Int63_emul$negBase.hashable,
      is_positive: Int63_emul$negBase.is_positive,
      is_non_negative: Int63_emul$negBase.is_non_negative,
      is_negative: Int63_emul$negBase.is_negative,
      is_non_positive: Int63_emul$negBase.is_non_positive,
      sign: Int63_emul$negBase.sign,
      invariant: Int63_emul$negBase.invariant,
      Hex: Int63_emul$negBase.Hex,
      to_string_hum: Int63_emul$negBase.to_string_hum,
      zero: Int63_emul$negBase.zero,
      one: Int63_emul$negBase.one,
      minus_one: Int63_emul$negBase.minus_one,
      $plus: Int63_emul$negBase.$plus,
      $neg: Int63_emul$negBase.$neg,
      $star: Int63_emul$negBase.$star,
      $star$star: Int63_emul$negBase.$star$star,
      neg: Int63_emul$negBase.neg,
      $tilde$neg: Int63_emul$negBase.$tilde$neg,
      $slash$percent: Int63_emul$negBase.$slash$percent,
      $percent: Int63_emul$negBase.$percent,
      $slash: Int63_emul$negBase.$slash,
      rem: Int63_emul$negBase.rem,
      $slash$slash: Int63_emul$negBase.$slash$slash,
      land: Int63_emul$negBase.land,
      lor: Int63_emul$negBase.lor,
      lxor: Int63_emul$negBase.lxor,
      lnot: Int63_emul$negBase.lnot,
      lsl: Int63_emul$negBase.lsl,
      asr: Int63_emul$negBase.asr,
      round: Int63_emul$negBase.round,
      round_towards_zero: Int63_emul$negBase.round_towards_zero,
      round_down: Int63_emul$negBase.round_down,
      round_up: Int63_emul$negBase.round_up,
      round_nearest: Int63_emul$negBase.round_nearest,
      abs: Int63_emul$negBase.abs,
      succ: Int63_emul$negBase.succ,
      pred: Int63_emul$negBase.pred,
      pow: Int63_emul$negBase.pow,
      bit_and: Int63_emul$negBase.bit_and,
      bit_or: Int63_emul$negBase.bit_or,
      bit_xor: Int63_emul$negBase.bit_xor,
      bit_not: Int63_emul$negBase.bit_not,
      popcount: Int63_emul$negBase.popcount,
      shift_left: Int63_emul$negBase.shift_left,
      shift_right: Int63_emul$negBase.shift_right,
      decr: Int63_emul$negBase.decr,
      incr: Int63_emul$negBase.incr,
      of_int32_exn: Int63_emul$negBase.of_int32_exn,
      to_int32_exn: Int63_emul$negBase.to_int32_exn,
      of_int64_exn: Int63_emul$negBase.of_int64_exn,
      to_int64: Int63_emul$negBase.to_int64,
      of_nativeint_exn: Int63_emul$negBase.of_nativeint_exn,
      to_nativeint_exn: Int63_emul$negBase.to_nativeint_exn,
      num_bits: Int63_emul$negBase.num_bits,
      max_value: Int63_emul$negBase.max_value,
      min_value: Int63_emul$negBase.min_value,
      lsr: Int63_emul$negBase.lsr,
      shift_right_logical: Int63_emul$negBase.shift_right_logical,
      ceil_pow2: Int63_emul$negBase.ceil_pow2,
      floor_pow2: Int63_emul$negBase.floor_pow2,
      ceil_log2: Int63_emul$negBase.ceil_log2,
      floor_log2: Int63_emul$negBase.floor_log2,
      is_pow2: Int63_emul$negBase.is_pow2,
      clz: Int63_emul$negBase.clz,
      ctz: Int63_emul$negBase.ctz,
      O: Int63_emul$negBase.O,
      of_int: Int63_emul$negBase.of_int,
      to_int: Int63_emul$negBase.to_int,
      to_int_trunc: Int63_emul$negBase.to_int_trunc,
      of_int32: Int63_emul$negBase.of_int32,
      to_int32: Int63_emul$negBase.to_int32,
      to_int32_trunc: Int63_emul$negBase.to_int32_trunc,
      of_int64: Int63_emul$negBase.of_int64,
      of_int64_trunc: Int63_emul$negBase.of_int64_trunc,
      of_nativeint: Int63_emul$negBase.of_nativeint,
      to_nativeint: Int63_emul$negBase.to_nativeint,
      of_nativeint_trunc: Int63_emul$negBase.of_nativeint_trunc,
      to_nativeint_trunc: Int63_emul$negBase.to_nativeint_trunc,
      of_float_unchecked: Int63_emul$negBase.of_float_unchecked,
      repr: Int63_emul$negBase.repr
    }) : ({
      t_sexp_grammar: Int$negBase.t_sexp_grammar,
      of_float: Int$negBase.of_float,
      to_float: Int$negBase.to_float,
      of_int_exn: Int$negBase.of_int_exn,
      to_int_exn: Int$negBase.to_int_exn,
      hash_fold_t: Int$negBase.hash_fold_t,
      hash: Int$negBase.hash,
      t_of_sexp: Int$negBase.t_of_sexp,
      sexp_of_t: Int$negBase.sexp_of_t,
      of_string: Int$negBase.of_string,
      to_string: Int$negBase.to_string,
      $great$eq: Int$negBase.$great$eq,
      $less$eq: Int$negBase.$less$eq,
      $eq: Int$negBase.$eq,
      $great: Int$negBase.$great,
      $less: Int$negBase.$less,
      $less$great: Int$negBase.$less$great,
      equal: Int$negBase.equal,
      compare: Int$negBase.compare,
      min: Int$negBase.min,
      max: Int$negBase.max,
      ascending: Int$negBase.ascending,
      descending: Int$negBase.descending,
      between: Int$negBase.between,
      clamp_exn: Int$negBase.clamp_exn,
      clamp: Int$negBase.clamp,
      comparator: Int$negBase.comparator,
      pp: Int$negBase.pp,
      hashable: Int$negBase.hashable,
      is_positive: Int$negBase.is_positive,
      is_non_negative: Int$negBase.is_non_negative,
      is_negative: Int$negBase.is_negative,
      is_non_positive: Int$negBase.is_non_positive,
      sign: Int$negBase.sign,
      invariant: Int$negBase.invariant,
      Hex: Int$negBase.Hex,
      to_string_hum: Int$negBase.to_string_hum,
      zero: Int$negBase.zero,
      one: Int$negBase.one,
      minus_one: Int$negBase.minus_one,
      $plus: Int$negBase.$plus,
      $neg: Int$negBase.$neg,
      $star: Int$negBase.$star,
      $star$star: Int$negBase.$star$star,
      neg: Int$negBase.neg,
      $tilde$neg: Int$negBase.$tilde$neg,
      $slash$percent: Int$negBase.$slash$percent,
      $percent: Int$negBase.$percent,
      $slash: Int$negBase.$slash,
      rem: Int$negBase.rem,
      $slash$slash: Int$negBase.$slash$slash,
      land: Int$negBase.land,
      lor: Int$negBase.lor,
      lxor: Int$negBase.lxor,
      lnot: Int$negBase.lnot,
      lsl: Int$negBase.lsl,
      asr: Int$negBase.asr,
      round: Int$negBase.round,
      round_towards_zero: Int$negBase.round_towards_zero,
      round_down: Int$negBase.round_down,
      round_up: Int$negBase.round_up,
      round_nearest: Int$negBase.round_nearest,
      abs: Int$negBase.abs,
      succ: Int$negBase.succ,
      pred: Int$negBase.pred,
      pow: Int$negBase.pow,
      bit_and: Int$negBase.bit_and,
      bit_or: Int$negBase.bit_or,
      bit_xor: Int$negBase.bit_xor,
      bit_not: Int$negBase.bit_not,
      popcount: Int$negBase.popcount,
      shift_left: Int$negBase.shift_left,
      shift_right: Int$negBase.shift_right,
      decr: Int$negBase.decr,
      incr: Int$negBase.incr,
      of_int32_exn: Int$negBase.of_int32_exn,
      to_int32_exn: Int$negBase.to_int32_exn,
      of_int64_exn: Int$negBase.of_int64_exn,
      to_int64: Int$negBase.to_int64,
      of_nativeint_exn: Int$negBase.of_nativeint_exn,
      to_nativeint_exn: Int$negBase.to_nativeint_exn,
      num_bits: Int$negBase.num_bits,
      max_value: Int$negBase.max_value,
      min_value: Int$negBase.min_value,
      lsr: Int$negBase.lsr,
      shift_right_logical: Int$negBase.shift_right_logical,
      ceil_pow2: Int$negBase.ceil_pow2,
      floor_pow2: Int$negBase.floor_pow2,
      ceil_log2: Int$negBase.ceil_log2,
      floor_log2: Int$negBase.floor_log2,
      is_pow2: Int$negBase.is_pow2,
      clz: Int$negBase.clz,
      ctz: Int$negBase.ctz,
      O: Int$negBase.O,
      of_int: Int$negBase.of_int,
      to_int: to_int,
      to_int_trunc: to_int_trunc,
      of_int32: Int$negBase.of_int32_exn,
      to_int32: Int$negBase.to_int32,
      to_int32_trunc: Int$negBase.to_int32_trunc,
      of_int64: Int$negBase.of_int64,
      of_int64_trunc: Int$negBase.of_int64_trunc,
      of_nativeint: Int$negBase.of_nativeint,
      to_nativeint: to_nativeint,
      of_nativeint_trunc: Int$negBase.of_nativeint_trunc,
      to_nativeint_trunc: to_nativeint_trunc,
      of_float_unchecked: Int$negBase.of_float_unchecked,
      repr: /* Int */0
    });

var to_int_exn = impl.to_int_exn;

var sexp_of_t = impl.sexp_of_t;

var $less$eq = impl.$less$eq;

var $eq = impl.$eq;

var $great = impl.$great;

var $less = impl.$less;

var $less$great = impl.$less$great;

var equal = impl.equal;

var is_positive = impl.is_positive;

var zero = impl.zero;

var one = impl.one;

var $plus = impl.$plus;

var $neg = impl.$neg;

var $star = impl.$star;

var neg = impl.neg;

var $slash = impl.$slash;

var abs = impl.abs;

var bit_and = impl.bit_and;

var bit_or = impl.bit_or;

var bit_xor = impl.bit_xor;

var bit_not = impl.bit_not;

var shift_left = impl.shift_left;

var of_int64_exn = impl.of_int64_exn;

var to_int64 = impl.to_int64;

var num_bits = impl.num_bits;

var min_value = impl.min_value;

var of_int = impl.of_int;

function $plus$1(t, u) {
  var sum = Curry._2($plus, t, u);
  if (Curry._2($less, Curry._2(bit_or, Curry._2(bit_xor, t, u), Curry._2(bit_xor, t, Curry._1(bit_not, sum))), zero)) {
    return sum;
  } else {
    return Error$negBase.raise_s(Sexp$negBase.message("( + ) overflow", {
                    hd: [
                      "t",
                      Curry._1(sexp_of_t, t)
                    ],
                    tl: {
                      hd: [
                        "u",
                        Curry._1(sexp_of_t, u)
                      ],
                      tl: {
                        hd: [
                          "sum",
                          Curry._1(sexp_of_t, sum)
                        ],
                        tl: /* [] */0
                      }
                    }
                  }));
  }
}

function $neg$1(t, u) {
  var diff = Curry._2($neg, t, u);
  var pos_diff = Curry._2($great, t, u);
  if (Curry._2($less$great, t, u) && Curry._2(Bool$negBase.$less$great, pos_diff, Curry._1(is_positive, diff))) {
    return Error$negBase.raise_s(Sexp$negBase.message("( - ) overflow", {
                    hd: [
                      "t",
                      Curry._1(sexp_of_t, t)
                    ],
                    tl: {
                      hd: [
                        "u",
                        Curry._1(sexp_of_t, u)
                      ],
                      tl: {
                        hd: [
                          "diff",
                          Curry._1(sexp_of_t, diff)
                        ],
                        tl: /* [] */0
                      }
                    }
                  }));
  } else {
    return diff;
  }
}

var negative_one = Curry._1(of_int, -1);

function div_would_overflow(t, u) {
  if (Curry._2($eq, t, min_value)) {
    return Curry._2($eq, u, negative_one);
  } else {
    return false;
  }
}

function $star$1(t, u) {
  var product = Curry._2($star, t, u);
  if (Curry._2($less$great, u, zero) && (div_would_overflow(product, u) || Curry._2($less$great, Curry._2($slash, product, u), t))) {
    return Error$negBase.raise_s(Sexp$negBase.message("( * ) overflow", {
                    hd: [
                      "t",
                      Curry._1(sexp_of_t, t)
                    ],
                    tl: {
                      hd: [
                        "u",
                        Curry._1(sexp_of_t, u)
                      ],
                      tl: {
                        hd: [
                          "product",
                          Curry._1(sexp_of_t, product)
                        ],
                        tl: /* [] */0
                      }
                    }
                  }));
  } else {
    return product;
  }
}

function $slash$1(t, u) {
  if (div_would_overflow(t, u)) {
    return Error$negBase.raise_s(Sexp$negBase.message("( / ) overflow", {
                    hd: [
                      "t",
                      Curry._1(sexp_of_t, t)
                    ],
                    tl: {
                      hd: [
                        "u",
                        Curry._1(sexp_of_t, u)
                      ],
                      tl: {
                        hd: [
                          "product",
                          Curry._1(sexp_of_t, Curry._2($slash, t, u))
                        ],
                        tl: /* [] */0
                      }
                    }
                  }));
  } else {
    return Curry._2($slash, t, u);
  }
}

function abs$1(t) {
  if (Curry._2($eq, t, min_value)) {
    return Import$negBase.failwith("abs overflow");
  } else {
    return Curry._1(abs, t);
  }
}

function neg$1(t) {
  if (Curry._2($eq, t, min_value)) {
    return Import$negBase.failwith("neg overflow");
  } else {
    return Curry._1(neg, t);
  }
}

if (!Curry._2(Int$negBase.$eq, num_bits, 63)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "int63.ml",
          162,
          9
        ],
        Error: new Error()
      };
}

function random_of_int(stateOpt, bound) {
  var state = stateOpt !== undefined ? Caml_option.valFromOption(stateOpt) : Random$negBase.State.$$default;
  return Curry._1(of_int, Curry._2(Random$negBase.State.$$int, state, Curry._1(to_int_exn, bound)));
}

function random_of_int64(stateOpt, bound) {
  var state = stateOpt !== undefined ? Caml_option.valFromOption(stateOpt) : Random$negBase.State.$$default;
  return Curry._1(of_int64_exn, Random$negBase.State.int64(state, Curry._1(to_int64, bound)));
}

var random = Word_size$negBase.word_size ? random_of_int : random_of_int64;

function random_incl_of_int(stateOpt, lo, hi) {
  var state = stateOpt !== undefined ? Caml_option.valFromOption(stateOpt) : Random$negBase.State.$$default;
  return Curry._1(of_int, Random$negBase.State.int_incl(state, Curry._1(to_int_exn, lo), Curry._1(to_int_exn, hi)));
}

function random_incl_of_int64(stateOpt, lo, hi) {
  var state = stateOpt !== undefined ? Caml_option.valFromOption(stateOpt) : Random$negBase.State.$$default;
  return Curry._1(of_int64_exn, Random$negBase.State.int64_incl(state, Curry._1(to_int64, lo), Curry._1(to_int64, hi)));
}

var random_incl = Word_size$negBase.word_size ? random_incl_of_int : random_incl_of_int64;

function floor_log2(t) {
  if (Word_size$negBase.word_size) {
    return Int$negBase.floor_log2(Curry._1(to_int_exn, t));
  }
  if (Curry._2($less$eq, t, zero)) {
    Error$negBase.raise_s(Sexp$negBase.message("[Int.floor_log2] got invalid input", {
              hd: [
                "",
                Curry._1(sexp_of_t, t)
              ],
              tl: /* [] */0
            }));
  }
  var floor_log2$1 = Int$negBase.$neg(num_bits, 2);
  while(Curry._2(equal, zero, Curry._2(bit_and, t, Curry._2(shift_left, one, floor_log2$1)))) {
    floor_log2$1 = Int$negBase.$neg(floor_log2$1, 1);
  };
  return floor_log2$1;
}

var t_sexp_grammar = impl.t_sexp_grammar;

var of_float = impl.of_float;

var to_float = impl.to_float;

var of_int_exn = impl.of_int_exn;

var hash_fold_t = impl.hash_fold_t;

var hash = impl.hash;

var t_of_sexp = impl.t_of_sexp;

var of_string = impl.of_string;

var to_string = impl.to_string;

var $great$eq = impl.$great$eq;

var compare = impl.compare;

var min = impl.min;

var max = impl.max;

var ascending = impl.ascending;

var descending = impl.descending;

var between = impl.between;

var clamp_exn = impl.clamp_exn;

var clamp = impl.clamp;

var comparator = impl.comparator;

var pp = impl.pp;

var hashable = impl.hashable;

var is_non_negative = impl.is_non_negative;

var is_negative = impl.is_negative;

var is_non_positive = impl.is_non_positive;

var sign = impl.sign;

var invariant = impl.invariant;

var Hex = impl.Hex;

var to_string_hum = impl.to_string_hum;

var minus_one = impl.minus_one;

var $star$star = impl.$star$star;

var $tilde$neg = impl.$tilde$neg;

var $slash$percent = impl.$slash$percent;

var $percent = impl.$percent;

var rem = impl.rem;

var $slash$slash = impl.$slash$slash;

var land = impl.land;

var lor = impl.lor;

var lxor = impl.lxor;

var lnot = impl.lnot;

var lsl = impl.lsl;

var asr = impl.asr;

var round = impl.round;

var round_towards_zero = impl.round_towards_zero;

var round_down = impl.round_down;

var round_up = impl.round_up;

var round_nearest = impl.round_nearest;

var succ = impl.succ;

var pred = impl.pred;

var pow = impl.pow;

var popcount = impl.popcount;

var shift_right = impl.shift_right;

var decr = impl.decr;

var incr = impl.incr;

var of_int32_exn = impl.of_int32_exn;

var to_int32_exn = impl.to_int32_exn;

var of_nativeint_exn = impl.of_nativeint_exn;

var to_nativeint_exn = impl.to_nativeint_exn;

var of_float_unchecked = impl.of_float_unchecked;

var max_value = impl.max_value;

var lsr = impl.lsr;

var shift_right_logical = impl.shift_right_logical;

var ceil_pow2 = impl.ceil_pow2;

var floor_pow2 = impl.floor_pow2;

var ceil_log2 = impl.ceil_log2;

var is_pow2 = impl.is_pow2;

var clz = impl.clz;

var ctz = impl.ctz;

var O = impl.O;

var Overflow_exn = {
  $plus: $plus$1,
  $neg: $neg$1,
  $star: $star$1,
  $slash: $slash$1,
  abs: abs$1,
  neg: neg$1
};

var to_int$1 = impl.to_int;

var of_int32 = impl.of_int32;

var to_int32 = impl.to_int32;

var of_int64 = impl.of_int64;

var of_nativeint = impl.of_nativeint;

var to_nativeint$1 = impl.to_nativeint;

var to_int_trunc$1 = impl.to_int_trunc;

var to_int32_trunc = impl.to_int32_trunc;

var of_int64_trunc = impl.of_int64_trunc;

var of_nativeint_trunc = impl.of_nativeint_trunc;

var to_nativeint_trunc$1 = impl.to_nativeint_trunc;

var Private_repr = impl.repr;

var Private = {
  Repr: Int63_emul$negBase.Repr,
  repr: Private_repr
};

exports.t_sexp_grammar = t_sexp_grammar;
exports.of_float = of_float;
exports.to_float = to_float;
exports.of_int_exn = of_int_exn;
exports.to_int_exn = to_int_exn;
exports.hash_fold_t = hash_fold_t;
exports.hash = hash;
exports.t_of_sexp = t_of_sexp;
exports.sexp_of_t = sexp_of_t;
exports.of_string = of_string;
exports.to_string = to_string;
exports.$great$eq = $great$eq;
exports.$less$eq = $less$eq;
exports.$eq = $eq;
exports.$great = $great;
exports.$less = $less;
exports.$less$great = $less$great;
exports.equal = equal;
exports.compare = compare;
exports.min = min;
exports.max = max;
exports.ascending = ascending;
exports.descending = descending;
exports.between = between;
exports.clamp_exn = clamp_exn;
exports.clamp = clamp;
exports.comparator = comparator;
exports.pp = pp;
exports.hashable = hashable;
exports.is_positive = is_positive;
exports.is_non_negative = is_non_negative;
exports.is_negative = is_negative;
exports.is_non_positive = is_non_positive;
exports.sign = sign;
exports.invariant = invariant;
exports.Hex = Hex;
exports.to_string_hum = to_string_hum;
exports.zero = zero;
exports.one = one;
exports.minus_one = minus_one;
exports.$plus = $plus;
exports.$neg = $neg;
exports.$star = $star;
exports.$star$star = $star$star;
exports.neg = neg;
exports.$tilde$neg = $tilde$neg;
exports.$slash$percent = $slash$percent;
exports.$percent = $percent;
exports.$slash = $slash;
exports.rem = rem;
exports.$slash$slash = $slash$slash;
exports.land = land;
exports.lor = lor;
exports.lxor = lxor;
exports.lnot = lnot;
exports.lsl = lsl;
exports.asr = asr;
exports.round = round;
exports.round_towards_zero = round_towards_zero;
exports.round_down = round_down;
exports.round_up = round_up;
exports.round_nearest = round_nearest;
exports.abs = abs;
exports.succ = succ;
exports.pred = pred;
exports.pow = pow;
exports.bit_and = bit_and;
exports.bit_or = bit_or;
exports.bit_xor = bit_xor;
exports.bit_not = bit_not;
exports.popcount = popcount;
exports.shift_left = shift_left;
exports.shift_right = shift_right;
exports.decr = decr;
exports.incr = incr;
exports.of_int32_exn = of_int32_exn;
exports.to_int32_exn = to_int32_exn;
exports.of_int64_exn = of_int64_exn;
exports.to_int64 = to_int64;
exports.of_nativeint_exn = of_nativeint_exn;
exports.to_nativeint_exn = to_nativeint_exn;
exports.of_float_unchecked = of_float_unchecked;
exports.num_bits = num_bits;
exports.max_value = max_value;
exports.min_value = min_value;
exports.lsr = lsr;
exports.shift_right_logical = shift_right_logical;
exports.ceil_pow2 = ceil_pow2;
exports.floor_pow2 = floor_pow2;
exports.ceil_log2 = ceil_log2;
exports.is_pow2 = is_pow2;
exports.clz = clz;
exports.ctz = ctz;
exports.O = O;
exports.Overflow_exn = Overflow_exn;
exports.of_int = of_int;
exports.to_int = to_int$1;
exports.of_int32 = of_int32;
exports.to_int32 = to_int32;
exports.of_int64 = of_int64;
exports.of_nativeint = of_nativeint;
exports.to_nativeint = to_nativeint$1;
exports.to_int_trunc = to_int_trunc$1;
exports.to_int32_trunc = to_int32_trunc;
exports.of_int64_trunc = of_int64_trunc;
exports.of_nativeint_trunc = of_nativeint_trunc;
exports.to_nativeint_trunc = to_nativeint_trunc$1;
exports.random = random;
exports.random_incl = random_incl;
exports.floor_log2 = floor_log2;
exports.Private = Private;
/* negative_one Not a pure module */
