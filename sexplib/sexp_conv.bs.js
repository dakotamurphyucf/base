// Generated by Melange
'use strict';

var Gc = require("bs-platform/lib/js/gc.js");
var Arg = require("bs-platform/lib/js/arg.js");
var Obj = require("bs-platform/lib/js/obj.js");
var Sys = require("bs-platform/lib/js/sys.js");
var Lazy = require("bs-platform/lib/js/lazy.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Int32 = require("bs-platform/lib/js/int32.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Scanf = require("bs-platform/lib/js/scanf.js");
var Stack = require("bs-platform/lib/js/stack.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Stdlib = require("bs-platform/lib/js/stdlib.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Parsing = require("bs-platform/lib/js/parsing.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Ephemeron = require("bs-platform/lib/js/ephemeron.js");
var Nativeint = require("bs-platform/lib/js/nativeint.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var ListLabels = require("bs-platform/lib/js/listLabels.js");
var MoreLabels = require("bs-platform/lib/js/moreLabels.js");
var BytesLabels = require("bs-platform/lib/js/bytesLabels.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var StringLabels = require("bs-platform/lib/js/stringLabels.js");
var Sexp$negSexplib0 = require("./sexp.bs.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Sexp_conv_grammar$negSexplib0 = require("./sexp_conv_grammar.bs.js");

var default_string_of_float = {
  contents: (function (x) {
      var y = Caml_format.caml_format_float("%.15G", x);
      if (Caml_format.caml_float_of_string(y) === x) {
        return y;
      } else {
        return Caml_format.caml_format_float("%.17G", x);
      }
    })
};

var read_old_option_format = {
  contents: true
};

var write_old_option_format = {
  contents: true
};

function list_map(f, l) {
  return ListLabels.rev(ListLabels.rev_map(f, l));
}

function sexp_of_unit(param) {
  return {
          TAG: /* List */1,
          _0: /* [] */0
        };
}

function sexp_of_bool(b) {
  return {
          TAG: /* Atom */0,
          _0: Stdlib.string_of_bool(b)
        };
}

function sexp_of_string(str) {
  return {
          TAG: /* Atom */0,
          _0: str
        };
}

function sexp_of_bytes(bytes) {
  return {
          TAG: /* Atom */0,
          _0: BytesLabels.to_string(bytes)
        };
}

function sexp_of_char(c) {
  return {
          TAG: /* Atom */0,
          _0: StringLabels.make(1, c)
        };
}

function sexp_of_int(n) {
  return {
          TAG: /* Atom */0,
          _0: String(n)
        };
}

function sexp_of_float(n) {
  return {
          TAG: /* Atom */0,
          _0: Curry._1(default_string_of_float.contents, n)
        };
}

function sexp_of_int32(n) {
  return {
          TAG: /* Atom */0,
          _0: Int32.to_string(n)
        };
}

function sexp_of_int64(n) {
  return {
          TAG: /* Atom */0,
          _0: Int64.to_string(n)
        };
}

function sexp_of_nativeint(n) {
  return {
          TAG: /* Atom */0,
          _0: Nativeint.to_string(n)
        };
}

function sexp_of_ref(sexp_of__a, rf) {
  return Curry._1(sexp_of__a, rf.contents);
}

function sexp_of_lazy_t(sexp_of__a, lv) {
  return Curry._1(sexp_of__a, CamlinternalLazy.force(lv));
}

function sexp_of_option(sexp_of__a, x) {
  if (x === undefined) {
    if (write_old_option_format.contents) {
      return {
              TAG: /* List */1,
              _0: /* [] */0
            };
    } else {
      return {
              TAG: /* Atom */0,
              _0: "none"
            };
    }
  }
  var x$1 = Caml_option.valFromOption(x);
  if (write_old_option_format.contents) {
    return {
            TAG: /* List */1,
            _0: {
              hd: Curry._1(sexp_of__a, x$1),
              tl: /* [] */0
            }
          };
  } else {
    return {
            TAG: /* List */1,
            _0: {
              hd: {
                TAG: /* Atom */0,
                _0: "some"
              },
              tl: {
                hd: Curry._1(sexp_of__a, x$1),
                tl: /* [] */0
              }
            }
          };
  }
}

function sexp_of_pair(sexp_of__a, sexp_of__b, param) {
  return {
          TAG: /* List */1,
          _0: {
            hd: Curry._1(sexp_of__a, param[0]),
            tl: {
              hd: Curry._1(sexp_of__b, param[1]),
              tl: /* [] */0
            }
          }
        };
}

function sexp_of_triple(sexp_of__a, sexp_of__b, sexp_of__c, param) {
  return {
          TAG: /* List */1,
          _0: {
            hd: Curry._1(sexp_of__a, param[0]),
            tl: {
              hd: Curry._1(sexp_of__b, param[1]),
              tl: {
                hd: Curry._1(sexp_of__c, param[2]),
                tl: /* [] */0
              }
            }
          }
        };
}

function sexp_of_list(sexp_of__a, lst) {
  return {
          TAG: /* List */1,
          _0: ListLabels.rev(ListLabels.rev_map(sexp_of__a, lst))
        };
}

function sexp_of_array(sexp_of__a, ar) {
  var lst_ref = /* [] */0;
  for(var i = ar.length - 1 | 0; i >= 0; --i){
    lst_ref = {
      hd: Curry._1(sexp_of__a, Caml_array.get(ar, i)),
      tl: lst_ref
    };
  }
  return {
          TAG: /* List */1,
          _0: lst_ref
        };
}

function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl) {
  var coll = function (k, v, acc) {
    return {
            hd: {
              TAG: /* List */1,
              _0: {
                hd: Curry._1(sexp_of_key, k),
                tl: {
                  hd: Curry._1(sexp_of_val, v),
                  tl: /* [] */0
                }
              }
            },
            tl: acc
          };
  };
  return {
          TAG: /* List */1,
          _0: Curry._3(MoreLabels.Hashtbl.fold, coll, htbl, /* [] */0)
        };
}

function sexp_of_opaque(param) {
  return {
          TAG: /* Atom */0,
          _0: "<opaque>"
        };
}

function sexp_of_fun(param) {
  return {
          TAG: /* Atom */0,
          _0: "<fun>"
        };
}

var compare = Caml_obj.caml_compare;

var Int = {
  compare: compare
};

var Exn_ids = Curry._1(MoreLabels.$$Map.Make, Int);

var exn_id_map = {
  contents: Exn_ids.empty
};

function clean_up_handler(slot) {
  while(true) {
    var id = Obj.extension_id(slot);
    var old_exn_id_map = exn_id_map.contents;
    var new_exn_id_map = Curry._2(Exn_ids.remove, id, old_exn_id_map);
    if (exn_id_map.contents === old_exn_id_map) {
      exn_id_map.contents = new_exn_id_map;
      return ;
    }
    continue ;
  };
}

function add(printexcOpt, finaliseOpt, extension_constructor, sexp_of_exn) {
  var printexc = printexcOpt !== undefined ? printexcOpt : true;
  var finalise = finaliseOpt !== undefined ? finaliseOpt : true;
  var id = Obj.extension_id(extension_constructor);
  var _param;
  while(true) {
    var old_exn_id_map = exn_id_map.contents;
    var ephe = Ephemeron.K1.create(undefined);
    Ephemeron.K1.set_data(ephe, {
          sexp_of_exn: sexp_of_exn,
          printexc: printexc
        });
    Ephemeron.K1.set_key(ephe, extension_constructor);
    var new_exn_id_map = Curry._3(Exn_ids.add, id, ephe, old_exn_id_map);
    if (exn_id_map.contents !== old_exn_id_map) {
      _param = undefined;
      continue ;
    }
    exn_id_map.contents = new_exn_id_map;
    if (!finalise) {
      return ;
    }
    try {
      return Gc.finalise(clean_up_handler, extension_constructor);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Invalid_argument) {
        return ;
      }
      throw exn;
    }
  };
}

function add_auto(finalise, exn, sexp_of_exn) {
  return add(undefined, finalise, Obj.extension_constructor(exn), sexp_of_exn);
}

function find_auto(for_printexc, exn) {
  var id = Obj.extension_id(Obj.extension_constructor(exn));
  var ephe;
  try {
    ephe = Curry._2(Exn_ids.find, id, exn_id_map.contents);
  }
  catch (raw_exn){
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn$1.RE_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw exn$1;
  }
  var match = Ephemeron.K1.get_data(ephe);
  if (match === undefined) {
    return ;
  }
  var sexp_of_exn = match.sexp_of_exn;
  if (for_printexc && !match.printexc) {
    return ;
  } else {
    return Curry._1(sexp_of_exn, exn);
  }
}

function size(param) {
  return Curry._3(Exn_ids.fold, (function (param, ephe, acc) {
                var match = Ephemeron.K1.get_data(ephe);
                if (match !== undefined) {
                  return acc + 1 | 0;
                } else {
                  return acc;
                }
              }), exn_id_map.contents, 0);
}

var For_unit_tests_only = {
  size: size
};

function sexp_of_exn_opt(exn) {
  return find_auto(false, exn);
}

function sexp_of_exn(exn) {
  var sexp = find_auto(false, exn);
  if (sexp !== undefined) {
    return sexp;
  } else {
    return {
            TAG: /* List */1,
            _0: {
              hd: {
                TAG: /* Atom */0,
                _0: Printexc.to_string(exn)
              },
              tl: /* [] */0
            }
          };
  }
}

Printexc.register_printer(function (exn) {
      var sexp = find_auto(true, exn);
      if (sexp !== undefined) {
        return Sexp$negSexplib0.to_string_hum(2, sexp);
      }
      
    });

function printexc_prefer_sexp(exn) {
  var sexp = find_auto(false, exn);
  if (sexp !== undefined) {
    return Sexp$negSexplib0.to_string_hum(2, sexp);
  } else {
    return Printexc.to_string(exn);
  }
}

var record_check_extra_fields = {
  contents: true
};

function of_sexp_error_exn(exc, sexp) {
  throw {
        RE_EXN_ID: Sexp$negSexplib0.Of_sexp_error,
        _1: exc,
        _2: sexp,
        Error: new Error()
      };
}

function of_sexp_error(what, sexp) {
  throw {
        RE_EXN_ID: Sexp$negSexplib0.Of_sexp_error,
        _1: {
          RE_EXN_ID: Stdlib.Failure,
          _1: what
        },
        _2: sexp,
        Error: new Error()
      };
}

function unit_of_sexp(sexp) {
  if (sexp.TAG === /* Atom */0 || sexp._0) {
    return of_sexp_error("unit_of_sexp: empty list needed", sexp);
  }
  
}

function bool_of_sexp(sexp) {
  if (sexp.TAG !== /* Atom */0) {
    return of_sexp_error("bool_of_sexp: atom needed", sexp);
  }
  switch (sexp._0) {
    case "False" :
    case "false" :
        return false;
    case "True" :
    case "true" :
        return true;
    default:
      return of_sexp_error("bool_of_sexp: unknown string", sexp);
  }
}

function string_of_sexp(sexp) {
  if (sexp.TAG === /* Atom */0) {
    return sexp._0;
  } else {
    return of_sexp_error("string_of_sexp: atom needed", sexp);
  }
}

function bytes_of_sexp(sexp) {
  if (sexp.TAG === /* Atom */0) {
    return BytesLabels.of_string(sexp._0);
  } else {
    return of_sexp_error("bytes_of_sexp: atom needed", sexp);
  }
}

function char_of_sexp(sexp) {
  if (sexp.TAG !== /* Atom */0) {
    return of_sexp_error("char_of_sexp: atom needed", sexp);
  }
  var str = sexp._0;
  if (str.length !== 1) {
    of_sexp_error("char_of_sexp: atom string must contain one character only", sexp);
  }
  return Caml_string.get(str, 0);
}

function int_of_sexp(sexp) {
  if (sexp.TAG !== /* Atom */0) {
    return of_sexp_error("int_of_sexp: atom needed", sexp);
  }
  try {
    return Caml_format.caml_int_of_string(sexp._0);
  }
  catch (raw_exc){
    var exc = Caml_js_exceptions.internalToOCamlException(raw_exc);
    return of_sexp_error("int_of_sexp: " + Sexp$negSexplib0.to_string_hum(undefined, sexp_of_exn(exc)), sexp);
  }
}

function float_of_sexp(sexp) {
  if (sexp.TAG !== /* Atom */0) {
    return of_sexp_error("float_of_sexp: atom needed", sexp);
  }
  try {
    return Caml_format.caml_float_of_string(sexp._0);
  }
  catch (raw_exc){
    var exc = Caml_js_exceptions.internalToOCamlException(raw_exc);
    return of_sexp_error("float_of_sexp: " + Sexp$negSexplib0.to_string_hum(undefined, sexp_of_exn(exc)), sexp);
  }
}

function int32_of_sexp(sexp) {
  if (sexp.TAG !== /* Atom */0) {
    return of_sexp_error("int32_of_sexp: atom needed", sexp);
  }
  try {
    return Caml_format.caml_int32_of_string(sexp._0);
  }
  catch (raw_exc){
    var exc = Caml_js_exceptions.internalToOCamlException(raw_exc);
    return of_sexp_error("int32_of_sexp: " + Sexp$negSexplib0.to_string_hum(undefined, sexp_of_exn(exc)), sexp);
  }
}

function int64_of_sexp(sexp) {
  if (sexp.TAG !== /* Atom */0) {
    return of_sexp_error("int64_of_sexp: atom needed", sexp);
  }
  try {
    return Caml_format.caml_int64_of_string(sexp._0);
  }
  catch (raw_exc){
    var exc = Caml_js_exceptions.internalToOCamlException(raw_exc);
    return of_sexp_error("int64_of_sexp: " + Sexp$negSexplib0.to_string_hum(undefined, sexp_of_exn(exc)), sexp);
  }
}

function nativeint_of_sexp(sexp) {
  if (sexp.TAG !== /* Atom */0) {
    return of_sexp_error("nativeint_of_sexp: atom needed", sexp);
  }
  try {
    return Caml_format.caml_nativeint_of_string(sexp._0);
  }
  catch (raw_exc){
    var exc = Caml_js_exceptions.internalToOCamlException(raw_exc);
    return of_sexp_error("nativeint_of_sexp: " + Sexp$negSexplib0.to_string_hum(undefined, sexp_of_exn(exc)), sexp);
  }
}

function ref_of_sexp(a__of_sexp, sexp) {
  return {
          contents: Curry._1(a__of_sexp, sexp)
        };
}

function lazy_t_of_sexp(a__of_sexp, sexp) {
  return Lazy.from_val(Curry._1(a__of_sexp, sexp));
}

function option_of_sexp(a__of_sexp, sexp) {
  if (read_old_option_format.contents) {
    if (sexp.TAG === /* Atom */0) {
      switch (sexp._0) {
        case "None" :
        case "none" :
            return ;
        default:
          return of_sexp_error("option_of_sexp: only none can be atom", sexp);
      }
    } else {
      var match = sexp._0;
      if (!match) {
        return ;
      }
      var el = match.hd;
      if (!match.tl) {
        return Caml_option.some(Curry._1(a__of_sexp, el));
      }
      if (el.TAG !== /* Atom */0) {
        return of_sexp_error("option_of_sexp: list must represent optional value", sexp);
      }
      switch (el._0) {
        case "Some" :
        case "some" :
            break;
        default:
          return of_sexp_error("option_of_sexp: list must represent optional value", sexp);
      }
      var match$1 = match.tl;
      if (match$1.tl) {
        return of_sexp_error("option_of_sexp: list must represent optional value", sexp);
      } else {
        return Caml_option.some(Curry._1(a__of_sexp, match$1.hd));
      }
    }
  } else if (sexp.TAG === /* Atom */0) {
    switch (sexp._0) {
      case "None" :
      case "none" :
          return ;
      default:
        return of_sexp_error("option_of_sexp: only none can be atom", sexp);
    }
  } else {
    var match$2 = sexp._0;
    if (!match$2) {
      return of_sexp_error("option_of_sexp: list must be (some el)", sexp);
    }
    var match$3 = match$2.hd;
    if (match$3.TAG !== /* Atom */0) {
      return of_sexp_error("option_of_sexp: list must be (some el)", sexp);
    }
    switch (match$3._0) {
      case "Some" :
      case "some" :
          break;
      default:
        return of_sexp_error("option_of_sexp: list must be (some el)", sexp);
    }
    var match$4 = match$2.tl;
    if (match$4 && !match$4.tl) {
      return Caml_option.some(Curry._1(a__of_sexp, match$4.hd));
    } else {
      return of_sexp_error("option_of_sexp: list must be (some el)", sexp);
    }
  }
}

function pair_of_sexp(a__of_sexp, b__of_sexp, sexp) {
  if (sexp.TAG === /* Atom */0) {
    return of_sexp_error("pair_of_sexp: list needed", sexp);
  }
  var match = sexp._0;
  if (!match) {
    return of_sexp_error("pair_of_sexp: list must contain exactly two elements only", sexp);
  }
  var match$1 = match.tl;
  if (!match$1) {
    return of_sexp_error("pair_of_sexp: list must contain exactly two elements only", sexp);
  }
  if (match$1.tl) {
    return of_sexp_error("pair_of_sexp: list must contain exactly two elements only", sexp);
  }
  var a = Curry._1(a__of_sexp, match.hd);
  var b = Curry._1(b__of_sexp, match$1.hd);
  return [
          a,
          b
        ];
}

function triple_of_sexp(a__of_sexp, b__of_sexp, c__of_sexp, sexp) {
  if (sexp.TAG === /* Atom */0) {
    return of_sexp_error("triple_of_sexp: list needed", sexp);
  }
  var match = sexp._0;
  if (!match) {
    return of_sexp_error("triple_of_sexp: list must contain exactly three elements only", sexp);
  }
  var match$1 = match.tl;
  if (!match$1) {
    return of_sexp_error("triple_of_sexp: list must contain exactly three elements only", sexp);
  }
  var match$2 = match$1.tl;
  if (!match$2) {
    return of_sexp_error("triple_of_sexp: list must contain exactly three elements only", sexp);
  }
  if (match$2.tl) {
    return of_sexp_error("triple_of_sexp: list must contain exactly three elements only", sexp);
  }
  var a = Curry._1(a__of_sexp, match.hd);
  var b = Curry._1(b__of_sexp, match$1.hd);
  var c = Curry._1(c__of_sexp, match$2.hd);
  return [
          a,
          b,
          c
        ];
}

function list_of_sexp(a__of_sexp, sexp) {
  if (sexp.TAG === /* Atom */0) {
    return of_sexp_error("list_of_sexp: list needed", sexp);
  } else {
    return ListLabels.rev(ListLabels.rev_map(a__of_sexp, sexp._0));
  }
}

function array_of_sexp(a__of_sexp, sexp) {
  if (sexp.TAG === /* Atom */0) {
    return of_sexp_error("array_of_sexp: list needed", sexp);
  }
  var match = sexp._0;
  if (!match) {
    return [];
  }
  var t = match.tl;
  var len = ListLabels.length(t) + 1 | 0;
  var res = Caml_array.make(len, Curry._1(a__of_sexp, match.hd));
  var _i = 1;
  var _param = t;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return res;
    }
    Caml_array.set(res, i, Curry._1(a__of_sexp, param.hd));
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp) {
  if (sexp.TAG === /* Atom */0) {
    return of_sexp_error("hashtbl_of_sexp: list needed", sexp);
  }
  var htbl = Curry._2(MoreLabels.Hashtbl.create, undefined, 0);
  var act = function (param) {
    if (param.TAG === /* Atom */0) {
      return of_sexp_error("hashtbl_of_sexp: tuple list needed", sexp);
    }
    var match = param._0;
    if (!match) {
      return of_sexp_error("hashtbl_of_sexp: tuple list needed", sexp);
    }
    var match$1 = match.tl;
    if (match$1 && !match$1.tl) {
      return Curry._3(MoreLabels.Hashtbl.add, htbl, Curry._1(key_of_sexp, match.hd), Curry._1(val_of_sexp, match$1.hd));
    } else {
      return of_sexp_error("hashtbl_of_sexp: tuple list needed", sexp);
    }
  };
  ListLabels.iter(act, sexp._0);
  return htbl;
}

function opaque_of_sexp(sexp) {
  return of_sexp_error("opaque_of_sexp: cannot convert opaque values", sexp);
}

function fun_of_sexp(sexp) {
  return of_sexp_error("fun_of_sexp: cannot convert function values", sexp);
}

function get_flc_error(name, param) {
  return {
          TAG: /* Atom */0,
          _0: Curry._4(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* ' ' */32,
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* ':' */58,
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* Char_literal */12,
                                _0: /* ':' */58,
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s %s:%d:%d"
                  }), name, param[0], param[1], param[2])
        };
}

ListLabels.iter((function (param) {
        return add(false, false, param[0], param[1]);
      }), {
      hd: [
        Stdlib.Assert_failure,
        (function (arg) {
            if (arg.RE_EXN_ID === Stdlib.Assert_failure) {
              return get_flc_error("Assert_failure", arg._1);
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "sexp_conv.ml",
                    400,
                    15
                  ],
                  Error: new Error()
                };
          })
      ],
      tl: {
        hd: [
          Stdlib.Exit,
          (function (param) {
              if (param.RE_EXN_ID === Stdlib.Exit) {
                return {
                        TAG: /* Atom */0,
                        _0: "Exit"
                      };
              }
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "sexp_conv.ml",
                      404,
                      15
                    ],
                    Error: new Error()
                  };
            })
        ],
        tl: {
          hd: [
            Stdlib.End_of_file,
            (function (param) {
                if (param.RE_EXN_ID === Stdlib.End_of_file) {
                  return {
                          TAG: /* Atom */0,
                          _0: "End_of_file"
                        };
                }
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "sexp_conv.ml",
                        408,
                        15
                      ],
                      Error: new Error()
                    };
              })
          ],
          tl: {
            hd: [
              Stdlib.Failure,
              (function (arg) {
                  if (arg.RE_EXN_ID === Stdlib.Failure) {
                    return {
                            TAG: /* List */1,
                            _0: {
                              hd: {
                                TAG: /* Atom */0,
                                _0: "Failure"
                              },
                              tl: {
                                hd: {
                                  TAG: /* Atom */0,
                                  _0: arg._1
                                },
                                tl: /* [] */0
                              }
                            }
                          };
                  }
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "sexp_conv.ml",
                          412,
                          15
                        ],
                        Error: new Error()
                      };
                })
            ],
            tl: {
              hd: [
                Stdlib.Not_found,
                (function (param) {
                    if (param.RE_EXN_ID === Stdlib.Not_found) {
                      return {
                              TAG: /* Atom */0,
                              _0: "Not_found"
                            };
                    }
                    throw {
                          RE_EXN_ID: "Assert_failure",
                          _1: [
                            "sexp_conv.ml",
                            416,
                            15
                          ],
                          Error: new Error()
                        };
                  })
              ],
              tl: {
                hd: [
                  Stdlib.Invalid_argument,
                  (function (arg) {
                      if (arg.RE_EXN_ID === Stdlib.Invalid_argument) {
                        return {
                                TAG: /* List */1,
                                _0: {
                                  hd: {
                                    TAG: /* Atom */0,
                                    _0: "Invalid_argument"
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* Atom */0,
                                      _0: arg._1
                                    },
                                    tl: /* [] */0
                                  }
                                }
                              };
                      }
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "sexp_conv.ml",
                              420,
                              15
                            ],
                            Error: new Error()
                          };
                    })
                ],
                tl: {
                  hd: [
                    Stdlib.Match_failure,
                    (function (arg) {
                        if (arg.RE_EXN_ID === Stdlib.Match_failure) {
                          return get_flc_error("Match_failure", arg._1);
                        }
                        throw {
                              RE_EXN_ID: "Assert_failure",
                              _1: [
                                "sexp_conv.ml",
                                424,
                                15
                              ],
                              Error: new Error()
                            };
                      })
                  ],
                  tl: {
                    hd: [
                      Sexp$negSexplib0.Not_found_s,
                      (function (arg) {
                          if (arg.RE_EXN_ID === Sexp$negSexplib0.Not_found_s) {
                            return {
                                    TAG: /* List */1,
                                    _0: {
                                      hd: {
                                        TAG: /* Atom */0,
                                        _0: "Not_found_s"
                                      },
                                      tl: {
                                        hd: arg._1,
                                        tl: /* [] */0
                                      }
                                    }
                                  };
                          }
                          throw {
                                RE_EXN_ID: "Assert_failure",
                                _1: [
                                  "sexp_conv.ml",
                                  428,
                                  15
                                ],
                                Error: new Error()
                              };
                        })
                    ],
                    tl: {
                      hd: [
                        Stdlib.Sys_error,
                        (function (arg) {
                            if (arg.RE_EXN_ID === Stdlib.Sys_error) {
                              return {
                                      TAG: /* List */1,
                                      _0: {
                                        hd: {
                                          TAG: /* Atom */0,
                                          _0: "Sys_error"
                                        },
                                        tl: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: arg._1
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    };
                            }
                            throw {
                                  RE_EXN_ID: "Assert_failure",
                                  _1: [
                                    "sexp_conv.ml",
                                    432,
                                    15
                                  ],
                                  Error: new Error()
                                };
                          })
                      ],
                      tl: {
                        hd: [
                          Arg.Help,
                          (function (arg) {
                              if (arg.RE_EXN_ID === Arg.Help) {
                                return {
                                        TAG: /* List */1,
                                        _0: {
                                          hd: {
                                            TAG: /* Atom */0,
                                            _0: "Arg.Help"
                                          },
                                          tl: {
                                            hd: {
                                              TAG: /* Atom */0,
                                              _0: arg._1
                                            },
                                            tl: /* [] */0
                                          }
                                        }
                                      };
                              }
                              throw {
                                    RE_EXN_ID: "Assert_failure",
                                    _1: [
                                      "sexp_conv.ml",
                                      436,
                                      15
                                    ],
                                    Error: new Error()
                                  };
                            })
                        ],
                        tl: {
                          hd: [
                            Arg.Bad,
                            (function (arg) {
                                if (arg.RE_EXN_ID === Arg.Bad) {
                                  return {
                                          TAG: /* List */1,
                                          _0: {
                                            hd: {
                                              TAG: /* Atom */0,
                                              _0: "Arg.Bad"
                                            },
                                            tl: {
                                              hd: {
                                                TAG: /* Atom */0,
                                                _0: arg._1
                                              },
                                              tl: /* [] */0
                                            }
                                          }
                                        };
                                }
                                throw {
                                      RE_EXN_ID: "Assert_failure",
                                      _1: [
                                        "sexp_conv.ml",
                                        440,
                                        15
                                      ],
                                      Error: new Error()
                                    };
                              })
                          ],
                          tl: {
                            hd: [
                              Lazy.Undefined,
                              (function (param) {
                                  if (param.RE_EXN_ID === Lazy.Undefined) {
                                    return {
                                            TAG: /* Atom */0,
                                            _0: "Lazy.Undefined"
                                          };
                                  }
                                  throw {
                                        RE_EXN_ID: "Assert_failure",
                                        _1: [
                                          "sexp_conv.ml",
                                          444,
                                          15
                                        ],
                                        Error: new Error()
                                      };
                                })
                            ],
                            tl: {
                              hd: [
                                Parsing.Parse_error,
                                (function (param) {
                                    if (param.RE_EXN_ID === Parsing.Parse_error) {
                                      return {
                                              TAG: /* Atom */0,
                                              _0: "Parsing.Parse_error"
                                            };
                                    }
                                    throw {
                                          RE_EXN_ID: "Assert_failure",
                                          _1: [
                                            "sexp_conv.ml",
                                            448,
                                            15
                                          ],
                                          Error: new Error()
                                        };
                                  })
                              ],
                              tl: {
                                hd: [
                                  Queue.Empty,
                                  (function (param) {
                                      if (param.RE_EXN_ID === Queue.Empty) {
                                        return {
                                                TAG: /* Atom */0,
                                                _0: "Queue.Empty"
                                              };
                                      }
                                      throw {
                                            RE_EXN_ID: "Assert_failure",
                                            _1: [
                                              "sexp_conv.ml",
                                              452,
                                              15
                                            ],
                                            Error: new Error()
                                          };
                                    })
                                ],
                                tl: {
                                  hd: [
                                    Scanf.Scan_failure,
                                    (function (arg) {
                                        if (arg.RE_EXN_ID === Scanf.Scan_failure) {
                                          return {
                                                  TAG: /* List */1,
                                                  _0: {
                                                    hd: {
                                                      TAG: /* Atom */0,
                                                      _0: "Scanf.Scan_failure"
                                                    },
                                                    tl: {
                                                      hd: {
                                                        TAG: /* Atom */0,
                                                        _0: arg._1
                                                      },
                                                      tl: /* [] */0
                                                    }
                                                  }
                                                };
                                        }
                                        throw {
                                              RE_EXN_ID: "Assert_failure",
                                              _1: [
                                                "sexp_conv.ml",
                                                456,
                                                15
                                              ],
                                              Error: new Error()
                                            };
                                      })
                                  ],
                                  tl: {
                                    hd: [
                                      Stack.Empty,
                                      (function (param) {
                                          if (param.RE_EXN_ID === Stack.Empty) {
                                            return {
                                                    TAG: /* Atom */0,
                                                    _0: "Stack.Empty"
                                                  };
                                          }
                                          throw {
                                                RE_EXN_ID: "Assert_failure",
                                                _1: [
                                                  "sexp_conv.ml",
                                                  460,
                                                  15
                                                ],
                                                Error: new Error()
                                              };
                                        })
                                    ],
                                    tl: {
                                      hd: [
                                        Stream.Failure,
                                        (function (param) {
                                            if (param.RE_EXN_ID === Stream.Failure) {
                                              return {
                                                      TAG: /* Atom */0,
                                                      _0: "Stream.Failure"
                                                    };
                                            }
                                            throw {
                                                  RE_EXN_ID: "Assert_failure",
                                                  _1: [
                                                    "sexp_conv.ml",
                                                    464,
                                                    15
                                                  ],
                                                  Error: new Error()
                                                };
                                          })
                                      ],
                                      tl: {
                                        hd: [
                                          Stream.$$Error,
                                          (function (arg) {
                                              if (arg.RE_EXN_ID === Stream.$$Error) {
                                                return {
                                                        TAG: /* List */1,
                                                        _0: {
                                                          hd: {
                                                            TAG: /* Atom */0,
                                                            _0: "Stream.Error"
                                                          },
                                                          tl: {
                                                            hd: {
                                                              TAG: /* Atom */0,
                                                              _0: arg._1
                                                            },
                                                            tl: /* [] */0
                                                          }
                                                        }
                                                      };
                                              }
                                              throw {
                                                    RE_EXN_ID: "Assert_failure",
                                                    _1: [
                                                      "sexp_conv.ml",
                                                      468,
                                                      15
                                                    ],
                                                    Error: new Error()
                                                  };
                                            })
                                        ],
                                        tl: {
                                          hd: [
                                            Sys.Break,
                                            (function (param) {
                                                if (param.RE_EXN_ID === Sys.Break) {
                                                  return {
                                                          TAG: /* Atom */0,
                                                          _0: "Sys.Break"
                                                        };
                                                }
                                                throw {
                                                      RE_EXN_ID: "Assert_failure",
                                                      _1: [
                                                        "sexp_conv.ml",
                                                        472,
                                                        15
                                                      ],
                                                      Error: new Error()
                                                    };
                                              })
                                          ],
                                          tl: /* [] */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

ListLabels.iter((function (param) {
        return add(true, false, param[0], param[1]);
      }), {
      hd: [
        Sexp$negSexplib0.Of_sexp_error,
        (function (param) {
            if (param.RE_EXN_ID === Sexp$negSexplib0.Of_sexp_error) {
              return {
                      TAG: /* List */1,
                      _0: {
                        hd: {
                          TAG: /* Atom */0,
                          _0: "Sexplib.Conv.Of_sexp_error"
                        },
                        tl: {
                          hd: sexp_of_exn(param._1),
                          tl: {
                            hd: param._2,
                            tl: /* [] */0
                          }
                        }
                      }
                    };
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "sexp_conv.ml",
                    484,
                    15
                  ],
                  Error: new Error()
                };
          })
      ],
      tl: /* [] */0
    });

var Of_sexp_error = Sexp$negSexplib0.Of_sexp_error;

var unit_sexp_grammar = Sexp_conv_grammar$negSexplib0.unit_sexp_grammar;

var bool_sexp_grammar = Sexp_conv_grammar$negSexplib0.bool_sexp_grammar;

var string_sexp_grammar = Sexp_conv_grammar$negSexplib0.string_sexp_grammar;

var bytes_sexp_grammar = Sexp_conv_grammar$negSexplib0.bytes_sexp_grammar;

var char_sexp_grammar = Sexp_conv_grammar$negSexplib0.char_sexp_grammar;

var int_sexp_grammar = Sexp_conv_grammar$negSexplib0.int_sexp_grammar;

var float_sexp_grammar = Sexp_conv_grammar$negSexplib0.float_sexp_grammar;

var int32_sexp_grammar = Sexp_conv_grammar$negSexplib0.int32_sexp_grammar;

var int64_sexp_grammar = Sexp_conv_grammar$negSexplib0.int64_sexp_grammar;

var nativeint_sexp_grammar = Sexp_conv_grammar$negSexplib0.nativeint_sexp_grammar;

var ref_sexp_grammar = Sexp_conv_grammar$negSexplib0.ref_sexp_grammar;

var lazy_t_sexp_grammar = Sexp_conv_grammar$negSexplib0.lazy_t_sexp_grammar;

var option_sexp_grammar = Sexp_conv_grammar$negSexplib0.option_sexp_grammar;

var list_sexp_grammar = Sexp_conv_grammar$negSexplib0.list_sexp_grammar;

var array_sexp_grammar = Sexp_conv_grammar$negSexplib0.array_sexp_grammar;

var opaque_sexp_grammar = Sexp_conv_grammar$negSexplib0.opaque_sexp_grammar;

var fun_sexp_grammar = Sexp_conv_grammar$negSexplib0.fun_sexp_grammar;

var Exn_converter = {
  add_auto: add_auto,
  add: add,
  For_unit_tests_only: For_unit_tests_only
};

exports.default_string_of_float = default_string_of_float;
exports.write_old_option_format = write_old_option_format;
exports.read_old_option_format = read_old_option_format;
exports.list_map = list_map;
exports.sexp_of_unit = sexp_of_unit;
exports.sexp_of_bool = sexp_of_bool;
exports.sexp_of_string = sexp_of_string;
exports.sexp_of_bytes = sexp_of_bytes;
exports.sexp_of_char = sexp_of_char;
exports.sexp_of_int = sexp_of_int;
exports.sexp_of_float = sexp_of_float;
exports.sexp_of_int32 = sexp_of_int32;
exports.sexp_of_int64 = sexp_of_int64;
exports.sexp_of_nativeint = sexp_of_nativeint;
exports.sexp_of_ref = sexp_of_ref;
exports.sexp_of_lazy_t = sexp_of_lazy_t;
exports.sexp_of_option = sexp_of_option;
exports.sexp_of_pair = sexp_of_pair;
exports.sexp_of_triple = sexp_of_triple;
exports.sexp_of_list = sexp_of_list;
exports.sexp_of_array = sexp_of_array;
exports.sexp_of_hashtbl = sexp_of_hashtbl;
exports.sexp_of_opaque = sexp_of_opaque;
exports.sexp_of_fun = sexp_of_fun;
exports.Of_sexp_error = Of_sexp_error;
exports.record_check_extra_fields = record_check_extra_fields;
exports.of_sexp_error = of_sexp_error;
exports.of_sexp_error_exn = of_sexp_error_exn;
exports.unit_of_sexp = unit_of_sexp;
exports.bool_of_sexp = bool_of_sexp;
exports.string_of_sexp = string_of_sexp;
exports.bytes_of_sexp = bytes_of_sexp;
exports.char_of_sexp = char_of_sexp;
exports.int_of_sexp = int_of_sexp;
exports.float_of_sexp = float_of_sexp;
exports.int32_of_sexp = int32_of_sexp;
exports.int64_of_sexp = int64_of_sexp;
exports.nativeint_of_sexp = nativeint_of_sexp;
exports.ref_of_sexp = ref_of_sexp;
exports.lazy_t_of_sexp = lazy_t_of_sexp;
exports.option_of_sexp = option_of_sexp;
exports.pair_of_sexp = pair_of_sexp;
exports.triple_of_sexp = triple_of_sexp;
exports.list_of_sexp = list_of_sexp;
exports.array_of_sexp = array_of_sexp;
exports.hashtbl_of_sexp = hashtbl_of_sexp;
exports.opaque_of_sexp = opaque_of_sexp;
exports.fun_of_sexp = fun_of_sexp;
exports.unit_sexp_grammar = unit_sexp_grammar;
exports.bool_sexp_grammar = bool_sexp_grammar;
exports.string_sexp_grammar = string_sexp_grammar;
exports.bytes_sexp_grammar = bytes_sexp_grammar;
exports.char_sexp_grammar = char_sexp_grammar;
exports.int_sexp_grammar = int_sexp_grammar;
exports.float_sexp_grammar = float_sexp_grammar;
exports.int32_sexp_grammar = int32_sexp_grammar;
exports.int64_sexp_grammar = int64_sexp_grammar;
exports.nativeint_sexp_grammar = nativeint_sexp_grammar;
exports.ref_sexp_grammar = ref_sexp_grammar;
exports.lazy_t_sexp_grammar = lazy_t_sexp_grammar;
exports.option_sexp_grammar = option_sexp_grammar;
exports.list_sexp_grammar = list_sexp_grammar;
exports.array_sexp_grammar = array_sexp_grammar;
exports.opaque_sexp_grammar = opaque_sexp_grammar;
exports.fun_sexp_grammar = fun_sexp_grammar;
exports.sexp_of_exn = sexp_of_exn;
exports.printexc_prefer_sexp = printexc_prefer_sexp;
exports.sexp_of_exn_opt = sexp_of_exn_opt;
exports.Exn_converter = Exn_converter;
/* Exn_ids Not a pure module */
