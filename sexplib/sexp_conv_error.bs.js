// Generated by Melange
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var ListLabels = require("bs-platform/lib/js/listLabels.js");
var StringLabels = require("bs-platform/lib/js/stringLabels.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Sexp_conv$negSexplib0 = require("./sexp_conv.bs.js");

function tuple_of_size_n_expected(loc, n, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(Curry._2(Printf.sprintf(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "_of_sexp: tuple of size ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: " expected",
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "%s_of_sexp: tuple of size %d expected"
                    }), loc, n), sexp);
}

function stag_no_args(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: sum tag does not take arguments", sexp);
}

function stag_incorrect_n_args(loc, tag, sexp) {
  var msg = Curry._2(Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* String_literal */11,
                _0: "_of_sexp: sum tag ",
                _1: {
                  TAG: /* Caml_string */3,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* String_literal */11,
                    _0: " has incorrect number of arguments",
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "%s_of_sexp: sum tag %S has incorrect number of arguments"
          }), loc, tag);
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

function stag_takes_args(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: sum tag must be a structured value", sexp);
}

function nested_list_invalid_sum(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: a nested list is an invalid sum", sexp);
}

function empty_list_invalid_sum(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: the empty list is an invalid sum", sexp);
}

function unexpected_stag(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: unexpected sum tag", sexp);
}

function record_sexp_bool_with_payload(loc, sexp) {
  var msg = loc + "_of_sexp: record conversion: a [sexp.bool] field was given a payload.";
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

function record_only_pairs_expected(loc, sexp) {
  var msg = loc + "_of_sexp: record conversion: only pairs expected, their first element must be an atom";
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

function record_superfluous_fields(what, loc, rev_fld_names, sexp) {
  var fld_names_str = StringLabels.concat(" ", ListLabels.rev(rev_fld_names));
  var msg = Curry._3(Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* String_literal */11,
                _0: "_of_sexp: ",
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* String_literal */11,
                    _0: ": ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: /* End_of_format */0
                    }
                  }
                }
              }
            },
            _1: "%s_of_sexp: %s: %s"
          }), loc, what, fld_names_str);
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

function record_duplicate_fields(loc, rev_fld_names, sexp) {
  return record_superfluous_fields("duplicate fields", loc, rev_fld_names, sexp);
}

function record_extra_fields(loc, rev_fld_names, sexp) {
  return record_superfluous_fields("extra fields", loc, rev_fld_names, sexp);
}

function record_get_undefined_loop(_fields, _param) {
  while(true) {
    var param = _param;
    var fields = _fields;
    if (!param) {
      return StringLabels.concat(" ", ListLabels.rev(fields));
    }
    var match = param.hd;
    if (match[0]) {
      _param = param.tl;
      _fields = {
        hd: match[1],
        tl: fields
      };
      continue ;
    }
    _param = param.tl;
    continue ;
  };
}

function record_undefined_elements(loc, sexp, lst) {
  var $$undefined = record_get_undefined_loop(/* [] */0, lst);
  var msg = Curry._2(Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* String_literal */11,
                _0: "_of_sexp: the following record elements were undefined: ",
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "%s_of_sexp: the following record elements were undefined: %s"
          }), loc, $$undefined);
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

function record_list_instead_atom(loc, sexp) {
  var msg = loc + "_of_sexp: list instead of atom for record expected";
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

function record_poly_field_value(loc, sexp) {
  var msg = loc + "_of_sexp: cannot convert values of types resulting from polymorphic record fields";
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

var No_variant_match = /* @__PURE__ */Caml_exceptions.create("Sexp_conv_error-Sexplib0.No_variant_match");

function no_variant_match(param) {
  throw {
        RE_EXN_ID: No_variant_match,
        Error: new Error()
      };
}

function no_matching_variant_found(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: no matching variant found", sexp);
}

function ptag_no_args(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: polymorphic variant does not take arguments", sexp);
}

function ptag_incorrect_n_args(loc, cnstr, sexp) {
  var msg = Curry._2(Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* String_literal */11,
                _0: "_of_sexp: polymorphic variant tag ",
                _1: {
                  TAG: /* Caml_string */3,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* String_literal */11,
                    _0: " has incorrect number of arguments",
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments"
          }), loc, cnstr);
  return Sexp_conv$negSexplib0.of_sexp_error(msg, sexp);
}

function ptag_takes_args(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: polymorphic variant tag takes an argument", sexp);
}

function nested_list_invalid_poly_var(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: a nested list is an invalid polymorphic variant", sexp);
}

function empty_list_invalid_poly_var(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: the empty list is an invalid polymorphic variant", sexp);
}

function empty_type(loc, sexp) {
  return Sexp_conv$negSexplib0.of_sexp_error(loc + "_of_sexp: trying to convert an empty type", sexp);
}

var Of_sexp_error = Sexp_conv$negSexplib0.Of_sexp_error;

exports.Of_sexp_error = Of_sexp_error;
exports.tuple_of_size_n_expected = tuple_of_size_n_expected;
exports.stag_no_args = stag_no_args;
exports.stag_incorrect_n_args = stag_incorrect_n_args;
exports.stag_takes_args = stag_takes_args;
exports.nested_list_invalid_sum = nested_list_invalid_sum;
exports.empty_list_invalid_sum = empty_list_invalid_sum;
exports.unexpected_stag = unexpected_stag;
exports.record_sexp_bool_with_payload = record_sexp_bool_with_payload;
exports.record_only_pairs_expected = record_only_pairs_expected;
exports.record_superfluous_fields = record_superfluous_fields;
exports.record_duplicate_fields = record_duplicate_fields;
exports.record_extra_fields = record_extra_fields;
exports.record_get_undefined_loop = record_get_undefined_loop;
exports.record_undefined_elements = record_undefined_elements;
exports.record_list_instead_atom = record_list_instead_atom;
exports.record_poly_field_value = record_poly_field_value;
exports.No_variant_match = No_variant_match;
exports.no_variant_match = no_variant_match;
exports.no_matching_variant_found = no_matching_variant_found;
exports.ptag_no_args = ptag_no_args;
exports.ptag_incorrect_n_args = ptag_incorrect_n_args;
exports.ptag_takes_args = ptag_takes_args;
exports.nested_list_invalid_poly_var = nested_list_invalid_poly_var;
exports.empty_list_invalid_poly_var = empty_list_invalid_poly_var;
exports.empty_type = empty_type;
/* Sexp_conv-Sexplib0 Not a pure module */
